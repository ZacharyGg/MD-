

# 					JVM

#一：JVM虚拟机

## 1.ExactVM

## 2.HotSpotVM(目前主流的JVM)

![HotSpot](/images/20181023092818.bmp)

​	目前一般都是hotSpot的虚拟机。  Server版本 ， 貌似是根据CPU核数、内存自动判断是服务器版还是客户端版，以目前的硬件水平基本属于server

## 3.KVM

## 4.JRockit

## 5.J9

## 6.dalvik

## 7.MicorsoftJVM



# 二：判断对象是否存活

 ## 1.引用计数器法

​	创建一个计数器，对使用的对象引用了进行+1，而赋值成null则-1；在栈中对堆的引用有效，但是在堆之间的互相引用则无法使用，目前都不用该计算方法。

## 2.可达性分析法

​         对对象进行可达性的检测，若无法到达该堆 则进行清除。。目前采用的都是该分析法。

# 三：垃圾回收算法

## 1.标记清除算法

​	**它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除**。	

​	**标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。**

​	**清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。**

​	**就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行**。

​	

​	**缺点：**

​	1.**它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲**

​	2.**这种方式清理出来的空闲内存是不连续的**



![](/images/20181023114113.bmp)

## 2.复制算法

​	将可用的内存按容量划分为大小相等的两块（from，to），每次只是用其中一块（总有一块是空的【to区域】）。当这一苦熬的内存用完了，就将还存活着的对象复制到另外一块上面，然后把已使用过的内存空间一次清理完。

HotSpot虚拟机默认Eden和Survivor大小的比例是8:1，也就是每次新生代中可用的内存空间为整个新生代容量的90%，只有10%的内存时被浪费的。

缺点：浪费内存空间，如果对象存活率较高时要执行较多的复制操作，效率降低。

优点：有一块内存区域是空的，一般是to区域。保留区域每次回收后都因为复制的时候让他们变为连续的地址空间，所有不产生内存碎片。

![](/images/20181023114246.bmp)



## 3.标记整理算法

​	标记整理算法的“标记”过程和标记-清除算法一致，只是后面并不是直接对可回收对象进行整理，而是让所有存活的对象都向一段移动，然后直接清理掉端边界意外的内存。

​	由于标记后继续整理，可以很明显的看出未使用的地址空间都是连续的，不会产生内存碎片。

![](/images/20181023114408.bmp)

## 4.分代收集算法

​	当前商业虚拟机基本上都是采用**分代垃圾回收算法**来回收垃圾，思想也很简单，就是根据对象的生命周期将内存划分，然后进行分区管理。

​	在Java虚拟机分代垃圾回收机制中，应用程序可用的堆空间可以分为**年轻代**与**老年代**，然后呢，年亲代有被分为**Eden区，From区与To区**。 

​		 ![](/images/20181023114619.bmp)

当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次**YoungGC**，也就是**年轻代的垃圾回收**。

一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。 

​			![](/images/20181023114655.bmp)

这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，**会将Eden区与From区还在被使用的对象复制到To区**，

​		![](/images/20181023114731.bmp)

再下一次YoungGC的时候，则是将**Eden区与To区中的还在被使用的对象复制到From区**。 

​			![](/images/20181023114812.bmp)

经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。 

​			![](/images/20181023114847.bmp)

老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收，一起滚蛋吧。

全量回收呢，就好比我们刚才比作的大扫除，毕竟动做比较大，成本高，不能跟平时的小型值日（Young GC）相比，所以如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。

**所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作**

#四：垃圾回收器

   		对垃圾回收算法的实现封装。

![垃圾收集器](/images/20181022150335.bmp)



## 1.serial收集器

​       串行收集器是最基本、发展时间最长、久经考验的垃圾收集器，也是client模式下的默认收集器配置。

串行收集器采用单线程stop-the-world的方式进行收集。当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。单线程也意味着复杂度更低、占用内存更少，但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核CPU的场合。



​       线程收集器。      适合新老年代

​      当收集器启动时，程序运行的线程都需要停止等待回收，等回收完成后程序运行线程继续运行。

​	目前用的很少，客户端桌面应用场景蛮适合。

![串行收集器](/images/20181022144354.bmp)

## 2.parnew收集器

​	复制算法    多线程收集器   新生代收集器   

## 3.parallel收集器

​	复制算法    新生代的收集器

​        多线程收集器



并行收集器是以关注吞吐量为目标的垃圾收集器，也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代Parallel Scavenge收集器上。

并行收集器与串行收集器工作模式相似，都是stop-the-world方式，只是暂停时并行地进行垃圾收集。年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩。关注吞吐量主要指年轻代的Parallel Scavenge收集器，通过两个目标参数-XX:MaxGCPauseMills和-XX:GCTimeRatio，调整新生代空间大小，来降低GC触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。

​	与Parnew收集器的关注点不同：  parnew关注缩短GC时间，而parallel关注可控制的吞吐量

​	-XX: MaxGCPasuseMillis  垃圾收集器停顿时间

​	-XX：GCTimeRatio 吞吐量大小

![并行收集器](/images/20181022145100.bmp)

## 4.CMS收集器 （Concurrent Mark Sweep）

​	用在老年代中的收集器  （只能配合serial或者parnew新生代收集器使用，无法与parallel配合使用）

​	工作过程：     初始标记-------->并发标记-------->重新标记-------->并发整理

​	优点：  并发收集  、低停顿

​        缺点： 1.占用大量CPU  2.无法处理浮动垃圾  3.出现Concurrent Mode Failure  4.空间碎片

![并发标记清除收集器](/images/20181022145141.bmp)

​	并发标记清除(CMS)是以关注延迟为目标、十分优秀的垃圾回收算法，开启后，年轻代使用STW式的并行收集，老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现在老年代CMS上。

​	年轻代ParNew与并行收集器类似，而老年代CMS每个收集周期都要经历：初始标记、并发标记、重新标记、并发清除。其中，初始标记以STW的方式标记所有的根对象；并发标记则同应用线程一起并行，标记出根对象的可达路径；在进行垃圾回收前，CMS再以一个STW进行重新标记，标记那些由mutator线程(指引起数据变化的线程，即应用线程)修改而可能错过的可达对象；最后得到的不可达对象将在并发清除阶段进行回收。值得注意的是，初始标记和重新标记都已优化为多线程执行。CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。

​	但是CMS并不完美，它有以下缺点：

1. 由于并发进行，CMS在收集与应用线程会同时会增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间；	
2. 标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数`-XX:CMSFullGCsBeForeCompaction`(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC。

## 5.G1收集器(Garbage First)

​	最牛的垃圾收集器，在上面的收集器都有几个共同点：

1. 年轻代、老年代是独立且连续的内存块；
2. 年轻代收集使用单eden、双survivor进行复制算法；
3. 老年代收集必须扫描整个老年代区域；
4. 都是以尽可能少而块地执行GC为设计原则。



同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。



G1垃圾收集器也是以关注延迟为目标、服务器端应用的垃圾收集器，被HotSpot团队寄予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。虽然G1也有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。事实上，G1收集与以上三组收集器有很大不同：

1. G1的设计原则是”首先收集尽可能多的垃圾(Garbage First)“。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；
2. G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；
3. G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；
4. G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。



![G1](/images/20181022145251.bmp)

# 五：内存的分配和回收

​     **内存分配策略**

1. 优先分配至eden
2. 大对象直接分配到老年代
3. 长期存活的的对象分配到老年代
4. 空间非配担保
5. 动态对象年龄判断

逃逸分析与栈上分配

​	**元空间的本质和永久代类似，都是对JVM规范中的方法区的实现。最大区别在于元空间使用的是本地内存，永久代使用的是虚拟机内存，元空间的大小只受本地内存的限制。**



# 六：虚拟机工具

​	使用工具运用知识快速定位问题。 windows系统有部分命令无法使用，但是可在linux上可以。

​		

## 1.jps(Java Process status)

![Jps](/images/20181023093828.bmp)

​	查看进程信息，

​	jps  -l  查看进行详细信息，启动的主类

​       jps  -m  可查看到进行运行时传入主类的参数

​       jps  -v  可查看接收的虚拟机参数

## 2.jstat

​	 依赖于jps，需要知道进程ID。



​	![jstat](/images/20181023095009.bmp)



![](/images/20181023095241.bmp)

## 3.jinfo

​	实时查看和及时调整虚拟机的各项参数

​	![](/images/20181023100113.bmp)



![](/images/20181023100156.bmp)

## 4.jmap

​	查看堆存储、快照等功能。

​	![](/images/20181023100416.bmp)

​	

![](/images/20181023101012.bmp)

## 5.jhat(JVM heap analysis tool)

​	对生成的快照进行分析。    对CPU和内存的占用率很高，一般不用该命令

![](/images/20181023101748.bmp)

​	

![](/images/20181023101851.bmp)



![](/images/20181023102228.bmp)

查询很慢，也很耗资源。 Object Query Language

## 6.jstack

  	用于生成线程快照，可定位线程出现停顿时出现的问题以及其他很多问题。

​	![](/images/20181023102659.bmp)

​	

​	可使用管道命令

![](/images/20181023102932.bmp)



## 7.jconsole

![](/images/20181023103702.bmp)

![](/images/20181023103741.bmp)



## 8.VisualVM

目前主流的JVM监视工具

[下载链接地址](https://visualvm.github.io/download.html)

还可以自己下载插件进行安装。



![/images/20181023112011.bmp](/images/20181023112011.bmp)



# 七：性能调优

​                知识 ----工具-----数据-----经验

## 1.案例1

​		

## 2.案例2

​	

## 3.案例3

# 八：Class文件

​	javac把java文件编译转成class文件， jvm对class文件进行执行。

![](/images/20181023151608.bmp)

​	 Java是与平台无关的语言，这得益于Java源代码编译后生成的存储字节码的文件，即Class文件，以及Java虚拟机的实现。不仅使用Java编译器可以把Java代码编译成存储字节码的Class文件，使用JRuby等其他语言的编译器也可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是什么语言，只要它符合一定的结构，就可以在Java中运行。Java语言中的各种变量、关键字和运算符的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更强大，这便为其他语言实现一些有别于Java的语言特性提供了基础，而且这也正是在类加载时要进行安全验证的原因。

![](/IMAGES/20181024112006.bmp)



## 1.文件结构概述



- class文件是一组以8位字节位基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列再Class文件中，中间没有添加任何分隔符，整个Class文件中的存储的内容几乎全部是程序运行的必要数据，没有空隙的存在。


- 当遇到8位字节以上的空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。


- 根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：无符号数和表。

  **无符号数属于基本数据类型，以u1、u2、u4、u8来分别代表1、2、4、8个字节的无符号数。表是由多个无符号数或其他表作为数据项构成的符合数据类型，所有的表都习惯性地以“_info”结尾。**

  ​

![](/images/20181023153837.bmp)

![](/images/20181023155332.bmp)



```java
ClassFile {
    u4 magic; 
    u2 minor_version; 
    u2 major_version; 
    u2 constant_pool_count; 
    cp_info constant_pool[constant_pool_count-1];
    u2 access_flags; 
    u2 this_class; 
    u2 super_class; 
    u2 interfaces_count; 
    u2 interfaces[interfaces_count]; 
    u2 fields_count; 
    field_info fields[fields_count]; 
    u2 methods_count; 
    method_info methods[methods_count]; 
    u2 attributes_count; 
    attribute_info attributes[attributes_count]; 
}
```



## 2.Class文件设计理念及意义







## 3.文件结构

### 1.魔数和版本

  CAFE BABE 代表类文件

  CAFE DEAD 代表持久化对象，但是该技术以消失被RMI代替。



CAFE BABE  :代表class类的文件表示魔数。

34是14进制 ，转成10进制 位 52 ，是JDK1.8版本



CAFEBABE 后面的 00 00 2个字节是代表小版本号

00 34  2个字节是代表大版本号



![](/images/20181023164309.bmp)



![](/images/20181023164155.bmp)

​			![](/images/2118438-eabfebb54c27da04.png)



### 2.常量池



​	  major_version之后是常量池（constant_pool）的入口，它是Class文件中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。

​	  常量池中主要存放两大类常量：**字面量和符号引用**。字面量比较接近于Java层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用总结起来则包括了下面三类常量：

- 类和接口的全限定名（即带有包名的Class名，如：org.lxh.test.TestClass）
- 字段的名称和描述符（private、static等描述符）
- 方法的名称和描述符（private、static等描述符）

​       **虚拟机在加载Class文件时才会进行动态连接**，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。

​	

- **符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。**
- **直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。**




```java
cp_info { 
    u1 tag; 
    u1 info[]; 
}
```

其中，**tag表示常量的类型**，**info[]代表tag类型所属的表项**。



| 常量                                       | 项目     | 类型    | 描述                                       |
| :--------------------------------------- | ------ | :---- | :--------------------------------------- |
| CONSTANT_Utf8_info                       | tag    | u1    | 值为1                                      |
| (用于表示字符串常量的值)                            | length | u2    | UF-8编码的字符串占用的字节数                         |
|                                          | bytes  | u1    | 长度为length的UTF-8编码的字符串                    |
| CONSTANT_Integer_info                    | tag    | u1    | 值为3                                      |
| 表示4字节(int)的数值常量                          | bytes  | u4    | 按照高位在前存储的int值                            |
| CONSTANT_Float_info                      | tag    | u1    | 值为4                                      |
| 表示4字节(float)的数值常量                        | bytes  | u4    | 按照高位在前存储的float值                          |
| CONSTANT_Long_info                       | tag    | u1    | 值为5                                      |
| 表示8字节(long)的数值常量                         | bytes  | u8    | 按照高位在前存储的long值                           |
| CONSTANT_Double_info                     | tag    | u1    | 值为6                                      |
| 表示8字节(double)的数值常量                       | bytes  | u8    | 按照高位在前存储的double值                         |
| CONSTANT_Class_info                      | tag    | u1    | 值为7                                      |
| 表示类或接口的完全限定名                             | index  | u2    | 指向全限定名常量项的索引                             |
| CONSTANT_String_info                     | tag    | u1    | 值为8                                      |
| 用于表示java.lang.String类型常量对象               | index  | u2    | 指向字符串字面量的索引                              |
| CONSTANT_Fieldref_info                   | tag    | u1    | 值为9                                      |
| 用于表示类中的字段                                | index  | u2    | 指向声明字段的类或接口描述符CONSTANT_Class_info的索引项    |
|                                          | index  | u2    | 指向字段名称及类型描述符CONSTANT_NameAndType_info的索引项 |
| CONSTANT_Methodref_info                  | tag    | u1    | 值为10                                     |
| 用于表示类中的方法                                | index  | u2    | 指向声明方法的类描述符CONSTANT_Class_info的索引项       |
|                                          | index  | u2    | 指向方法名称及类型描述符CONSTANT_NameAndType_info的索引项 |
| CONSTANT_InrerfaceMethodref_info         | tag    | u1    | 值为11                                     |
| 表示类所实现接口的方法                              |        | index | u2指向声明方法的接口描述符CONSTANT_Class_info的索引项    |
|                                          | index  | u2    | 指向方法名称及类型描述符CONSTANT_NameAndType_info的索引项 |
| CONSTANT_NameAndType_info                | tag    | u1    | 值为12                                     |
| 表示字段或方法的名称和类型                            | index  | u2    | 指向字段或方法名称常量项目的索引                         |
|                                          | index  | u2    | 指向该字段或方法描述符常量项的索引                        |
| CONSTANT_MethodHandle_info               |        |       | 15                                       |
| 表示方法的句柄                                  |        |       |                                          |
|                                          |        |       |                                          |
| CONSTANT_MethodType_info                 |        |       | 16                                       |
| 表示方法类型                                   |        |       |                                          |
|                                          |        |       |                                          |
| CONSTANT_InvokeDynamic_info              |        |       | 18                                       |
| 表示invokedynamic指令所使用到的引导方法、引导方法使用到动态调用名称、参数和请求返回类型、以及可以选择性的附加被称位静态参数的常量序列 |        |       |                                          |
|                                          |        |       |                                          |



​	![](/images/20181024103952.bmp)

​	

- **CONSTANT_Methodref_info**



```java
CONSTANT_Methodref_info { 
    u1 tag; 
    u2 class_index; 
    u2 name_and_type_index; 
}
```

​	**tag**表示当前数据类型CONSTANT_Methodref_info，说明这个常量是一个方法。

​	**class_index**表示引用这个方法的对象在常量池数组的中索引，说明**constant_pool[class_index]**存放的就是调用该方法的对象名称。

​	**name_and_type_index**指的该方法在常量池数组的中索引，即**constant_pool[name_and_type_index]**存放着该方法的名称。



- **CONSTANT_Class_info**

  ```java
  CONSTANT_Class_info {
       u1 tag; 
       u2 name_index; 
  }
  ```

  ​





### 3.访问标志

​	

| 标志名            | 标志值    | 标志含义                | 针对的对像 |
| -------------- | ------ | ------------------- | ----- |
| ACC_PUBLIC     | 0x0001 | public类型            | 所有类型  |
| ACC_FINAL      | 0x0010 | final类型             | 类     |
| ACC_SUPER      | 0x0020 | 使用新的invokespecial语义 | 类和接口  |
| ACC_INTERFACE  | 0x0200 | 接口类型                | 接口    |
| ACC_ABSTRACT   | 0x0400 | 抽象类型                | 类和接口  |
| ACC_SYNTHETIC  | 0x1000 | 该类不由用户代码生成          | 所有类型  |
| ACC_ANNOTATION | 0x2000 | 注解类型                | 注解    |
| ACC_ENUM       | 0x4000 | 枚举类型                | 枚举    |



### 4.类索引

​	分别是**this_class ， super_class ， interfaces_count和interfaces** 。 这三个数据项分别描述了当前类（就是当前class文件所在的类）， 当前类所继承的超类， 和当前类所实现的接口（如果当前class文件代表的是一个接口， 那么 interfaces_count和interfaces描述的是当前接口所继承的超接口）。

这几个数据项都持有指向常量池的索引。 真实的信息都是存放在常量池中的， 只不过常量池中的这些信息会被this_class ， super_class ， interfaces_count和interfaces 引用。



### 5.字段表集合

​		![](/images/20181024113042.bmp)

![](/images/20181024113239.bmp)



```
field_info{
  u2 access_flag;
  u2  name_index;
  u2 descriptor_index;
  u2 attribute_count;
  attribute_info  attributes[attributes_count]
}
```

​			![](/images/20181024134900.bmp)

### 6.方法表集合 



```java
Method_info{
  u2 Access_flag;
  u2 Name_index;
  u2 Descriptor_index;
  u2 attributes_count;
  attribute_info attributes[attributes_count];
}
```

​		![](/images/20181024135004.bmp)

### 7.属性表集合

​		

```java
attribute_info{
  u2 attribute_name_index;
  u4 attribute_length
  u1 info[attribute_length]
}
```



# 九：字节码指令集

​	基于栈的架构的指令集。和基于寄存器架构的指令集不同。

​	这里只讲述常用的指令，详细的可以参考《JAVA虚拟机规范》。

​	**Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码以及跟随其后的零至多个代表此操作所需参数的操作数所构成。虚拟机中许多指令并不包含操作数，只是一个操作码。**

​		![](/images/20181024141314.bmp)



## 1.字节码与数据类型

​	在虚拟机的指令集中，大多数指令都包含了起操作所对应的数据类型信息，也有不包含类型信息的。

指令集是由一个字节进行定义，最多有256个指令，为了不超过数量，内部有进行转换、直接引用的方式。



i:代表对int类型的数据操作，  l 代表long , s代表short ,b 代表byte ,c 代表char ，f 代表float ,d 代表double,a代表reference。

​		![](/images/20181024165406.bmp)



## 2.加载与存储指令

​	**加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。**

​	**具体详细查看《JAVA虚拟机规范》**

- 将局部变量表加载到操作数栈中： iload  lload fload  dload aload


- 将以个数值从操作数栈存储到局部变量表中： istore -----

-  

  ![](/images/20181024165443.bmp)

  ​

  ​

  ​

  ![](/images/20181024143048.bmp)



![](/images/20181024143152.bmp)

![](/images/20181024143231.bmp)



## 3.算数指令

 ![](/images/20181024165651.bmp)



## 4.类型转换指令

​		![](/images/20181024165945.bmp)



![](/images/20181024170051.bmp)





## 5.对象的创建与操作

![](/images/20181024170140.bmp)

## 6.操作数栈管理指令

​		![](/images/20181024170226.bmp)



## 7.控制转移指令

​		![](/images/20181024170255.bmp)

​	

## 8.方法调用和返回指令

​	![](/images/20181024170412.bmp)



## 9.抛出异常

​			![](/images/20181024170439.bmp)

## 10.同步







# 十：类加载机制



​						**加载-------连接-----初始化-----使用------卸载**









## 1.类加载时机

​	主流虚拟机都采用的是懒加载机制。

​	 **初始化：**

​	1.遇到new、getstatic、pubstatic或invokestaic这4条字节码指令时，如果类没有进行过初始化，则需要先出发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候。

​	2.使用Java.lang,refler包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

​       3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先出发其父类的初始化。

​       4.当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。



​	**不会被初始化：**

​	1.通过子类引用父类的静态字段，子类不会被初始化。

​	2.通过数组定义来引用类，类不会被初始化。

​	3.调用类的常量，类不会加载初始化。



## 2.类加载过程

​			加载和连接是并行处理的， 只是加载先开始。 （验证、准备、解析都属于连接阶段）

### 	1.加载

1. **通过一个类的全限定名来获取定义此类的二进制流**

   ​	只要一个符合格式的二进制流都可以：  文件(class文件、Jar文件等)、网络、计算生成一个二进制流($Proxy、)、由其他文件生成(jsp)、数据库等。

2. **将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。**

   ​	像配置文件，spring大量使用的bean文件等都需要转化成虚拟机能识别的数据结构。

3. **在内存中生成一个代表这个类的class对象，作为这个类的各种数据的访问入口。**

   

   

   

   2.验证

   ```
   	验证是连接的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
   ```

- 文件格式验证

- 元数据验证

- 字节码验证

- 符号引用校验

  

  ### 3.准备

  

  		准备阶段正式为类变量分配内存并设置变量的初始值。这些变量使用的内存都将在方法区中进行分配。
  	
  		这里的初始值并非我们指定的值，而是其默认值。但是如果 被final修饰，那么在这个过过程，常量值会被一同指定。



### 	4.解析

 		解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。

- 类或接口的解析
- 字段的解析
- 类方法解析
- 接口方法解析



### 	5.初始化

​	初始化是类加载的最后一步，初始化是执行<clinit>()方法的过程。







## 3.类加载器

### 	1.启动类加载器

​			由c++实现，是虚拟机的一部分，用于加载javahome下的lib的目录下的类。

### 	2.扩展类加载器

​			加载javahome下的/lib/ext目录中的类	

### 	3.应用程序类加载器

​		加载用户类路径上所指定的类库

### 	4.自定义类加载器

​			定义一个类，继承CLASSLoader---重写loadclass方法----实例化class对象。







## 4.双亲委派模型加载

​		![](/images/20181026173343.bmp)

​	1.如果一个类加载器收到了类加载请求，它首先不会自己尝试区加这个类，而是把类加载请求委派给父类加载器去完成。

 	2.每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器。

​	3.如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundExcpetion，而不再调用其子类加载器去进行类加载。



**优点是java类它的类加载器一起具备了一种优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了程序的稳定运行。**



# 十一：虚拟机字节码执行引擎

## 1.运行时栈帧结构

- 局部变量表



- 操作数栈



- 动态连接

- 方法返回地址

  - 方法调用时通过一个指向方法的指针指向方法的地址，方法返回时将回归到调用处，那个地方是返回地址。

- 附加信息

  虚拟机规范中允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中。这部分信息完全取决于虚拟机的实现。





​	 

## 2.方法的调用

### 	1.解析调用

​			方法调用并不等同于方法的执行，方法调用阶段的唯一任务就是确定被调用方法的版本。

### 	2.分派调用

​			1.静态分派调用

​				m名密码                              

​			2.动态分派调用



## 3.动态类型语言的支持

​	![](/images/20181029153953.bmp)





