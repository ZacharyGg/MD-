零散笔记



# 1.java多线程:  Thread 、Runnable、Callable

​	**多线程编程优点**

​	1.进程之间不能共享内存，但线程之间共享内存非常容易

​	2.系统创建线程所分配的资源相对于创建进程而言，代价非常小。

​	**Java中实现多线程有3中方法**

​	1.继承Thread接口

​	2.实现Runnable接口

​	3.实现Callable接口

​	

​	第一种实现---继承Thread类

继承Thread类，需要覆盖方法 run()方法，在创建Thread类的子类时需要重写 run(),加入线程所要执行的代即可。 

​	

```java
public class ThreadTest {
    public static void main(String[] args) throws Exception {
        new MyThread().start();
        new MyThread().start();
        new MyThread().start();
    }
}
class MyThread extends Thread{
    private int ticket = 5;

    @Override
    public void run() {
            for (int i = 0; i < 10; i++) {
                if(ticket>0){
                    System.out.println("车票第+" + ticket--+"张");
            }
        }
    }
}
```

这样代码的写法简单，符合大家的习惯，但是直接继承Thread类有一个很大的缺点，因为“java类的继承是单一的，extends后面只能指定一个父类”，所有如果当前类继承Thread类之后就不可以继承其他类。如果我们的类已经从一个类继承（如Swing继承自 Panle 类、JFram类等），则无法再继承 Thread 类，这时如果我们又不想建立一个新的类，应该怎么办呢？ 



第二种实现--实现Runnable接口



如果要实现多继承就得要用**implements**，Java 提供了接口 **java.lang.Runnable** 来解决上边的问题。

**Runnable**是可以共享数据的，多个Thread可以同时加载一个**Runnable**，当各自Thread获得CPU时间片的时候开始运行**Runnable**，**Runnable**里面的资源是被共享的，所以使用**Runnable**更加的灵活。



```java
public class ThreadRunnable {
    public static void main(String[] args) throws Exception {
        MyThread1 myThread1 = new MyThread1();
        new Thread( myThread1 ).start();
        new Thread( myThread1 ).start();
    }
}

class MyThread1 implements Runnable{
    private int ticket = 5;
    @Override
    public void run() {
            for (int i = 0; i < 10; i++) {
                if(ticket>0){
                    System.out.println("车票第+" + ticket--+"张");
            }
        }
    }
}


车票第+5张
车票第+2张
车票第+1张
车票第+3张
车票第+4张
```

1. 在第二种方法（**Runnable**）中，ticket输出的顺序并不是54321，这是因为线程执行的时机难以预测，ticket--并不是原子操作(关于原子操作后边会有详解)。
2. 在第一种方法中，我们new了3个Thread对象，即三个线程分别执行三个对象中的代码，因此便是三个线程去独立地完成卖票的任务；而在第二种方法中，我们同样也new了3个**Thread**对象，但只有一个**Runnable**对象，3个**Thread**对象共享这个**Runnable**对象中的代码，因此，便会出现3个线程共同完成卖票任务的结果。如果我们new出3个Runnable对象，作为参数分别传入3个**Thread**对象中，那么3个线程便会独立执行各自**Runnable**对象中的代码，即3个线程各自卖5张票。
3. 在第二种方法中，由于3个**Thread**对象共同执行一个**Runnable**对象中的代码，因此可能会造成线程的不安全，比如可能ticket会输出-1（如果我们System.out....语句前加上线程休眠操作，该情况将很有可能出现），这种情况的出现是由于，一个线程在判断ticket为1>0后，还没有来得及减1，另一个线程已经将ticket减1，变为了0，那么接下来之前的线程再将ticket减1，便得到了-1。这就需要加入同步操作（即互斥锁），确保同一时刻只有一个线程在执行每次for循环中的操作。而在第一种方法中，并不需要加入同步操作，因为每个线程执行自己Thread对象中的代码，不存在多个线程共同执行同一个方法的情况。



第三种实现---Callable接口

​	**Runnable**是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成的能返回一个值，那么可以实现**Callable**接口而不是**Runnable**接口。在Java SE5中引入的**Callable**是一种具有类型参数的泛型，它的参数类型表示的是从方法**call**()(不是**run**())中返回的值。 



​	

```java
public class ThreadCallable {
    public static void main(String[] args) throws Exception{
        MyThread2 myThread2 = new MyThread2();

        FutureTask<Integer> futureTask = new FutureTask<Integer>( myThread2 );
        new Thread( futureTask,"线程名：有返回值的线程2" ).start();

        System.out.println("子线程的返回值：" + futureTask.get());

    }
}
class MyThread2 implements Callable<Integer>{

    @Override
    public Integer call() throws Exception {
        System.out.println("当前线程名——" + Thread.currentThread().getName());
        int i = 0;
        for (; i < 5; i++) {
            System.out.println( "循环变量i的值：" + i );
        }
        return i;
    }
}



当前线程名——线程名：有返回值的线程2
循环变量i的值：0
循环变量i的值：1
循环变量i的值：2
循环变量i的值：3
循环变量i的值：4
子线程的返回值：5

Process finished with exit code 0

```





总结：

实现**Runnable**接口相比继承**Thread**类有如下优势： 

​	

1. 可以避免由于Java的单继承特性而带来的局限；
2. 增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；
3. 适合多个相同程序代码的线程区处理同一资源的情况。



实现**Runnable**接口和实现**Callable**接口的区别: 

​	

1. Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的
2. Callable规定的方法是call(),Runnable规定的方法是run()
3. Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)
4. call方法可以抛出异常，run方法不可以
5. 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。
6. 加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。

![](/images/20181108113457.bmp)



# 2.Java锁--synchronized、Lock

**锁的类型**

1.可重入锁： 在执行对象中所有同步方法不用再次获取锁

2.可中断锁：再等待获取锁过程可中断

3.公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利 

4.读写锁： 对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写 



| 类别     | synchronized                                                 | lock                                                         |
| :------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存在层次 | Java的关键字，在jvm层面上                                    | 是一个类                                                     |
| 锁的释放 | 1、以获取锁的线程执行完同步代码，释放锁 <br />2、线程执行发生异常，jvm会让线程释放锁 | 在finally中必须释放锁，不然容易造成线程死锁                  |
| 锁的获取 | 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待   | 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待 |
| 锁状态   | 无法判断                                                     | 可以判断                                                     |
| 锁类型   | 可重入 不可中断 非公平                                       | 可重入 可判断 可公平（两者皆可）                             |
| 性能     | 少量同步                                                     | 大量同步                                                     |



**synchronized**

```java
//修饰方法
public synchronized void method()
{
   // todo
}

//修饰代码块
public void method()
{
   synchronized(this) {
      // todo
   }
}

//修饰对象
public void method3(SomeObject obj)
{
   //obj 锁定的对象
   synchronized(obj)
   {
      // todo
   }
}



//修饰类
class ClassName {
   public void method() {
      synchronized(ClassName.class) {
         // todo
      }
   }
}
```

总结：

A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 

C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。



**Lock**

下是Lock接口的源码，修剪之后的结果： 

```java
public interface Lock {

    /**
     * Acquires the lock.
     */
    void lock();

    /**
     * Acquires the lock unless the current thread is
     * {@linkplain Thread#interrupt interrupted}.
     */
    void lockInterruptibly() throws InterruptedException;

    /**
     * Acquires the lock only if it is free at the time of invocation.
     */
    boolean tryLock();

    /**
     * Acquires the lock if it is free within the given waiting time and the
     * current thread has not been {@linkplain Thread#interrupt interrupted}.
     */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    /**
     * Releases the lock.
     */
    void unlock();

    /**
     * Returns a new {@link Condition} instance that is bound to this
     * {@code Lock} instance.
     */
    Condition newCondition();
}
```

lock()：获取锁，如果锁被暂用则一直等待

unlock():释放锁

tryLock(): 注意返回类型是boolean，如果获取锁的时候锁被占用就返回false，否则返回true

tryLock(long time, TimeUnit unit)：比起tryLock()就是给了一个时间期限，保证等待参数时间

lockInterruptibly()：用该锁的获得方式，如果线程在获取锁的阶段进入了等待，那么可以中断此线程，先去做别的事



lock()

```java
public class LockTest {
    private Lock lock = new ReentrantLock();

    //需要参与同步的方法
    private void method(Thread thread){
        lock.lock();
        try {
            System.out.println("线程名"+thread.getName() + "获得了锁");
        }catch(Exception e){
            e.printStackTrace();
        } finally {
            System.out.println("线程名"+thread.getName() + "释放了锁");
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        LockTest lockTest = new LockTest();

        //线程1
        Thread t1 = new Thread(new Runnable() {

            @Override
            public void run() {
                lockTest.method(Thread.currentThread());
            }
        }, "t1");

        Thread t2 = new Thread(new Runnable() {

            @Override
            public void run() {
                lockTest.method(Thread.currentThread());
            }
        }, "t2");

        t1.start();
        t2.start();
    }
}
//执行情况：线程名t1获得了锁
//         线程名t1释放了锁
//         线程名t2获得了锁
//         线程名t2释放了锁
```



trylock()

```java
public class LockTest {
    private Lock lock = new ReentrantLock();

    //需要参与同步的方法
    private void method(Thread thread){
/*      lock.lock();
        try {
            System.out.println("线程名"+thread.getName() + "获得了锁");
        }catch(Exception e){
            e.printStackTrace();
        } finally {
            System.out.println("线程名"+thread.getName() + "释放了锁");
            lock.unlock();
        }*/


        if(lock.tryLock()){
            try {
                System.out.println("线程名"+thread.getName() + "获得了锁");
            }catch(Exception e){
                e.printStackTrace();
            } finally {
                System.out.println("线程名"+thread.getName() + "释放了锁");
                lock.unlock();
            }
        }else{
            System.out.println("我是"+Thread.currentThread().getName()+"有人占着锁，我就不要啦");
        }
    }

    public static void main(String[] args) {
        LockTest lockTest = new LockTest();

        //线程1
        Thread t1 = new Thread(new Runnable() {

            @Override
            public void run() {
                lockTest.method(Thread.currentThread());
            }
        }, "t1");

        Thread t2 = new Thread(new Runnable() {

            @Override
            public void run() {
                lockTest.method(Thread.currentThread());
            }
        }, "t2");

        t1.start();
        t2.start();
    }
}

//执行结果： 线程名t2获得了锁
//         我是t1有人占着锁，我就不要啦
//         线程名t2释放了锁

```

ReentranyLock从源码可以看出在Lock中可以自己控制锁是否公平，而且，默认的是非公平锁，以下是ReentrantLock的构造函数： 

```java
public ReentrantLock() {
        sync = new NonfairSync();//默认非公平锁
    }
```





synchronized的底层实现：

我们知道java是用字节码指令来控制程序（这里不包括热点代码编译成机器码）。在字节指令中，存在有synchronized所包含的代码块，那么会形成2段流程的执行。 

![](/images/20181108135833.bmp)

我们点击查看SyncDemo.java的源码SyncDemo.class，可以看到如下： 

![](/images/20181108135923.bmp)

如上就是这段代码段字节码指令，没你想的那么难吧。言归正传，我们可以清晰段看到，其实synchronized映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。

那么有的朋友看到这里就疑惑了，那图上有2个monitorexit呀？马上回答这个问题：上面我以前写的文章也有表述过，synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放。图中第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。而且，从图中我们也可以看到在第13行，有一个goto指令，也就是说如果正常运行结束会跳转到19行执行。





Lock的底层实现：

Lock实现和synchronized不一样，后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock呢底层其实是CAS乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。底层主要靠volatile和CAS操作实现的。





![](/images/20181108141042.bmp)

CAS:Compare and Swap, 比较并交换。 

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 



![](/images/20181108140850.bmp)



# 3.mysql索引 B+tree

B树是一种多路自平衡搜索树，它类似普通的二叉树，但是B书允许每个节点有更多的子节点。B树示意图如下： 

![](/images/20181108142706.bmp)

B树的特点： 

（1）所有键值分布在整个树中 

（2）任何关键字出现且只出现在一个节点中 

（3）搜索有可能在非叶子节点结束 

（4）在关键字全集内做一次查找，性能逼近二分查找算法 



B+树是B树的变体，也是一种多路平衡查找树，B+树的示意图为： 

![](/images/20181108142754.bmp)

从图中也可以看到，B+树与B树的不同在于： 

（1）所有关键字存储在叶子节点，非叶子节点不存储真正的data 

（2）为所有叶子节点增加了一个链指针 

为什么用B/B+树这种结构来实现索引呢？？ 

答：红黑树等结构也可以用来实现索引，但是文件系统及数据库系统普遍使用B/B+树结构来实现索引。mysql是基于磁盘的数据库，索引是以索引文件的形式存在于磁盘中的，索引的查找过程就会涉及到磁盘IO消耗，磁盘IO的消耗相比较于内存IO的消耗要高好几个数量级，所以索引的组织结构要设计得在查找关键字时要尽量减少磁盘IO的次数。为什么要使用B/B+树，跟磁盘的存储原理有关。

**局部性原理与磁盘预读** 

 为了提升效率，要尽量减少磁盘IO的次数。实际过程中，磁盘并不是每次严格按需读取，而是每次都会预读。磁盘读取完需要的数据后，会按顺序再多读一部分数据到内存中，这样做的理论依据是计算机科学中注明的局部性原理： 

```
当一个数据被用到时，其附近的数据也通常会马上被使用
程序运行期间所需要的数据通常比较集中
```

 （1）由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，
 因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。
 （2）MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改)。linux 默认页大小为4K。



**为什么mysql的索引使用B+树而不是B树呢？？**
 （1）B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。
 （2）mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树每个节点的key和data在一起，无法进行区间查找。

![](/images/20180824101539582.png)



# **4.缓存击穿、缓存雪崩、缓存穿透**



**缓存击穿**

​	缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 

解决方案：

​	有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 



**缓存雪崩**

​	缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 

解决方案：

​	缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就是将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 



**缓存击穿**

​	对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。 

​	缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 

解决方案：

1.使用互斥锁（mutex key）

​	业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。 

​	SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果，所以这里给出两种版本代码参考： 

​	![](/images/20181108144840.bmp)

2.提前使用互斥锁

​	在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。

3."永远不过期" 

​	这里的“永远不过期”包含两层意思：

(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。

(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期

从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。

4.资源保护

​	采用netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。 

​	![](/images/20181108145704.bmp)



# 5.mysql优化

**概述**

MySQL数据库常见的两个瓶颈是：CPU和I/O的瓶颈。 

CPU在饱和的时候一般发生在**数据装入内存或从磁盘上读取数据时候**。 

磁盘I/O瓶颈发生在装入数据远大于内存容量的时候，如果应用分布在网络上，**那么查询量相当大的时候那么平瓶颈就会出现在网络上。** 

我们可以用mpstat, iostat, sar和vmstat来查看系统的性能状态。除了服务器硬件的性能瓶颈，对于MySQL系统本身，我们可以使用工具来优化数据库的性能。 



**mysql优化方案**

**Mysql的优化，大体可以分为三部分：索引的优化，sql语句的优化，表的优化** 



![](/images/20181108150941.bmp)

**索引优化**

1.索引

​	一般的应用系统，读写比例在10：1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的也是最容易出现问题的，还是一些复杂的查询操作，因此对查询语句的优化是重中之重，**加速查询最好的方法就是索引。** 

​	索引：简单的说，相当于图书的目录，可以帮助用户快速的找到需要的内容。 

​	在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。 

总结：索引的目的在于提高查询效率，与我们查询图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小结，然后找到页数。相似的例子还有：查字典，查地图等。 

2. 索引类型

普通索引：是最基本的索引，它没有任何限制。 

唯一索引：与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

复合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。

主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引 

全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。 

3.索引优化

- 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引
- 尽量使用短索引，如果可以，应该制定一个前缀长度
- 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度
- 对于有多个列where或者order by子句的，应该建立复合索引
- 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引
- 尽量不要在列上进行运算（函数操作和表达式操作）
- 尽量不要使用not in和<>操作



**SQL慢查询优化**

![](/images/20181108151632.bmp)

1.如何捕获低效sql

​	1）slow_query_log 

​		这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。 

​	2）ong_query_time 	

​		当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。 

​	3）slow_query_log_file 

​		记录日志的文件名。 

​	4）log_queries_not_using_indexes 

​		这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。 

2.慢查询优化的基本步骤

​	1)先运行看看是否真的很慢，注意设置SQL_NO_CACHE 

​	2）where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高 

​	3)explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询） 

​	4)order by limit 形式的sql语句让排序的表优先查 

​	5)了解业务方使用场景 

​	6)加索引时参照建索引的几大原则 

​	7)观察结果，不符合预期继续从1开始分析 

2.优化原则

- 查询时，能不要*就不用*，尽量写全字段名
- 大部分情况连接效率远大于子查询
- 多使用explain和profile分析查询语句
- 查看慢查询日志，找出执行时间长的sql语句优化
- 多表连接时，尽量小表驱动大表，即小表 join 大表
- 在千万级分页时使用limit
- 对于经常使用的查询，可以开启缓存



**数据库表优化**

- 表的字段尽可能用NOT NULL
- 字段长度固定的表查询会更快
- 把数据库的大表按时间或一些标志分成小表
- 将表拆分

数据表拆分：主要就是垂直拆分和水平拆分。 

水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。 

垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。 



#  6.HashMap和TreeMap

​	首先介绍一下什么是Map。在数组中我们是通过数组下标来对其内容索引的，而在Map中我们通过对象来对对象进行索引，用来索引的对象叫做key，其对应的对象叫做value。这就是我们平时说的键值对。 

​	HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。 

​	HashMap 非线程安全 TreeMap 非线程安全   HashTable是线程安全

​	**线程安全**

​	 在Java里，线程安全一般体现在两个方面： 

​	1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable （后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。 

​	2.每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。 

​	**使用接口**

​	AbstractMap抽象类：(HashMap继承AbstractMap)覆盖了equals()和hashCode()方法以确保两个相等映射返回相同的哈希码。如果两个映射大小相等、包含同样的键且每个键在这两个映射中对应的值都相同，则这两个映射相等。映射的哈希码是映射元素哈希码的总和，其中每个元素是Map.Entry接口的一个实现。因此，不论映射内部顺序如何，两个相等映射会报告相同的哈希码。 

​	SortedMap接口：（TreeMap继承自SortedMap）它用来保持键的有序顺序。SortedMap接口为映像的视图(子集)，包括两个端点提供了访问方法。除了排序是作用于映射的键以外，处理SortedMap和处理SortedSet一样。添加到SortedMap实现类的元素必须实现Comparable接口，否则您必须给它的构造函数提供一个Comparator接口的实现。TreeMap类是它的唯一一份实现。 

​	**实现方式**

​	HashMap：基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子 。

​	(1)HashMap(): 构建一个空的哈希映像 

​	(2)HashMap(Map m): 构建一个哈希映像，并且添加映像m的所有映射 

​	(3)HashMap(int initialCapacity): 构建一个拥有特定容量的空的哈希映像 

​	(4)HashMap(int initialCapacity, float loadFactor): 构建一个拥有特定容量和加载因子的空的哈希映像 



​	TreeMap：基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。 

​	(1)TreeMap():构建一个空的映像树 

​	(2)TreeMap(Map m): 构建一个映像树，并且添加映像m中所有元素 

​	(3)TreeMap(Comparator c): 构建一个映像树，并且使用特定的比较器对关键字进行排序 

​	(4)TreeMap(SortedMap s): 构建一个映像树，添加映像树s中所有映射，并且使用与有序映像s相同的比较器排序 

​	

​	**性能对比**

​	HashMap：适用于在Map中插入、删除和定位元素。 

​	Treemap：适用于按自然顺序或自定义顺序遍历键(key)。 

​	HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。 

​	

# 7.设计模式概要

面向对象编程（Object Oriented Programming，*OOP*，面向对象程序设计） 

**OOP三大基本特性**

封装

​	封装，也就是把客观事物封装成抽象的类，并且类可以把自己的属性和方法只让可信的类操作，对不可信的进行信息隐藏。 

继承

​	继承是指这样一种能力，它可以使用现有的类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。 

多态

​	多态指一个类实例的相同方法在不同情形有不同的表现形式。具体来说就是不同实现类对公共接口有不同的实现方式，但这些操作可以通过相同的方式（公共接口）予以调用。 

**OOD七大原则**

​	面向对象设计（OOD）有**七**大原则，它们互相补充。 

​	

​	开-闭原则 

​		Open-Close Principle（OCP），即开-闭原则。开，指的是对扩展开放，即要支持方便地扩展；闭，指的是对修改关闭，即要严格限制对已有内容的修改。开-闭原则是最抽象也是最重要的OOD原则。简单工厂模式、工厂方法模式、抽象工厂模式中都提到了如何通过良好的设计遵循开-闭原则。 

​	

​	里氏替换原则

​		Liskov Substitution Principle（LSP），即里氏替换原则。该原则规定“子类必须能够替换其父类，否则不应当设计为其子类”。换句话说，父类出现的地方，都应该能由其子类代替。所以，子类只能去扩展基类，而不是隐藏或者覆盖基类。 



​	依赖倒置原则

​		Dependence Inversion Principle（DIP），依赖倒置原则。它讲的是“设计和实现要依赖于抽象而非具体”。一方面抽象化更符合人的思维习惯；另一方面，根据里氏替换原则，可以很容易将原来的抽象替换为扩展后的具体，这样可以很好的支持开-闭原则。 



​	接口隔离原则

​		Interface Segration Principle（ISP），接口隔离原则，“将大的接口打散成多个小的独立的接口”。由于Java类支持实现多个接口，可以很容易的让类具有多种接口的特征，同时每个类可以选择性地只实现目标接口。 



​	单一职责原则

​		Single Responsibility Principle（SRP），单一职责原则。它讲的是，不要存在多于一个导致类变更的原因，是高内聚低耦合的一个体现。 



​	迪米特法则/最少知道原则

​		Law of Demeter or Least Knowledge Principle（LoD or LKP），迪米特法则或最少知道原则。它讲的是“一个对象就尽可能少的去了解其它对象”，从而实现松耦合。如果一个类的职责过多，由于多个职责耦合在了一起，任何一个职责的变更都可能引起其它职责的问题，严重影响了代码的可维护性和可重用性。 



​	合成/聚合复用原则

 		Composite/Aggregate Reuse Principle（CARP / CRP），合成/聚合复用原则。如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么应当尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要再重新创建。新对象可通过向这些对象的委派达到复用已有功能的效果。简而言之，要尽量使用合成/聚合，而非使用继承。《Java设计模式（九） 桥接模式》中介绍的桥接模式即是对这一原则的典型应用。 

 	

​	**设计模式**

​	可以用一句话概括设计模式———设计模式是一种利用OOP的封闭、继承和多态三大特性，同时在遵循单一职责原则、开闭原则、里氏替换原则、迪米特法则、依赖倒置原则、接口隔离原则及合成/聚合复用原则的前提下，被总结出来的经过反复实践并被多数人知晓且经过分类和设计的可重用的软件设计方式。 

​	

​	

- 设计模式是高级软件工程师和架构师面试基本必问的项目（先通过面试进入这个门槛我们再谈其它）
- 设计模式是经过大量实践检验的安全高效可复用的解决方案。不要重复发明轮子，而且大多数时候你发明的轮子还没有已有的好
- 设计模式是被主流工程师/架构师所广泛接受和使用的，你使用它，方便与别人沟通，也方便别人code review（这个够实在吧）
- 使用设计模式可以帮你快速解决80%的代码设计问题，从而让你更专注于业务本身
- 设计模式本身是对几大特性的利用和对几大设计原则的践行，代码量积累到一定程度，你会发现你已经或多或少的在使用某些设计模式了
- 架构师或者team leader教授初级工程师设计模式，可以很方便的以大家认可以方式提高初级工程师的代码设计水平，从而有利于提高团队工程实力

GOF 23种设计模式

**1.创建型模式：抽象了对象实例化的过程，用来帮助创建对象的实例**

- Factory模式   （工厂模式）

- AbstractFactoy模式 (抽象工厂)

- Singleton模式 (单例)

- Builder模式 (创建者)

- Prototype模式（原型）

  **2.结构型模式：描述如何组合类和对象以获得更大的结构**

- Bridge模式   (桥接模式)

- Adapter模式   （适配器模式）

- Decorator模式 （装饰模式）

- Composite模式 （组合模式）

- Flyweight模式 （享元模式 ）

- Facade模式      (外观模式)

- Proxy模式   (代理模式)

  **3.行为型模式：描述算法和对象间职责的分配**

- Template模式   (模板方法模式)

- Strategy模式 （策略模式）

- State模式   (状态模式)

- Observer模式   (观察者模式)

- Memento模式 （备忘录模式）

- Mediator模式  (中介者模式)

- Command模式  (命令模式)

- Visitor模式 (访问者模式)

- Chain of Responsibility模式  (职责链模式)

- Iterator模式  （迭代器模式）

- Interpreter模式  （解释器模式）





