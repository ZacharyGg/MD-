

**研磨设计模式**

# 一：设计模式基础

## 1.设计模式是什么？

设计模式指的设计方面的模板，也就是设计方法的方式方法。

**设计模式：在软件开发中，经过验证的，用于解决在特定环境下、重复出现的、特定问题的解决方案。**

- 设计模式是解决某些问题的办法

- 设计模式不是凭空想出来的，是经验的积累和总结

- 设计模式并不是一成不变的，而是在不断的发展中
- 设计模式并不是软件行业独有的，各行各业都有自己的设计模式

## 2.设计模式的历史

​	设计模式起源于建筑行业，一位名叫Alexander的建筑师，发现并总结了一些建筑行业的设计模式。

​	在1995年，由Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides 合著的<设计模式-可服用面向对象软件的基础>艺术的出版，正式掀开了软件业设计模式的序幕，这本书的四位作者被世人称为四人组，业就是熟见的GoF(Gang of Four).	



## 2.设计模式有什么？

一般而言，**一个模式有四个基本要素**：

1. **模式名称（pattern name）**:一个助记名，它用一两个词来描述模式的问题、解决方案
   和效果。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上
   进行设计。基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使
   用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰当
   的模式名也是我们设计模式编目工作的难点之一。
2. **问题(problem)** :描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后
   果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设
   计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。
3. **解决方案(solution)** :描述了设计的组成成分，它们之间的相互关系及各自的职责和协
   作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定
   而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合
   （类或对象组合）来解决这个问题。
4. **效果(consequences)**: 描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述
   设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处
   具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因
   为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植
   性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。



### 1.设计模式按照技术领域来分

- Java设计模式：通常指GoF一书中提到的设计模式

- JEE设计模式：通常指SUN的《J2EE核心设计模式》一书中提到的设计模式
- 其他领域的，包括但不限于：EJB设计模式、实时系统设计模式、多线程设计模式、架构模式等等。

### 2.针对于GOF设计模式的分类

​	**1.创建型模式：抽象了对象实例化的过程，用来帮助创建对象的实例**

- Factory模式   （工厂模式）

- AbstractFactoy模式 (抽象工厂)

- Singleton模式 (单例)

- Builder模式 (创建者)

- Prototype模式（原型）

   **2.结构型模式：描述如何组合类和对象以获得更大的结构**

- Bridge模式   (桥接模式)

- Adapter模式   （适配器模式）

- Decorator模式 （装饰模式）

- Composite模式 （组合模式）

- Flyweight模式 （享元模式 ）

- Facade模式      (外观模式)

- Proxy模式   (代理模式)

   **3.行为型模式：描述算法和对象间职责的分配**

- Template模式   (模板方法模式)
- Strategy模式 （策略模式）
- State模式   (状态模式)
- Observer模式   (观察者模式)
- Memento模式 （备忘录模式）
- Mediator模式  (中介者模式)
- Command模式  (命令模式)
- Visitor模式 (访问者模式)
- Chain of Responsibility模式  (职责链模式)
- Iterator模式  （迭代器模式）
- Interpreter模式  （解释器模式）

### 3.设计模式和面对对象设计原则

​	设计原则是思想上的指导，而设计模式是实现上的手段。--》设计模式就是这些设计原则的一些具体体现。

​	**单一职责原则： Single Responsibility principle**

​	应该有且只有一个原因引起类的变更。换句话说就是一个接口只做一件事，即一个职责一个接口。但是困难的是划分职责时并没有一个标准，最终都是需要从实际的项目去考虑。我们在设计的时候，尽量单一，然后对于其实现类就要多方面的考虑。不能死套单一职责原则，否则会增加很多类，给维护带来不便。 

​	单一职责的潜台词是：拆分到最小单位，解决复用和组合问题。  



​	**里氏替换原则：Liskov Substitution principle**

​	里氏替换原则简单易懂一点的定义就是只要父类出现的地方子类就可以出现，且替换成子类也不会出现任何错误或者异常。(但是反过来，有子类出现的地方，父类不一定可以适用)。

​	里氏替换原则是为继承定义了四个规范 

​	① 子类必须完全实现父类的方法。 

​	② 子类可以有自己的个性。  

​	③覆盖或者实现父类的方法时输入参数可以被放大。 	

​	③覆盖或者实现父类的方法时输入参数可以被放大。 

 	里氏替换原则的潜台词是：尽量使用精准的抽象类或者接口。 



​	**依赖倒置原则：Dependence Inversion Principle**

​	精简的定义就是面向接口编程。在Java语言中的表现就是为以下的三点:

​	 ① 模块间的依赖关系通过接口和抽象类产生，实体类之间不直接发生依赖关系。 

​	 ②接口和抽象类不依赖于实现类。 

​	 ③实现类依赖接口或者抽象类。 

​	依赖倒置的潜台词是：面向抽象编程，解耦调用和被调用者。 



​	**接口隔离原则：Interface Segregation Principle**

​	接口隔离原则可以说是单一职责的必要手段，它的含义是尽量使用职能单一的接口，而不使用职能复杂、全面的接口。很好理解，接口是为了让子类实现的，如果子类想达到职能单一，那么接口也必须满足职能单一。相反，如果接口融合了多个不相关的方法，那它的子类就被迫要实现所有方法，尽管有些方法是根本用不到的。这就是接口污染。

1.定义: 建立单一接口，不要建立臃肿庞大的接口。即接口尽量细化，同时接口中的方法尽量少。在这里提一下单一职责和接口隔离原则的区别。首先两个侧重点是不一样的， 单一职责要求类和接口，或者方法的职责单一，侧重点在职责，这是根据业务逻辑进行划分的。而接口隔离原则要接口中的方法尽量少。比如，一个接口或者一个中有十个方法，不同的方法做不同的事情，但是这个接口总体就是处理一件事情，然后具体细分成了10个方法。不同的模块根据不同的权限进行访问，这是符单一职责原则的。但是按照接口隔离的原则是要求接口中的方法尽量少，落实到这个实例就是要求尽量多几个专门的接口供不同的模块使用，而不是只有一个臃肿的接口，依据权限去限制不同模块可以访问的方法。 

​	

​	2.接口隔离原则是对接口定义的规范。含义主要包含以下4点。 

​	①接口尽量小。根据具体业务把一个接口按照接口隔离原则细化成更多的接口。但是在此基础之上必须不能违背单一职责原则。

​	②接口要高内聚。高内聚的意思就是提高接口和类处理能力，减少对外的交互。接口是对外的承诺，因此设计时应该尽量少公布接口中的public方法，承诺越少系统开发越有利且变更风险就越少。 

​	③定制服务。定制服务就是单独为一个个体提供服务，即只提供访问者需要的方法。

​	④接口设计是有限度的。接口设计越小越好，但是结构同时会变得复杂，维护也变得难了。因此就要把握住这个度。  

接口隔离原则的潜台词是：拆分，从接口开始。 



​	**迪米特法则： Law if Demeter**



1. 定义: 迪米特法则也叫做最少知识原则(Least Knowledge Principle,LKP)，即一个对象应该对其他对象有最少的了解，也就是说一个类要对自己需要耦合或者调用的类知道的最少。我只知道你有多少public方法可以供我调用，而其他的一切都与我无关。 
2. 迪米特法则是对类的低耦合做处理明确的要求 。
3. 迪米特法则的核心观念就是类间解耦，最终可能产生的结果就是会产生了大量的中转类。为了把解耦做到极致导致实现一个业务逻辑的实现跳转了很多类，这也是不可取的做法。因此根据实际权衡利弊才是重要的。 

迪米特原则的潜台词是：不和陌生人说话，有事去中介。

 

​	**开闭原则： Open Close Principle**

​	开闭原则是Java里最基础的设计原则。具体的定义是：一个软件实体，比如类，模块，函数应该对扩展开放，对修改关闭。说的通熟易懂一些就是一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现改变。 

​	它的潜台词是：控制需求变动风险，缩小维护成本。



​	**组合/聚合复用原则** 

​	此原则的含义是，如果只是达到代码复用的目的，尽量使用组合与聚合，而不是继承。这里需要解释一下，组合聚合只是引用其他的类的方法，而不会受引用的类的继承而改变血统。 

​	继承的耦合性更大，比如一个父类后来添加实现一个接口或者去掉一个接口，那子类可能会遭到毁灭性的编译错误，但如果只是组合聚合，只是引用类的方法，就不会有这种巨大的风险，同时也实现了复用。 

​	组合聚合复用原则的潜台词是：我只是用你的方法，我们不一定是同类。 



### 4.设计模式与UML

​	１.ＵＭＬ是一种标准的图形化建模语言，它是面对对象分析与设计的一种标准表示。

​	２.设计模式和ＵＭＬ本身没有任何联系

​	３.可以使用ＵＭＬ来图形化表示设计模式的：设计结构、调用顺序等，方便交流

​	４.完全可以不使用ＵＭＬ，可以使用任何易于交流和表达的方法来表示设计模式。

### ５．设计模式和重构

​	**合理的的提前设计是主要手段，重构是辅助手段。**

​	１．设计模式是重构的目标，重构是达到目标的手段。

​	２．重构并不排斥以前设计，重构并不是不需要设计。

​	３.合理的提前设计＋重构来不断的改进设计＝＝＝＝＝＝》趋近于优秀的系统



# 二：初识设计模式：简单工厂模式

​	１.定义

​	提供一个创建对象实例的功能，而无须关心起具体实现。被创建实例的类型可以是结构、抽象类、业可以是具体的类。（是工厂方法模式的工厂方法参数的实现。）

​	２.结构和说明

​		![](/images/20181030102907.bmp)



接口：

```java
/**
 * 接口的定义，该接口可以通过简单工厂来创建
 */
public interface Api {
	/**
	 * 示意，具体的功能方法的定义
	 * @param s 示意，需要的参数
	 */
	public void operation(String s);
}

```

接口实现A:

```java
/**
 * 接口的具体实现对象A 
 */
public class ImplA implements Api{
	public void operation(String s) {
		//实现功能的代码，示意一下
		System.out.println("ImplA s=="+s);
	}
}

```

接口实现B:

```java
/**
 * 接口的具体实现对象B 
 */
public class ImplB implements Api{
	public void operation(String s) {
		//实现功能的代码，示意一下
		System.out.println("ImplB s=="+s);
	}
}

```

工厂类：

```java
/**
 * 工厂类，用来创造Api对象
 */
public class Factory {
	/**
	 * 具体的创造Api对象的方法
	 * @param condition 示意，从外部传入的选择条件
	 * @return 创造好的Api对象
	 */
	public static Api createApi(int condition){
		//应该根据某些条件去选择究竟创建哪一个具体的实现对象
		//这些条件可以从外部传入，也可以从其它途径获取
		//如果只有一个实现，可以省略条件，因为没有选择的必要
		
		//示意使用条件
		Api api = null;
		if(condition == 1){
			api = new ImplA();
		}else if(condition == 2){
			api = new ImplB();
		}
		return api;
	}
}
```

客户端：

```java
/**
 * 客户端，使用Api接口
 */
public class Client {
	public static void main(String[] args) {
		//通过简单工厂来获取接口对象
		Api api = Factory.createApi(1);
		api.operation("正在使用简单工厂");
	}
}

```



1.接口的概念：  接口是一种是特殊的抽象类

2.接口用来干什么： 通常用接口来定义实现类的外观，就相当于一份契约，根据外部应用需求的功能，约定了实			现类应该要实现的功能。

3.接口的思想：   封装隔离

4.接口的好处：只要接口不变，内部实现的变化就不会影响到外部应用，从而使得系统更灵活，具有更好的扩展性和可维护性。

5.接口和抽象类的选择： 优先选用接口，在如下情况下选抽象类：既要定义子类的行为，又要未子类提供公共的功能。





## 1.理解简单工厂

​	1.简单工厂的功能

​		可以创建的接口、抽象类和普通类的实例

​	2.静态工厂

​		通常把简单工厂类实现成一个工具类，直接使用静态方法就可以了，也就是说简单工厂的方法通常是静态的，所以也称为静态工厂。

​	3.万能工厂

​	一个简单工厂理论上可以用来构建任何对象。

​	4.简单工厂创建对象的范围

​	建议控制在一个独立的组件级别或者一个模块级别。



![](/images/20181030111248.bmp)

命名规则：

1.**类名建议为“模块名称+Factory”**，比如 用户模块工厂就成为：UserFactory.

2.**方法名通常为"get+接口名称"或者“create+接口名称”**

3.不建议把方法名成为“new+接口名称”



## 2.简单工厂的优缺点

​	1.帮助封装

​	2.解耦

​	3.可能增加客户端的复杂度

​	4.不方便扩展子工厂



## 3.思考简单工厂

​	简单工厂的本质是：  **选择实现**（实现类已经实现，而核心在于选择哪个实现类）

​	选择的参数：

​	1.客户端传参

​	2.配置文件

​	3.系统变量、运行变量等

​	何时选用简单工厂

​	1.如果想要完全封装隔离具体实现，让外部只能通过接口来操作封装体，那么可以选用简单工厂，让客户端通过工厂来获取相应的接口，而无需关心具体的实现。

​	2.如果像要把对外创建对象的职责集中管理和控制，可以选用简单工厂，一个简单工厂可以创建很多的、不相关的对象，可以把对外创建对象的直接集中到一个简单工厂来，从而实现集中管理和控制。



# 三：GoF  23个设计模式

# 一、外观模式

## 	1.体验外观模式	

**定义**：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

​	**结构和说明**：

​	![](/images/20181030133137.bmp)



![](/images/20181030134800.bmp)



**Facade**:定义子系统的多个模块对外的高层接口，通常需要调用内部多个模块，从而把客户的请求代理给适当的子系统对象。

**模块**：接受Facade对象的委派，真正实现功能，各个模块之间可能有交互。

**注意：Facade对象知道各个模块，但是各个模块不应该知道Facade对象。**



A模块接口：

```java
/**
 * A模块的接口
 */
public interface AModuleApi {
	/**
	 * 示意方法，A模块对外的一个功能方法
	 */
	public void testA();
}

```

A接口实现：

```java
public class AModuleImpl implements AModuleApi{
	public void testA() {
		System.out.println("现在在A模块里面操作testA方法");
	}
}

```

B接口

```java
public interface BModuleApi {
	public void testB();
}
```

B接口实现

```java
public class BModuleImpl implements BModuleApi{

	
	public void testB() {
		System.out.println("现在在B模块里面操作testB方法");
	}

}

```

Facade

```java
/**
 * 外观对象
 */
public class Facade {
	/**
	 * 示意方法，满足客户需要的功能
	 */
	public void test(){
		//在内部实现的时候，可能会调用到内部的多个模块
		AModuleApi a = new AModuleImpl();
		a.testA();
		BModuleApi b = new BModuleImpl();
		b.testB();
	}
}
```

Client:

```java
public class Client {
	public static void main(String[] args) {
//		//不用Facade，需要自己跟多个模块交互
//		AModuleApi a = new AModuleImpl();
//		a.testA();
//		BModuleApi b = new BModuleImpl();
//		b.testB();
//		CModuleApi c = new CModuleImpl();
//		c.testC();
//		
//		System.out.println("使用Facade----------------------〉");
		//使用了Facade
		new Facade().test();		
	}
}
```



## 2.理解外观模式

​	**外观模式的目的**：外观模式的目的不是给予系统添加新的功能接口，而是为了让外减少与子系统多个模块的交互，松散耦合，让而让外部能够更简单的使用子系统。

​	使用外观与不使用的对比：  Facade方便了客户端的调用、封装了系统内部的细节功能、实现功能的共享和复用。

​	有外观但是可以不使用。

​	外挂提供了缺省的实现



![](/images/20181030142507.bmp)



## 3.外观模式的实现

​	Facade的方法实现中，一般是负责把客户端的请求转发给予系统累不的各个模块进行处理，Facade的方法本身并不进行功能的处理，Facade的方法的实现只是实现一个功能的组合调用。



​	1.把外观类当作辅助工具类实现。

​	2.Facade可以实现成interface。（结合简单工厂模式）

![](/images/20181030144825.bmp)

​	3.Facade可以选择性的暴露接口。

​	

## 4.外观模式的优缺点

​	1.松散耦合

​	2.简单易用

​	3.更好的划分访问层次

​	4.过多的或者不太合理的Facade容易让人迷惑

## 5.外观模式的本质

​	外观模式的本质是：**封装交互，简化调用**

​	

​	对设计原则的体现：  体现了“**最少知识原则**

​	

​	**何时选用外挂模式**：

​	1.如果你希望为一个复杂的系统提供一个简单接口的时候，可以考虑使用外观模式，使用外观对象来实现大部分客户需要的功能，从而简化客户的使用。

​	2.如果想要客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象来将整个子系统与它的客户分离开来，从而提高子系统的独立性和移植性。

​	3.如果构建多层架构的系统，可以考虑使用外观模式，，使用外观对象作为每层的入口，这样可以简化层间的调用，也可以松散层次之间的依赖关系。



# 二、适配器模式

## 1.初识适配器模式

​	定义： 将一个类的接口**转换**成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

​	结构与说明：

​	![](/images/20181030151640.bmp)

​	Client:客户端，调用需要的领域接口target

​	Target:定义客户端需要的跟特定领域相关的接口。

​	Adaptee:已经存在的接口，但与客户端要求的特定领域接口不一致，需要被适配。

​	Adapter: 适配器，把adaptee适配成Client需要的target



​	Adaptee代码：

```java
/**
 * 已经存在的接口，这个接口需要被适配
 */
public class Adaptee {
	/**
	 * 示意方法，原本已经存在，已经实现的方法
	 */
	public void specificRequest() {
		//具体的功能处理
	}
}
```

Target代码：

```java
/**
 * 定义客户端使用的接口，与特定领域相关
 */
public interface Target {
	/**
	 * 示意方法，客户端请求处理的方法
	 */
	public void request();
}


```

Adapter适配器代码：

```java
/**
 * 适配器
 */
public class Adapter implements Target {
	/**
	 * 持有需要被适配的接口对象
	 */
	private Adaptee adaptee;
	/**
	 * 构造方法，传入需要被适配的对象
	 * @param adaptee 需要被适配的对象
	 */
	public Adapter(Adaptee adaptee) {
		this.adaptee = adaptee;
	}

	public void request() {
		//可能转调已经实现了的方法，进行适配
		adaptee.specificRequest();
	}
}

```



Client调用：



```java
/**
使用适配器的客户端
*/
public class Client {	
public static void main(String[] args) {
	//创建需被适配的对象
	Adaptee adaptee = new Adaptee();
	//创建客户端需要调用的接口对象
	Target target = new Adapter(adaptee);
	//请求处理
	target.request();
	}
}
```



## 2.体会适配器模式

​	



## 3.理解适配器模式

​	1.适配器模式的功能

​		适配器模式的主要功能是进行转换匹配，目的是复用已有的功能，而不是来实现新的接口。

​		适配器里面也可以实现功能，称这种适配器为智能适配器。

​	2.Adptee和Target的关系

​		适配器模式中被适配的接口Adaptee和适配成为的接口Target是没有关联的。

​	3.适配多个Adaptee。

​	4.适配器Adapter实现的复杂程度取决与Target、Adaptee的相似程度。



​	**类适配器和对象适配器的权衡**

​	实现上：类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。

​	类适配器：  	由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是一个静态的关系，当适配器继承了Adaptee过后，就不可能再去处理Adaptee的子类了。

​	对象适配器： 允许一个Adapter和多个Adaptee，包括Adaptee和它所有的子类一起工作。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。

​	

​	对于类适配器：适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。

​	对于对象适配器：要定义Adaptee的行为比较困难，这种情况下需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。







## 4.思考适配器模式

适配器的本质是：**转换匹配、复用功能**



何时选用适配器模式：

​	1.如果你像要是用一个已经存在的类，但是它的接口不符合你的需求，这种情况可以使用适配器模式，来把已有的实现转换成你需要的接口。

​	2.如果你像创建一个可以复用的类，这个类可能和一些不兼容的类一起工作，这种情况可以使用适配器模式，到时候需要说明就适配什么。

​	3.如果你像使用一些已经存在的子类，但是不可能对每一个子类都进行适配，这种情况可以选用对象适配器，直接适配这些子类的父类就可以了。



# 三、单例模式

## 1.初识单例模式

​	**定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。**

​	

​	结构与说明：

​			                                 ![](/images/20181031093943.bmp)



​	负责创建Singleton类自己的唯一实例，并提供一个getInstance的方法，让外部来访问这个类的唯一实例。

懒汉式：

```java
/**
 * 单例示例
 */
public class Singleton {
	/**
	 * 定义一个变量来存储创建好的类实例
	 */
	private static Singleton uniqueInstance = null;
	/**
	 * 私有化构造方法，好在内部控制创建实例的数目
	 */
	private Singleton(){
		//
	}
	/**
	 * 定义一个方法来为客户端提供类实例
	 * @return 一个Singleton的实例
	 */
	public static synchronized Singleton getInstance(){
		//判断存储实例的变量是否有值
		if(uniqueInstance == null){
			//如果没有，就创建一个类实例，并把值赋值给存储类实例的变量
			uniqueInstance = new Singleton();
		}
		//如果有值，那就直接使用
		return uniqueInstance;
	}
	/**
	 * 示意方法，单例可以有自己的操作
	 */
	public void singletonOperation(){
		//功能处理
	}
	/**
	 * 示意属性，单例可以有自己的属性
	 */
	private String singletonData;
	/**
	 * 示意方法，让外部通过这些方法来访问属性的值
	 * @return 属性的值
	 */
	public String getSingletonData(){
		return singletonData;
	}
}

```



饿汉式：

```java
/**
 * 饿汉式单例实现的示例
 */
public class Singleton {
	/**
	 * 定义一个变量来存储创建好的类实例，直接在这里创建类实例，只会创建一次
	 */
	private static Singleton uniqueInstance = new Singleton();
	/**
	 * 私有化构造方法，好在内部控制创建实例的数目
	 */
	private Singleton(){
		//
	}
	/**
	 * 定义一个方法来为客户端提供类实例
	 * @return 一个Singleton的实例
	 */
	public static Singleton getInstance(){
		//直接使用已经创建好的实例
		return uniqueInstance;
	}
	
	/**
	 * 示意方法，单例可以有自己的操作
	 */
	public void singletonOperation(){
		//功能处理
	}
	/**
	 * 示意属性，单例可以有自己的属性
	 */
	private String singletonData;
	/**
	 * 示意方法，让外部通过这些方法来访问属性的值
	 * @return 属性的值
	 */
	public String getSingletonData(){
		return singletonData;
	}
}

```



## 2.体会单例模式

不使用单例模式时读取文件：

```java
AppConfig.properties:
paramA=a
paramB=b

AppConfig.java
/**
 * 读取应用配置文件
 */
public class AppConfig {
	/**
	 * 用来存放配置文件中参数A的值
	 */
	private String parameterA;
	/**
	 * 用来存放配置文件中参数B的值
	 */
	private String parameterB;
	
	public String getParameterA() {
		return parameterA;
	}
	public String getParameterB() {
		return parameterB;
	}
	/**
	 * 构造方法
	 */
	public AppConfig(){
		//调用读取配置文件的方法
		readConfig();
	}
	/**
	 * 读取配置文件，把配置文件中的内容读出来设置到属性上
	 */
	private void readConfig(){
		Properties p = new Properties(); 
		InputStream in = null;
		try {
			in = AppConfig.class.getResourceAsStream("AppConfig.properties");
			p.load(in);
			//把配置文件中的内容读出来设置到属性上
			this.parameterA = p.getProperty("paramA");
			this.parameterB = p.getProperty("paramB");
		} catch (IOException e) {
			System.out.println("装载配置文件出错了，具体堆栈信息如下：");
			e.printStackTrace();
		}finally{
			try {
				in.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}

Client.java

public class Client {
	public static void main(String[] args) {
		//创建读取应用配置的对象
		AppConfig config = new AppConfig();
		
		String paramA = config.getParameterA();
		String paramB = config.getParameterB();
		
		System.out.println("paramA="+paramA+",paramB="+paramB);
	}
}
```



采用饿汉式单例模式

```java
AppConfig.properties

paramA=a1
paramB=b2

AppConfig.java

/**
 * 读取应用配置文件，单例实现
 */
public class AppConfig {
	/**
	 * 定义一个变量来存储创建好的类实例，直接在这里创建类实例，只会创建一次
	 */
	private static AppConfig instance = new AppConfig();
	/**
	 * 定义一个方法来为客户端提供AppConfig类的实例
	 * @return 一个AppConfig的实例
	 */
	public static AppConfig getInstance(){
		return instance;
	}	
	/**
	 * 用来存放配置文件中参数A的值
	 */
	private String parameterA;
	/**
	 * 用来存放配置文件中参数B的值
	 */
	private String parameterB;
	
	public String getParameterA() {
		return parameterA;
	}
	public String getParameterB() {
		return parameterB;
	}
	/**
	 * 私有化构造方法
	 */
	private AppConfig(){
		//调用读取配置文件的方法
		readConfig();
	}
	/**
	 * 读取配置文件，把配置文件中的内容读出来设置到属性上
	 */
	private void readConfig(){
		Properties p = new Properties(); 
		InputStream in = AppConfig.class.getResourceAsStream("AppConfig.properties");
		try {
			p.load(in);
			//把配置文件中的内容读出来设置到属性上
			this.parameterA = p.getProperty("paramA");
			this.parameterB = p.getProperty("paramB");
		} catch (IOException e) {
			System.out.println("装载配置文件出错了，具体堆栈信息如下：");
			e.printStackTrace();
		}
	}
	
}


Client.java

public class Client {
	public static void main(String[] args) {
		//创建读取应用配置的对象
		AppConfig config = AppConfig.getInstance();	
		String paramA = config.getParameterA();
		String paramB = config.getParameterB();
		System.out.println("paramA="+paramA+",paramB="+paramB);
	}
}
```



## 3.理解单例模式

​	**单例模式的功能**

​	单例模式是用来保证这个类再运行期间只会创建一个类实例，并提供一个全局唯一的访问点。

​	**单例模式的范围**

​	是一个ClassLoader及其子ClassLoader的范围。

​	**单例模式的命名**

​	一般建议单例模式的命名 ：getInstance



​	懒汉式和饿汉式的代码案例

​	**一定要私有化构造方法，让外部无法使用。**

```java
懒汉式：
public class Singleton {
	//4：定义一个变量来存储创建好的类实例
	//5：因为这个变量要在静态方法中使用，所以需要加上static修饰
	private static Singleton instance = null;
	//1：私有化构造方法，好在内部控制创建实例的数目
	private Singleton(){
	}
	//2：定义一个方法来为客户端提供类实例
	//3：这个方法需要定义成类方法，也就是要加static
	public static  Singleton getInstance(){
		//6：判断存储实例的变量是否有值
		if(instance == null){
			//6.1：如果没有，就创建一个类实例，并把值赋值给存储类实例的变量
			instance = new Singleton();
		}
		//6.2：如果有值，那就直接使用
		return instance;
	}
}



饿汉式：
public class Singleton {
	//4：定义一个静态变量来存储创建好的类实例
	//直接在这里创建类实例，只会创建一次
	private static Singleton instance = new Singleton();
	//1：私有化构造方法，好在内部控制创建实例的数目
	private Singleton(){		
	}
	//2：定义一个方法来为客户端提供类实例
	//3：这个方法需要定义成类方法，也就是要加static
	public static Singleton getInstance(){
		//5：直接使用已经创建好的实例
		return instance;
	}
}

```



单例模式的优缺点：

​	时间和空间：  懒汉式式典型的时间换空间，饿汉式式典型的空间换时间。

​	线程安全：  不加同步的懒汉式式线程不安全的。饿汉式由虚拟机保证了其线程安全。

​	懒汉式保证线程安全需要增加synchronized。可以使用双重检查加锁。

```java
双重检查加锁
public class Singleton {
	/**
	 * 对保存实例的变量添加volatile的修饰
	 */
	private volatile static Singleton instance = null;
	private Singleton(){
		
	}
	public static  Singleton getInstance(){
		//先检查实例是否存在，如果不存在才进入下面的同步块
		if(instance == null){
			//同步块，线程安全的创建实例
			synchronized(Singleton.class){
				//再次检查实例是否存在，如果不存在才真的创建实例
				if(instance == null){
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```

​	第一个判断后如果赋值了，如果不用volatile无法保证修改通知，所有需要采用volatile定义变量。



在java中一种更好的单例实现方式

​	Lazy initialization holder class模式，这个模式综合使用了java的类级内部类和多线程缺省同步锁的知识，很巧妙的同时实现了延迟加载和线程安全。

**内部类是延时加载的，也就是说只会在第一次使用时加载。不使用就不加载，所以可以很好的实现单例模式。** 

```java
public class Singleton {
	/**
	 * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，
	 * 而且只有被调用到才会装载，从而实现了延迟加载
	 */
	private static class SingletonHolder{
		/**
		 * 静态初始化器，由JVM来保证线程安全
		 */
		private static Singleton instance = new Singleton();
	}
	/**
	 * 私有化构造方法
	 */
	private Singleton(){
	}
	
	public static  Singleton getInstance(){
		return SingletonHolder.instance;
	}
}
```



单例和枚举

​	单元素的美剧类型已经成为实现Singleton的最佳方法。

```java
/**
 * 使用枚举来实现单例模式的示例
 */
public enum Singleton {	
	/**
	 * 定义一个枚举的元素,它就代表了Singleton的一个实例
	 */
	uniqueInstance;
	
	/**
	 * 示意方法，单例可以有自己的操作
	 */
	public void singletonOperation(){
		//功能处理
	}
}
```



## 4.思考单例模式

​	单例模式的本质式：  **控制实例的数目**

​	扩展代码,控制实例数目为3个。****

```java
/**
 * 简单演示如何扩展单例模式，控制实例数目为3个 
 */
public class OneExtend {
	/**
	 * 定义一个缺省的key值的前缀
	 */
	private final static String DEFAULT_PREKEY = "Cache";
	/**
	 * 缓存实例的容器
	 * 会遇到实例调度的问题
	 */
	private static Map<String,OneExtend> map = new HashMap<String,OneExtend>();
	/**
	 * 用来记录当前正在使用第几个实例，到了控制的最大数目，就返回从1开始
	 */
	private static int num = 1;
	/**
	 * 定义控制实例的最大数目
	 */
	private final static int NUM_MAX = 3; 
	private OneExtend(){}
	public static OneExtend getInstance(){
		String key = DEFAULT_PREKEY+num;
		OneExtend oneExtend = map.get(key);
		if(oneExtend==null){
			oneExtend = new OneExtend();
			map.put(key, oneExtend);
		}
		//把当前实例的序号加1
		num++;
		if(num > NUM_MAX){
			//如果实例的序号已经达到最大数目了，那就重复从1开始获取
			num = 1;
		}
		return oneExtend;		
	}
	
	public static void main(String[] args) {
		OneExtend t1 = getInstance();
		OneExtend t2 = getInstance();
		OneExtend t3 = getInstance();
		OneExtend t4 = getInstance();
		OneExtend t5 = getInstance();
		OneExtend t6 = getInstance();
		
		System.out.println("t1=="+t1);
		System.out.println("t2=="+t2);
		System.out.println("t3=="+t3);
		System.out.println("t4=="+t4);
		System.out.println("t5=="+t5);
		System.out.println("t6=="+t6);
	}
}
```

**何时选用单例模式**

​    当需要控制一个类的实例只能有一个，而且客户端只能从一个全局访问点访问，可以选择单例模式。



# 四、工厂方法模式

## 1.初识工厂方法模式

定义：

**定义一个用于创建对象的接口，让子类决定实例化哪一个类，FactoryMethod使一个类的实例化延迟到其子类**。

结构和说明：

​	![](/images/20181031140423.bmp)

Product: 定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口。

ConcreteProduct: 具体的Product接口实现的对象

Creator: 创建器，声明工厂方法

ConcreteCreator: 具体的创建器对象，覆盖实现Create定义的哦那个工厂方法，返回具体的Product实例。

**Product.java** 

```java
/**
 * 工厂方法所创建的对象的接口
 */
public interface Product {
	//可以定义Product的方法
}
```

**ConcreteProduct.java**

```java
/**
 * 具体的Product对象
 */
public class ConcreteProduct implements Product {
	//实现Product要求的方法
}
```

**Creator.java**

```java
/**
 * 创建器，声明工厂方法
 */
public abstract class Creator {
	/**
	 * 创建Product的工厂方法
	 * @return Product对象
	 */
	protected abstract Product factoryMethod();
	/**
	 * 示意方法，实现某些功能的方法 
	 */
	public void someOperation() {
		//通常在这些方法实现中，需要调用工厂方法来获取Product对象
		Product product = factoryMethod();
	}
}
```

**ConcreteCreator.java** 

```java
/**
 * 具体的创建器实现对象
 */
public class ConcreteCreator extends Creator {
    @Override
	public Product factoryMethod() {
		//重定义工厂方法，返回一个具体的Product对象
		return new ConcreteProduct();
	}
}
```



## 2.体会工厂方法模式

​	考虑这样一个实际应用：  实际一个导出数据的应用框架，来让客户选择数据的导出方式，并真正的执行数据导出。

​	![](/images/20181031144626.bmp)



```java
ExportFileApi.java
/**
 * 导出的文件对象的接口
 */
public interface ExportFileApi {
	/**
	 * 导出内容成为文件
	 * @param data 示意：需要保存的数据
	 * @return 是否导出成功
	 */
	public boolean export(String data);
}


ExportDB.java
/**
 * 导出成数据库备份文件形式的对象
 */
public class ExportDB implements ExportFileApi{
	public boolean export(String data) {
		//简单示意一下，这里需要操作数据库和文件
		System.out.println("导出数据"+data+"到数据库备份文件");
		return true;
	}
}


ExportTxtFile.java
/**
 * 导出成文本文件格式的对象
 */
public class ExportTxtFile implements ExportFileApi{
	public boolean export(String data) {
		//简单示意一下，这里需要操作文件
		System.out.println("导出数据"+data+"到文本文件");
		return true;
	}
}



ExportOperate.java
/**
 * 实现导出数据的业务功能对象
 */
public abstract class ExportOperate {
	/**
	 * 导出文件
	 * @param data 需要保存的数据
	 * @return 是否成功导出文件
	 */
	public boolean export(String data){
		//使用工厂方法
		ExportFileApi api = factoryMethod();
		return api.export(data);
	}
	/**
	 * 工厂方法，创建导出的文件对象的接口对象
	 * @return 导出的文件对象的接口对象
	 */
	protected abstract ExportFileApi factoryMethod();
}


ExportDBOperate.java
/**
 * 具体的创建器实现对象，实现创建导出成数据库备份文件形式的对象
 */
public class ExportDBOperate extends ExportOperate{
	protected ExportFileApi factoryMethod() {
		//创建导出成数据库备份文件形式的对象
		return new ExportDB();
	}
}

ExportTxtFileOperate.java
/**
 * 具体的创建器实现对象，实现创建导出成文本文件格式的对象
 */
public class ExportTxtFileOperate extends ExportOperate{

	protected ExportFileApi factoryMethod() {
		//创建导出成文本文件格式的对象
		return new ExportTxtFile();
	}
}


Client.java
public class Client {
	public static void main(String[] args) {
		//创建需要使用的Creator对象
		ExportOperate operate = new ExportDBOperate();
		//调用输出数据的功能方法
		operate.export("测试数据");
	}
}
```



## 3.理解工厂方法模式

**工厂方法模式的功能**：

​	工厂方法模式的主要功能式让父类在不知道具体实现的情况下，完成自身的功能调用，而具体的实现延迟到子类去实现。

**实现成抽象类**：

​	工厂方法的实现中，通常父类会是一个抽象类，里面包含创建所需对象的抽象方法，这些抽象方法就是工厂方法。

**实现成具体的类**： 

​	也可以把父类实现成一个具体的类，这种情况下，通常是在父类中提供获取所需对象的默认实现方法，这样就算没有具体的子类，也能够运行。

**工厂方法的参数和返回值**： 

​	工厂方法的实现中，可能需要参数，以便决定到底选用哪一种具体的实现。一般工厂方法返回的**是被创建对象的接口对象**，当然也可以是抽象类或者一个具体的类的实例。 

**谁来使用工厂方法创建的对象：** 

​	1.在工厂方法模式里面，应该是Creator中的其他方法在使用工厂方法创建的对象。

​	2.客户端应该是使用Creator对象，或者是使用由Creator创建出阿来的对象，这个失火工厂方法创建的对象，是Creator中的某些方法使用。

​	3.在某些情况下，客户端可能会使用由Creator创建出来的对象，这个时候工厂方法创建的对象，是构成客户端需要的对象的一部分。

​	**在工厂方法模式里面，客户端要么使用Creator对象，要么使用Creator创建的对象，一般客户端不直接使用工厂方法。当然也可以直接把工厂方法暴露给客户端操作，但是一般不这么做。** 



（Creator不仅会创建工厂方法返回的对象，同时它本身也是一个对象）

客户端使用由Creator创建出来的对象情况的调用顺序示意图：

​	![](/images/20181031152154.bmp)  

客户端使用Creator对象时候的调用顺序示意图：

![](/images/20181031152444.bmp) 



工厂方法模式与IOC/DI

1.概念

​	依赖注入：应用程序依赖容器创建并注入它所需要的外部资源。

​	控制反转：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。

2.理解

- 参与者都有谁？

- 依赖：谁依赖于谁？为什么需要依赖？

- 注入：谁注入于谁？到底注入什么？

- 控制反转：谁控制谁？控制什么？为何叫反转（有反转就应该有正转了）？

- 依赖注入和控制反转是同一概念吗？

3.过程

​	![](/images/20181031155720.bmp) 

4.思想

​	其实IOC/DI对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本占主动地位，要获取什么资源都是主动出击，但是在IOC/DI思想中，应用程序就编程被动的了，被动的等待IOC/DI容器来创建并注入它所需要的资源了。

​	这样就有效的分离了对象和它所需要的外部资源，使得他们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。

5.工厂方法模式和IOC/DI的关系

​	思想很类似，都是“主动变被动”，进行“主从换位”，从而获得更灵活的程序结构。



**平行的类层次结构** 

​	1.什么是平行的类层次结构？

​		假如有两个类层次结构，其中一个类层次中的每一类在另一个类层次中都有一个对象的类的结构，就被称位平行的类层次结构。

![](/images/20181031162636.bmp)





​	2.这种平行的类层次结构用来干什么？

​		主要用来把一个类层次中的某些行为分离出来，让类层次中的类把原本属于自己的职责委托给分离出来的类去实现，从而使得类层次本身变得更简单，更容易扩展和复用。

​	3.工厂方法模式和平行得类层次结构有何关系？

​		**可以使用工厂方法模式来连接平行得类层次**。 

**参数化工厂方法**

​	所谓参数化工厂方法指的就是：通过给工厂方法传递参数，让工厂方法根据参数得不同来创建不同的产品对象。 



**工厂方法模式的优缺点**

​	1.可以在不知具体实现的情况下编程

​	2.更容易扩展对象的新版本

​	3.连接平行的类层次



​	4.具体产品和工厂方法具有耦合性

## 4.思考工厂方法模式

1**.工厂方法的本质**

​	工厂方法模式的本质是：  **延迟到子类来选择实现**  

**2.对设计原则的体现**

工厂方法模式很好的体现了“依赖倒置原则”

​	依赖导致原则告诉我们“要依赖抽象，不要依赖具体类”，简单点说就是：不能让高层组件依赖于低层组件，而不管高层组件还是低层组件，都应该依赖于抽象。

**3.何时选用工厂方法模式**

​	1.如果一个类需要创建某个接口的对象，但是又不知道具体的实现，这种情况可以选用工厂方法模式，把创建对象的工厂延迟到子类去实现

​	2.如果一个类本身就希望由它的子类来创建所需的对象的时候，应该使用工厂方法模式。

# 五、抽象工厂模式

## 1.初识抽象工厂模式

​	定义：提供一个创建一系列相关和相互依赖对象的接口，而无须指定它们具体的类。

​	结构和说明：

​		![](/images/20181101094002.bmp)

AbstractFactory：抽象工厂，定义创建一系列产品对象的操作接口。

ConcreteFactory: 具体的工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建。

AbstatctProduct:  定义 一类产品对象的接口

ConcreteProduct: 具体产品实现对象，通常在具体的工厂里面，会选择具体的产品实现对象，来创建符合抽象工厂定义的方法返回的产品雷响的对象。

Client:客户端，主要使用抽象工厂来获取一系列所需要的产品对象，然后面向这些产品对象的接口编程，以实现需要的功能。



代码实现

```java
AbstractProductA.java

/**
 * 抽象产品A的接口
 */
public interface AbstractProductA {
	//定义抽象产品A相关的操作
}

AbstractProductB.java

/**
 * 抽象产品B的接口
 */
public interface AbstractProductB {
	//定义抽象产品B相关的操作
}

ProductA1.java
/**
 * 产品A的具体实现
 */
public class ProductA1 implements AbstractProductA {
	//实现产品A的接口中定义的操作
}



ProductA2.java
/**
 * 产品A的具体实现
 */
public class ProductA2 implements AbstractProductA {
	//实现产品A的接口中定义的操作
}


ProductB1.java
/**
 * 产品B的具体实现
 */
public class ProductB1 implements AbstractProductB {
	//实现产品B的接口中定义的操作
}


ProductB2.java
/**
 * 产品B的具体实现
 */
public class ProductB2 implements AbstractProductB {
	//实现产品B的接口中定义的操作
}



AbstractFactory.java
/**
 * 抽象工厂的接口，声明创建抽象产品对象的操作
 */
public interface AbstractFactory {
	/**
	 * 示例方法，创建抽象产品A的对象
	 * @return 抽象产品A的对象
	 */
	public AbstractProductA createProductA();
	/**
	 * 示例方法，创建抽象产品B的对象
	 * @return 抽象产品B的对象
	 */
	public AbstractProductB createProductB();
}



ConcreteFactory1.java
/**
 * 具体的工厂实现对象，实现创建具体的产品对象的操作
 */
public class ConcreteFactory1 implements AbstractFactory {

	public AbstractProductA createProductA() {
		return new ProductA1();
	}
	public AbstractProductB createProductB() {
		return new ProductB1();
	}
}



ConcreteFactory2.java

/**
 * 具体的工厂实现对象，实现创建具体的产品对象的操作
 */
public class ConcreteFactory2 implements AbstractFactory {

	public AbstractProductA createProductA() {
		return new ProductA2();
	}
	public AbstractProductB createProductB() {
		return new ProductB2();
	}
}


Client.java
public class Client {

	public static void main(String[] args) {
		//创建抽象工厂对象
		AbstractFactory af = new ConcreteFactory1();
		//通过抽象工厂来获取一系列的对象，如产品A和产品B
		af.createProductA();
		af.createProductB();
	}
}


```



## 2.体会抽象工厂模式

​	装电脑需要主板、CPU、硬盘等匹配情况，各个硬件相关联。

​	游戏关卡，简单、中等、困难的各个关卡相互关系。





## 3.理解抽象工厂模式

​	**抽象工厂模式的功能**：  抽象工厂模式的功能是为一系列相关对象或相互依赖的对象创建一个接口。从某种意义上看，抽象工厂其实就是一个产品系列，或者是产品簇。

​	**实现成接口**： AbstractFactory在Java中通常实现成为接口，不要被误导，以为实现成抽象类。

​	**使用工厂方法**： AbstractFactory定义了创建产品所需要的接口，具体的实现是在实现类里面，通常在实现类里面就需要选择多种更具体的实现，所以AbstractFactory定义的创建产品的方法可以看成是工厂方法，而这些工厂方法的具体实现就延迟到了具体的工厂里面，也就是说使用工厂方法来实现抽象工厂。

​	**切换产品簇**： 抽象工厂定义了一个产品簇，因此切换产品簇就需要切换不同抽象工厂的具体实现。

​	

​	**时序图：** 

​	![](/images/20181101100121.bmp)





​	![](/images/20181101100825.bmp)



**抽象工厂和DAO** 

​	DAO： 数据访问对象，是Data Access Object首字符的简写。

​	DAO是JEE中的一个标准模式，通过它来解决访问数据对象所面临的一系列的问题，比如：数据源不同、存储类型不同、访问方式不同、供应商不同、版本不同等等，这些不同会照成访问数据的实现上的差别很大。

​	使用DAO的系统结构图

​		![](/images/20181101102319.bmp)

​	DAO需要抽象和封装所有对数据的访问，DAO承担和数据仓库交互的职责，访问数据所面临的所有问题，都需要DAO在内部来自行解决。

​	DAO和抽象工厂的关系： 在实现DAO模式的时候，最常见的实现策略就是使用工厂的策略，而却多是通过抽象工厂模式来实现，当然在实现抽象工厂模式来实现的失火，可以结合工厂方法模式。因此DAO模式和抽象工厂模式又很大的联系。

​	DAO模式采用工厂模式来实现的策略

​		![](/images/20181101102746.bmp)

​	DAO模式采用抽象工厂模式来实现的策略

​	![](/images/20181101102949.bmp)



​	抽象工厂模式的优缺点：

​	1.分离接口和实现

​	2.使得切换产品簇变得容易

​	3.不太容易扩展新的产品

​	4.容易造成类层次复杂



## 4.思考抽象工厂模式

​	抽象工厂模式的本质：   **选择产品簇的实现**

​	

​	**何时选用抽象工厂模式** 

​	1.如果希望一个系统独立于它的产品的创建，组合和表示的时候，也就是希望一个系统只是指定产品的接口，而不关系实现的时候。

​	2.如果一个系统要由多个产品系列中的一个来配置的时候，也就是可以动态的切换产品簇的时候。

​	3.如果要强调一系列相关产品的接口，以便联合使用它们的时候。



# 六、生成器模式

## 1.初识生成器模式

​	**定义：  将一个负载对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。** 

​	结构和说明：

​		![](/images/20181101151359.bmp) 

​	Builder:生成器接口，定义创建一个Product对象所需的各个部件的操作。

​	ConcreteBuilder： 具体生成器的实现，实现各个部件的创建，并负责组装Product对象的各个部件，同时还提供一个让客户获取组装完成后的产品对象的方法。

​	Director：指导者，主要用来使用Builder接口，以一个统一的过程来构建所需要的Product对象。

​	Product：产品。表示被生成器构建的复杂对象，包含对各部件。

​	

​	简单代码示例

​	

```java
Product.java
/**
 * 被构建的产品对象的接口
 */
public interface Product {
	//定义产品的操作
}



Builder.java

/**
 * 构建器接口，定义创建一个产品对象所需的各个部件的操作
 */
public interface Builder {
	/**
	 * 示意方法，构建某个部件
	 */
	public void buildPart();
}


ConcreteBuilder.java

/**
 * 具体的构建器实现对象
 */
public class ConcreteBuilder implements Builder {
	/**
	 * 构建器最终构建的产品对象
	 */
	private Product resultProduct;
	/**
	 * 获取构建器最终构建的产品对象
	 * @return 构建器最终构建的产品对象
	 */
	public Product getResult() {
		return resultProduct;
	}
	public void buildPart() {
		//构建某个部件的功能处理
	}
}


Director.java

/**
 * 指导者，指导使用构建器的接口来构建产品的对象
 */
public class Director {
	/**
	 * 持有当前需要使用的构建器对象
	 */
	private Builder builder;
	/**
	 * 构造方法，传入构建器对象
	 * @param builder 构建器对象
	 */
	public Director(Builder builder) {
		this.builder = builder;
	}
	/**
	 * 示意方法，指导构建器构建最终的产品对象
	 */
	public void construct() {
		//通过使用构建器接口来构建最终的产品对象
		builder.buildPart();
	}
}
```







## 2.体会生成器模式

​	![](/images/20181101152048.bmp) 

![](/images/20181101152200.bmp)

![](/images/20181101152131.bmp)



```java
ExportHeaderModel.java
/**
 * 描述输出到文件头的内容的对象
 */
public class ExportHeaderModel {
	/**
	 * 分公司或门市点编号
	 */
	private String depId;
	/**
	 * 导出数据的日期
	 */
	private String exportDate;
	public String getDepId() {
		return depId;
	}
	public void setDepId(String depId) {
		this.depId = depId;
	}
	public String getExportDate() {
		return exportDate;
	}
	public void setExportDate(String exportDate) {
		this.exportDate = exportDate;
	}
}


ExportDataModel.java
/**
 * 描述输出数据的对象
 */
public class ExportDataModel {
	/**
	 * 产品编号
	 */
	private String productId;
	/**
	 * 销售价格
	 */
	private double price;
	/**
	 * 销售数量
	 */
	private double amount;
	
	public String getProductId() {
		return productId;
	}
	public void setProductId(String productId) {
		this.productId = productId;
	}
	public double getPrice() {
		return price;
	}
	public void setPrice(double price) {
		this.price = price;
	}
	public double getAmount() {
		return amount;
	}
	public void setAmount(double amount) {
		this.amount = amount;
	}
	
}



ExportFooterModel.java
/**
 * 描述输出到文件尾的内容的对象
 */
public class ExportFooterModel {
	/**
	 * 输出人
	 */
	private String exportUser;

	public String getExportUser() {
		return exportUser;
	}

	public void setExportUser(String exportUser) {
		this.exportUser = exportUser;
	}
}


Builder.java
/**
 * 构建器接口，定义创建一个输出文件对象所需的各个部件的操作
 */
public interface Builder {
	/**
	 * 构建输出文件的Header部分
	 * @param ehm 文件头的内容
	 */
	public void buildHeader(ExportHeaderModel ehm);
	/**
	 * 构建输出文件的Body部分
	 * @param mapData 要输出的数据的内容
	 */
	public void buildBody(Map<String,Collection<ExportDataModel>> mapData);
	/**
	 * 构建输出文件的Footer部分
	 * @param efm 文件尾的内容
	 */
	public void buildFooter(ExportFooterModel efm);
}


TxtBuilder.java

/**
 * 实现导出数据到文本文件的的构建器对象
 */
public class TxtBuilder implements Builder {
	/**
	 * 用来记录构建的文件的内容，相当于产品
	 */
	private StringBuffer buffer = new StringBuffer();
	public void buildBody(
			Map<String, Collection<ExportDataModel>> mapData) {
		for(String tblName : mapData.keySet()){
			//先拼接表名称
			buffer.append(tblName+"\n");
			//然后循环拼接具体数据
			for(ExportDataModel edm : mapData.get(tblName)){
				buffer.append(edm.getProductId()+","+edm.getPrice()+","+edm.getAmount()+"\n");
			}
		}
	}
	public void buildFooter(ExportFooterModel efm) {
		buffer.append(efm.getExportUser());
	}
	public void buildHeader(ExportHeaderModel ehm) {
		buffer.append(ehm.getDepId()+","+ehm.getExportDate()+"\n");
	}	
	public StringBuffer getResult(){
		return buffer;
	}	
}

XmlBuilder.java

/**
 * 实现导出数据到XML文件的的构建器对象
 */
public class XmlBuilder implements Builder {
	/**
	 * 用来记录构建的文件的内容，相当于产品
	 */
	private StringBuffer buffer = new StringBuffer();
	public void buildBody(
			Map<String, Collection<ExportDataModel>> mapData) {
		buffer.append("  <Body>\n");
		for(String tblName : mapData.keySet()){
			//先拼接表名称
			buffer.append("    <Datas TableName=\""+tblName+"\">\n");
			//然后循环拼接具体数据
			for(ExportDataModel edm : mapData.get(tblName)){
				buffer.append("      <Data>\n");
				buffer.append("        <ProductId>"+edm.getProductId()+"</ProductId>\n");
				buffer.append("        <Price>"+edm.getPrice()+"</Price>\n");
				buffer.append("        <Amount>"+edm.getAmount()+"</Amount>\n");
				buffer.append("      </Data>\n");
			}
			buffer.append("    </Datas>\n");
		}
		buffer.append("  </Body>\n");
	}

	public void buildFooter(ExportFooterModel efm) {
		buffer.append("  <Footer>\n");
		buffer.append("    <ExportUser>"+efm.getExportUser()+"</ExportUser>\n");
		buffer.append("  </Footer>\n");
		buffer.append("</Report>\n");
	}

	public void buildHeader(ExportHeaderModel ehm) {
		buffer.append("<?xml version='1.0' encoding='gb2312'?>\n");
		buffer.append("<Report>\n");
		buffer.append("  <Header>\n");
		buffer.append("    <DepId>"+ehm.getDepId()+"</DepId>\n");
		buffer.append("    <ExportDate>"+ehm.getExportDate()+"</ExportDate>\n");
		buffer.append("  </Header>\n");
	}
	public StringBuffer getResult(){
		return buffer;
	}
	
}

Director.java

/**
 * 指导者，指导使用构建器的接口来构建输出的文件的对象
 */
public class Director {
	/**
	 * 持有当前需要使用的构建器对象
	 */
	private Builder builder;
	/**
	 * 构造方法，传入构建器对象
	 * @param builder 构建器对象
	 */
	public Director(Builder builder) {
		this.builder = builder;
	}
	/**
	 * 指导构建器构建最终的输出的文件的对象
	 * @param ehm 文件头的内容
	 * @param mapData 数据的内容
	 * @param efm 文件尾的内容
	 */
	public void construct(ExportHeaderModel ehm,Map<String,Collection<ExportDataModel>> mapData,ExportFooterModel efm) {
		//1：先构建Header
		builder.buildHeader(ehm);
		//2：然后构建Body
		builder.buildBody(mapData);
		//3：然后构建Footer
		builder.buildFooter(efm);
	}
}

Client.java

public class Client {
	public static void main(String[] args) {
		//准备测试数据
		ExportHeaderModel ehm = new ExportHeaderModel();
		ehm.setDepId("一分公司");
		ehm.setExportDate("2010-05-18");
		
		Map<String,Collection<ExportDataModel>> mapData = new HashMap<String,Collection<ExportDataModel>>();
		Collection<ExportDataModel> col = new ArrayList<ExportDataModel>();
		
		ExportDataModel edm1 = new ExportDataModel();
		edm1.setProductId("产品001号");
		edm1.setPrice(100);
		edm1.setAmount(80);
		
		ExportDataModel edm2 = new ExportDataModel();
		edm2.setProductId("产品002号");
		edm2.setPrice(99);
		edm2.setAmount(55);		
		//把数据组装起来
		col.add(edm1);
		col.add(edm2);		
		mapData.put("销售记录表", col);
		
		ExportFooterModel efm = new ExportFooterModel();
		efm.setExportUser("张三");
		
		//测试输出到文本文件
		TxtBuilder txtBuilder = new TxtBuilder();
		//创建指导者对象
		Director director = new Director(txtBuilder);
		director.construct(ehm, mapData, efm);
		//把要输出的内容输出到控制台看看
		System.out.println("输出到文本文件的内容：\n"+txtBuilder.getResult());
		//测试输出到xml文件
		XmlBuilder xmlBuilder = new XmlBuilder();
		Director director2 = new Director(xmlBuilder);
		director2.construct(ehm, mapData, efm);
		//把要输出的内容输出到控制台看看
		System.out.println("输出到XML文件的内容：\n"+xmlBuilder.getResult());	
	}
}
```



## 3.理解生成器模式

​	**生成器模式的功能：**主要功能是构建复杂的产品，而且是细化的，分步骤的构建产品，也就是生长期模式重在一步一步构建复杂对象的问题。更为重要的是，这个构建的过程是统一的，固定不变的，变化的部分放到生长期部分，只要配置不同的生成器，在同样的构建过程就能构建不同的产品表示。

​	生成器模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用，具体的构建实现可以很方便的扩展和切换，从而可以灵活的组合来构造出不同的产品对象。

 	 **生成器模式的构成：** 两个重要部分

​	1.一部分是Builder接口这边，这边定义了如何构建各个部件，知道每个部件功能如何实现，以及如何装配这些部件到产品中去。

​	2.令一个部分是Director，Director是知道如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤来执行。

​	生成器模式中，强调的是固定整体构建算法，而灵活扩展和切换部件的具体构造和产品的装配方式，所以要严格区分这两个部分。

​	**生成器模式的使用：** 

​		应用生成器模式的时候，可以让客户端创造Director，在Director里面封装整体构建算法，让后让Director去调用Builder，让Builder来封装具体部件的构建功能。

​		Client也充当Director的角色。

​	**生成器的调用顺序示意图**  

​	![](/images/20181101133530.bmp) 



​	**生成器模式的实现**：

​		1.生成器的实现

​			实际上在Builder接口的实现中，每个部件构建的方法里面，除了部件装配外，也可以实现如何具体		                        的创建各个部件对象，也就是说每个方法都可以又两部分功能，一个是创建部件对象，一个是组装部件。

​			在构建部件的方法里面可以选择并创建具体的部件对象，然后在把整个部件对象组装到产品对象中               去，这样Builder就可以和工厂方法配合使用。

​			如果在实现Builder的时候，只有创建对象的功能，而没有组装功能，这个时候的Builder实现跟抽象工厂的实现是类似的 。

​	        2.指导者的实现

​			在生成器模式里面，指导者承担的是整体构建算法部分，是相对不变的部分。因此在实现指导者的时候，把变化的部分分离出去是很重要的。

​			其实知道这分离出去的变化部分，就到了生成器那边，指导者知道整体的构建算法，就是不知道如何具体的创建和装配部件对象。

​			因此真正的指导者实现，并不仅仅是如例子一样简单的按照一定的顺序调用生成器的方法来生成对象，应该是又较为负载的算法和运算过程，在运算过程中根据需要，才会调用生成器的方法来生成部件对象。

​		3.指导者和生成器的交互

​			在生成器模式里面，指导者和生成器的交互，是通过生成器的那些Build Part方法来完成的。指导者通常会实现比较负载的算法或者运算过程，在实际中很可能会又这样的情况。

​		a.在运行指导者的时候，会按照整体构建算法的步骤进行运算，可能先运行前几步运算，到了某一步骤，需要具体创建某个部件对象了，然后就调用Builder中创建相应部件的方法来创建具体的部件。同时，把前面运算得到的数据传递给Builder，因为在Builder内部实现创建和组装部件的时候，可能会需要到这些数据。

​		b.Builder创建完具体的部件对象后，会把创建号的部件对象返回给指导者，指导者继续后续的算法运算。可能会用到以及创建号的对象。

​		4.返回装配好的装配方法

​			在标准的生成器模式里面，在Builder实现里面会提供一个返回装配好的产品的方法，在Builder接口上是没有的。它考虑的是最终的对象一定要通过部件构建和装配，才算真正创建了，而具体干活的就是这个Builder实现，虽然指导者也参与了，但是指导者是不负责具体的部件创建和组装的，因此客户端是从Builder实现里面获取最终配装备的产品。

​		5.关于被构建的产品的接口

​			在使用生成器模式的时候，大多数情况下是不知道最终构建出来的产品是什么样的，所以在标准的生成器模式里面，一般是不需要对产品定义抽象接口的。因为最终构造的产品千差万别，给这些产品定义公共接口几乎没有意义。

​	**使用生成器模式构建复杂对象**  

​		![](/images/20181101143553.bmp)



```java
ConcreteBuilder.java

/**
 * 构造保险合同对象的构建器
 */
public class ConcreteBuilder {
	private String contractId;
	private String personName;
	private String companyName;
	private long beginDate;
	private long endDate;
	private String otherData;
	/**
	 * 构造方法，传入必须要有的参数
	 * @param contractId 保险合同编号
	 * @param beginDate 保险开始生效的日期
	 * @param endDate 保险失效的日期
	 */
	public ConcreteBuilder(String contractId,long beginDate,long endDate){
		this.contractId = contractId;
		this.beginDate = beginDate;
		this.endDate = endDate;
	}
	/**
	 * 选填数据，被保险人员的名称
	 * @param personName  被保险人员的名称
	 * @return 构建器对象
	 */
	public ConcreteBuilder setPersonName(String personName){
		this.personName = personName;
		return this;
	}
	/**
	 *  选填数据，被保险公司的名称
	 * @param companyName 被保险公司的名称
	 * @return 构建器对象
	 */
	public ConcreteBuilder setCompanyName(String companyName){
		this.companyName = companyName;
		return this;
	}
	/**
	 * 选填数据，其它数据
	 * @param otherData 其它数据
	 * @return 构建器对象
	 */
	public ConcreteBuilder setOtherData(String otherData){
		this.otherData = otherData;
		return this;
	}
	/**
	 * 构建真正的对象并返回
	 * @return 构建的保险合同的对象
	 */
	public InsuranceContract build(){
		if(contractId==null || contractId.trim().length()==0){
			throw new IllegalArgumentException("合同编号不能为空");
		}
		boolean signPerson = personName!=null && personName.trim().length()>0;
		boolean signCompany = companyName!=null && companyName.trim().length()>0;
		if(signPerson && signCompany){
			throw new IllegalArgumentException("一份保险合同不能同时与人和公司签订");
		}		
		if(signPerson==false && signCompany==false){
			throw new IllegalArgumentException("一份保险合同不能没有签订对象");
		}
		if(beginDate<=0){
			throw new IllegalArgumentException("合同必须有保险开始生效的日期");
		}
		if(endDate<=0){
			throw new IllegalArgumentException("合同必须有保险失效的日期");
		}
		if(endDate<=beginDate){
			throw new IllegalArgumentException("保险失效的日期必须大于保险生效日期");
		}
		return new InsuranceContract(this);
	}
	
	public String getContractId() {
		return contractId;
	}

	public String getPersonName() {
		return personName;
	}

	public String getCompanyName() {
		return companyName;
	}

	public long getBeginDate() {
		return beginDate;
	}

	public long getEndDate() {
		return endDate;
	}

	public String getOtherData() {
		return otherData;
	}
}



InsuranceContract.java

/**
 * 保险合同的对象
 */
public class InsuranceContract {
	/**
	 * 保险合同编号
	 */
	private String contractId;
	/**
	 * 被保险人员的名称，同一份保险合同，要么跟人员签订，要么跟公司签订，
	 * 也就是说，"被保险人员"和"被保险公司"这两个属性，不可能同时有值
	 */
	private String personName;
	/**
	 * 被保险公司的名称
	 */
	private String companyName;
	/**
	 * 保险开始生效的日期
	 */
	private long beginDate;
	/**
	 * 保险失效的日期，一定会大于保险开始生效的日期
	 */
	private long endDate;
	/**
	 * 示例：其它数据
	 */
	private String otherData;
	
	/**
	 * 构造方法，访问级别是同包能访问
	 */
	InsuranceContract(ConcreteBuilder builder){
		this.contractId = builder.getContractId();
		this.personName = builder.getPersonName();
		this.companyName = builder.getCompanyName();
		this.beginDate = builder.getBeginDate();
		this.endDate = builder.getEndDate();
		this.otherData = builder.getOtherData();
	}
	
	/**
	 * 示意：保险合同的某些操作
	 */
	public void someOperation(){
		System.out.println("Now in Insurance Contract someOperation=="+this.contractId);
	}
}

Client.java

public class Client {
	public static void main(String[] args) {
		//创建构建器
		ConcreteBuilder builder = new ConcreteBuilder("001",12345L,67890L);
		//设置需要的数据，然后构建保险合同对象
		InsuranceContract contract = builder.setPersonName("张三").setOtherData("test").build();
		//操作保险合同对象的方法
		contract.someOperation();
	}
}
```





## 4.思考生成器模式

生成器的本质：  **分离整体构建算法和部件构造** 

何时选用生成器模式：

​	1.如果创建对象的算法，应该独立于该对象组成部分以及他们的装配方式时

​	2.如果用一个构建过程有着不同的表示时。



# 七、原型模式

## 1.初识原型模式

​	**定义： 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。** 

​	结构和说明：

​	![](/images/20181101153857.bmp) 

Prototype:声明一个克隆自身的接口，用来约束想要克隆自己的类，要求它们都要实现这里定义的克隆方法。

ConcretePrototype： 实现Prototype的接口的类，这些类真正实现克隆自身的功能。

Client：使用原型的客户端，首先要获取到原型实例对象，让后通过原型实例克隆自身来创建新的对象实例。



简单代码示例

```java
Prototype.java

/**
 * 声明一个克隆自身的接口
 */
public interface Prototype {
	/**
	 * 克隆自身的方法
	 * @return 一个从自身克隆出来的对象
	 */
	public Prototype clone();
}

ConcretePrototype1.java
/**
 * 克隆的具体实现对象
 */
public class ConcretePrototype1 implements Prototype {
	public Prototype clone() {
		//最简单的克隆，新建一个自身对象，由于没有属性，就不去复制值了
		Prototype prototype = new ConcretePrototype1();
		return prototype;
	}
}

ConcretePrototype2.java

/**
 * 克隆的具体实现对象
 */
public class ConcretePrototype2 implements Prototype {
	public Prototype clone() {
		//最简单的克隆，新建一个自身对象，由于没有属性，就不去复制值了
		Prototype prototype = new ConcretePrototype2();
		return prototype;
	}
}

Client.java
/**
 * 使用原型的客户端
 */
public class Client {
	/**
	 * 持有需要使用的原型接口对象
	 */
	private Prototype prototype;
	/**
	 * 构造方法，传入需要使用的原型接口对象
	 * @param prototype 需要使用的原型接口对象
	 */
	public Client(Prototype prototype){
		this.prototype = prototype;
	}
	/**
	 * 示意方法，执行某个功能操作
	 */
	public void operation(){
		//会需要创建原型接口的对象
		Prototype newPrototype = prototype.clone();
	}
}
```



## 2.体会原型模式



![](/images/20181101154451.bmp) 



```java
OrderApi.java

/**
 * 订单的接口，声明了可以克隆自身的方法
 */
public interface OrderApi {
	/**
	 * 获取订单产品数量
	 * @return 订单中产品数量
	 */
	public int getOrderProductNum();
	/**
	 * 设置订单产品数量
	 * @param num 订单产品数量
	 */
	public void setOrderProductNum(int num);
	/**
	 * 克隆方法
	 * @return 订单原型的实例
	 */
	public OrderApi cloneOrder();
}



PersonalOrder.java
/**
 * 个人订单对象
 */
public class PersonalOrder implements OrderApi{
	/**
	 * 订购人员姓名
	 */
	private String customerName;
	/**
	 * 产品编号
	 */
	private String productId;
	/**
	 * 订单产品数量
	 */
	private int orderProductNum = 0;
	
	public int getOrderProductNum() {
		return this.orderProductNum;
	}	
	public void setOrderProductNum(int num) {
		this.orderProductNum = num;
	}	
	public String getCustomerName() {
		return customerName;
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public String getProductId() {
		return productId;
	}
	public void setProductId(String productId) {
		this.productId = productId;
	}
	public String toString(){
		return "本个人订单的订购人是="+this.customerName+"，订购产品是="+this.productId+"，订购数量为="+this.orderProductNum;
	}
	
	public OrderApi cloneOrder() {
		//创建一个新的订单，然后把本实例的数据复制过去
		PersonalOrder order = new PersonalOrder();
		order.setCustomerName(this.customerName);
		order.setProductId(this.productId);
		order.setOrderProductNum(this.orderProductNum);	
		return order;
	}
}


EnterpriseOrder.java

/**
 * 企业订单对象
 */
public class EnterpriseOrder implements OrderApi{
	/**
	 * 企业名称
	 */
	private String enterpriseName;
	/**
	 * 产品编号
	 */
	private String productId;	
	/**
	 * 订单产品数量
	 */
	private int orderProductNum = 0;
	public int getOrderProductNum() {
		return this.orderProductNum;
	}	
	public void setOrderProductNum(int num) {
		this.orderProductNum = num;
	}	
	public String getEnterpriseName() {
		return enterpriseName;
	}
	public void setEnterpriseName(String enterpriseName) {
		this.enterpriseName = enterpriseName;
	}
	public String getProductId() {
		return productId;
	}
	public void setProductId(String productId) {
		this.productId = productId;
	}
	public String toString(){
		return "本企业订单的订购企业是="+this.enterpriseName+"，订购产品是="+this.productId+"，订购数量为="+this.orderProductNum;
	}
	public OrderApi cloneOrder() {
		//创建一个新的订单，然后把本实例的数据复制过去
		EnterpriseOrder order = new EnterpriseOrder();
		order.setEnterpriseName(this.enterpriseName);
		order.setProductId(this.productId);
		order.setOrderProductNum(this.orderProductNum);		
		return order;
	}
}


OrderBusiness.java

/**
 * 处理订单的业务对象
 */
public class OrderBusiness {
	/**
	 * 创建订单的方法
	 * @param order 订单的接口对象
	 */
	public void saveOrder(OrderApi order){
		//根据业务要求，当订单的预定的产品数量超过1000的时候，就需要把订单拆成两份订单
		//当然如果要做好，这里的1000应该做成常量，这么做是为了演示简单
		
		//1：判断当前的预定产品数量是否大于1000
		while(order.getOrderProductNum() > 1000){
			//2：如果大于，还需要继续拆分
			//2.1再新建一份订单，跟传入的订单除了数量不一样外，其他都相同
			OrderApi newOrder = order.cloneOrder();
			//然后进行赋值，产品数量为1000
			newOrder.setOrderProductNum(1000);
			
			//2.2原来的订单保留，把数量设置成减少1000
			order.setOrderProductNum(order.getOrderProductNum()-1000);
			
			//然后是业务功能处理，省略了，打印输出，看一下
			System.out.println("拆分生成订单=="+newOrder);
		}		
		//3：不超过，那就直接业务功能处理，省略了，打印输出，看一下
		System.out.println("订单=="+order);
		
	}
}


OrderClient.java

public class OrderClient {
	public static void main(String[] args) {
		//创建订单对象，这里为了演示简单，直接new了
		PersonalOrder op = new PersonalOrder();
		//设置订单数据
		op.setOrderProductNum(3925);
		op.setCustomerName("张三");
		op.setProductId("P0001");
		
		//这里获取业务处理的类，也直接new了，为了简单，连业务接口都没有做
		OrderBusiness ob = new OrderBusiness();
		//调用业务来保存订单对象
		ob.saveOrder(op);
	}
}
```





## 3.理解原型模式

### 	1.原型模式的功能

​			1.通过克隆来创建新的对象实例

​			2.为克隆出来的新的对象实例复制原型实例属性的值

### 	 2.原型与new

​			原型模式从某种意义上说，就像是new操作。克隆方法和new操作最明显的不同就是在于new一个实例，一般属性是没有值或者只有默认值；克隆得到的实例是具有原型对象实例的属性的值。

### 	3.原型实例和克隆实例

​			原型和克隆出来的实例是没有关联的,不同的内存空间。

### 	4.调用顺序示例图

​			![](/images/20181101160352.bmp)  





### 	5.Java克隆

​			**Java中的克隆方法**

​			在java语言中已经提供了Clone方法，定义在Object类中。需要克隆功能的类，只需要要实现java.lang.cloneable接口，这个接口没有需要实现的方法，是一个标识接口。

​			![](/images/20181101161036.bmp)

​			**浅度克隆和深度克隆** 

​			浅度克隆：只负责克隆按值传递的数据

​			深度克隆：除了浅度克隆的值外，还负责克隆引用类型的数据，基本上就是被克隆实例所有的所有的属性的数据都会被克隆出来。

​			深度克隆还有一个特点，若果被克隆的对象里面的属性数据是引用类型，也就是属性的类型也是对象，那么需要一直递归的克隆下去。这也意味着，要想深度克隆成功，必须要整个克隆所涉及的对象都要正确实现克隆方法，如果其中一个没有实现克隆，那么就会导致克隆失败。

### 	5.原型管理器

​			如果一个系统中原型的数目不固定，比如系统中的原型可以被动态的创建和销毁，那么就需要在系中维护一个当前可用的原型的注册表，整个注册表就被成为原型管理器。

​			![](/images/20181101163211.bmp)

### 	6.原型模式的优缺点

​		1.对客户端隐藏了具体的实现类型

​		2.在运行时动态改变了具体的实现类型

​		3.深度克隆方法实现比较苦难

## 4.思考原型模式

​	原型模式的本质：  **克隆生成对象** 



​	何时选用原型模式：

​		1.如果一个系统想要独立于它想要使用的对象时，可用使用原型模式，让系统只面向接口编程，在系统需要新的对象的时候，可用通过克隆原型来得到。

​		2.如果需要实例化的类是在运行时动态指定时，可用使用原型模式，通过克隆原型来得到需要的实例。



# 八、中介者模式

## 1.初识中介者模式

​	定义：**用一个中介对象来封装一系列对象交互。 中介者使得各对象不需要显式地互相引用，从而使其耦合松散，而且可用独立的改变它们之间的交互。** 

​	**结构与说明：**

​	![](/images/20181101174657.bmp)



​	Mediator:中介者接口，在里面定义了各个同事之间交互需要的方法。可以式公共的通讯方法，比如changed方法，大家都用，也可以式小范围的交互方法。

​	ConcreteMidiator：具体中介者实现对象。它需要了解并维护各个同事对象，并扶着具体的协调各同时对象的交互关系。

​	Colleague：同事类的定义，通常实现成为抽象类，只要负责约束同事对象的类型，并实现一些具体同事类之间的公共功能。比如：每个具体同事类都应该知道中介者对象，也就是具体同事类都会持有中介者对象，就可以定义到整个类里面。

​	ConcreteColleague：具体的同事类，实现子的业务，在需要与其他同事通讯的时候，就与持有的中介者通讯，中介者会负责与其他的同事交互。



**代码示例**



```java
Colleague.java

/**
 * 同事类的抽象父类
 */
public abstract class Colleague {
	/**
	 * 持有中介者对象，每一个同事类都知道它的中介者对象
	 */
	private Mediator mediator;
	/**
	 * 构造方法，传入中介者对象
	 * @param mediator 中介者对象
	 */
	public Colleague(Mediator mediator) {
		this.mediator = mediator;
	}
	/**
	 * 获取当前同事类对应的中介者对象
	 * @return 对应的中介者对象
	 */
	public Mediator getMediator() {
		return mediator;
	}
}


ConcreteColleagueA.java

/**
 * 具体的同事类A
 */
public class ConcreteColleagueA extends Colleague {
	public ConcreteColleagueA(Mediator mediator) {
		super(mediator);
	}
	/**
	 * 示意方法，执行某些业务功能
	 */
	public void someOperation() {
		//在需要跟其他同事通信的时候，通知中介者对象
		getMediator().changed(this);
	}
}


ConcreteColleagueB.java

/**
 * 具体的同事类B
 */
public class ConcreteColleagueB extends Colleague {
	public ConcreteColleagueB(Mediator mediator) {
		super(mediator);
	}
	/**
	 * 示意方法，执行某些业务功能
	 */
	public void someOperation() {
		//在需要跟其他同事通信的时候，通知中介者对象
		getMediator().changed(this);
	}
}

Mediator.java

/**
 * 中介者，定义各个同事对象通信的接口
 */
public interface Mediator {
	/**
	 * 同事对象在自身改变的时候来通知中介者的方法，
	 * 让中介者去负责相应的与其他同事对象的交互
	 * @param colleague 同事对象自身，好让中介者对象通过对象实例
	 *                  去获取同事对象的状态
	 */
	public void changed(Colleague colleague);
}


ConcreteMediator.java


/**
 * 具体的中介者实现
 */
public class ConcreteMediator implements Mediator {
	
	/**
	 * 持有并维护同事A
	 */
	private ConcreteColleagueA colleagueA;
	/**
	 * 持有并维护同事B
	 */
	private ConcreteColleagueB colleagueB;
	
	/**
	 * 设置中介者需要了解并维护的同事A对象
	 * @param colleague 同事A对象
	 */
	public void setConcreteColleagueA(ConcreteColleagueA colleague) 	{
		colleagueA = colleague;
	}
	/**
	 * 设置中介者需要了解并维护的同事B对象
	 * @param colleague 同事B对象
	 */
	public void setConcreteColleagueB(ConcreteColleagueB colleague) 	{
		colleagueB = colleague;
	}
	
	public void changed(Colleague colleague) {
		//某个同事类发生了变化，通常需要与其他同事交户
		//具体协调相应的同事对象来实现协作行为
	}
}
```



## 2.体会中介者模式

![](/images/20181101175435.bmp)



![](/images/20181101180018.bmp)



代码实现：

​	![](/images/20181101180059.bmp)



```java
Colleague.java

/**
 * 同事类的抽象父类
 */
public abstract class Colleague {
	/**
	 * 持有中介者对象，每一个同事类都知道它的中介者对象
	 */
	private Mediator mediator;
	/**
	 * 构造方法，传入中介者对象
	 * @param mediator 中介者对象
	 */
	public Colleague(Mediator mediator) {
		this.mediator = mediator;
	}
	/**
	 * 获取当前同事类对应的中介者对象
	 * @return 对应的中介者对象
	 */
	public Mediator getMediator() {
		return mediator;
	}
}

CDDriver.java

/**
 * 光驱类，一个同事类
 */
public class CDDriver extends Colleague{
	public CDDriver(Mediator mediator) {
		super(mediator);
	}
	/**
	 * 光驱读取出来的数据
	 */
	private String data = "";
	/**
	 * 获取光驱读取出来的数据
	 * @return 光驱读取出来的数据
	 */
	public String getData(){
		return this.data;
	}
	/**
	 * 读取光盘
	 */
	public void readCD(){
		//逗号前是视频显示的数据，逗号后是声音
		this.data = "设计模式,值得好好研究";
		//通知主板，自己的状态发生了改变
		this.getMediator().changed(this);
	}
}


CPU.java

/**
 * CPU类，一个同事类
 */
public class CPU extends Colleague{
	public CPU(Mediator mediator) {
		super(mediator);
	}
	/**
	 * 分解出来的视频数据
	 */
	private String videoData = "";
	/**
	 * 分解出来的声音数据
	 */
	private String soundData = "";
	/**
	 * 获取分解出来的视频数据
	 * @return 分解出来的视频数据
	 */
	public String getVideoData() {
		return videoData;
	}
	/**
	 * 获取分解出来的声音数据
	 * @return 分解出来的声音数据
	 */
	public String getSoundData() {
		return soundData;
	}
	/**
	 * 处理数据，把数据分成音频和视频的数据
	 * @param data 被处理的数据
	 */
	public void executeData(String data){
		//把数据分解开，前面的是视频数据，后面的是音频数据
		String [] ss = data.split(",");
		this.videoData = ss[0];
		this.soundData = ss[1];
		//通知主板，CPU的工作完成
		this.getMediator().changed(this);
	}
}


SoundCard.java

/**
 * 声卡类，一个同事类
 */
public class SoundCard extends Colleague{
	public SoundCard(Mediator mediator) {
		super(mediator);
	}	
	/**
	 * 按照声频数据发出声音
	 * @param data 发出声音的数据
	 */
	public void soundData(String data){
		System.out.println("画外音："+data);
	}
}

VideoCard.java

/**
 * 显卡类，一个同事类
 */
public class VideoCard extends Colleague{
	public VideoCard(Mediator mediator) {
		super(mediator);
	}
	/**
	 * 显示视频数据
	 * @param data 被显示的数据
	 */
	public void showData(String data){
		System.out.println("您正观看的是："+data);
	}
}


Mediator.java
/**
 * 中介者对象的接口
 */
public interface Mediator {
	/**
	 * 同事对象在自身改变的时候来通知中介者的方法，
	 * 让中介者去负责相应的与其他同事对象的交互
	 * @param colleague 同事对象自身，好让中介者对象通过对象实例
	 *                  去获取同事对象的状态
	 */
	public void changed(Colleague colleague);
}


MotherBoard.java
/**
 * 主板类，实现中介者接口
 */
public class MotherBoard implements Mediator{
	/**
	 * 需要知道要交互的同事类——光驱类
	 */
	private CDDriver cdDriver = null;
	/**
	 * 需要知道要交互的同事类——CPU类
	 */
	private CPU cpu = null;
	/**
	 * 需要知道要交互的同事类——显卡类
	 */
	private VideoCard videoCard = null;
	/**
	 * 需要知道要交互的同事类——声卡类
	 */
	private SoundCard soundCard = null;

	public void setCdDriver(CDDriver cdDriver) {
		this.cdDriver = cdDriver;
	}
	public void setCpu(CPU cpu) {
		this.cpu = cpu;
	}
	public void setVideoCard(VideoCard videoCard) {
		this.videoCard = videoCard;
	}
	public void setSoundCard(SoundCard soundCard) {
		this.soundCard = soundCard;
	}
	
	public void changed(Colleague colleague) {
		if(colleague == cdDriver){
			//表示光驱读取数据了
			this.opeCDDriverReadData((CDDriver)colleague);
		}else if(colleague == cpu){
			//表示CPU处理完了
			this.opeCPU((CPU)colleague);
		}
	}
	/**
	 * 处理光驱读取数据过后与其他对象的交互
	 * @param cd 光驱同事对象
	 */
	private void opeCDDriverReadData(CDDriver cd){
		//1：先获取光驱读取的数据
		String data = cd.getData();
		//2：把这些数据传递给CPU进行处理
		this.cpu.executeData(data);
	}
	/**
	 * 处理CPU处理完数据后与其他对象的交互
	 * @param cpu CPU同事类
	 */
	private void opeCPU(CPU cpu){
		//1：先获取CPU处理过后的数据
		String videoData = cpu.getVideoData();
		String soundData = cpu.getSoundData();
		//2：把这些数据传递给显卡和声卡展示出来
		this.videoCard.showData(videoData);
		this.soundCard.soundData(soundData);
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//1：创建中介者——主板对象
		MotherBoard mediator = new MotherBoard();
		//2：创建同事类
		CDDriver cd = new CDDriver(mediator);
		CPU cpu = new CPU(mediator);
		VideoCard vc = new VideoCard(mediator);
		SoundCard sc = new SoundCard(mediator);
		//3：让中介者知道所有的同事
		mediator.setCdDriver(cd);
		mediator.setCpu(cpu);
		mediator.setVideoCard(vc);
		mediator.setSoundCard(sc);
		
		//4：开始看电影，把光盘放入光驱，光驱开始读盘
		cd.readCD();
	}
}
```



## 3.理解中介者模式

#### 	1.认识中介者模式

​		**中介者模式的功能**：其功能非常简单，就式封装对象之间的交互。能够集中的控制这些对象的交互关系。

​		**需要Mediator接口吗**：取决于是否会提供多个不同的中介者实现。

​		**同事关系**：在该模式中，需要这些类都要继承相同的类，这些对象从某种角度式同一个类型，算是兄弟对象。

​		**同事和中介者的关系**：  中介者对象和同事对象之间是相互依赖的。

​		**如何实现同事和中介者的通信**： a.  在Mediator接口中定义一个特殊的通知接口，作为一个通用的方法，让各个同事类来吊桶这各方法。                 b.采用观察者模式

​		**中介者调用顺序示意图**

​			![](/images/20181102100831.bmp) 

#### 		2.广义中介者

​		![](/images/20181102101530.bmp)  

![](/images/20181102101551.bmp)

![](/images/20181102101623.bmp)

​		





![](/images/20181102105442.bmp)



![](/images/20181102105504.bmp)  

![](/images/20181102105522.bmp)





```java
User.java

/**
 * 人员类
 */
public class User{
	/**
	 * 人员编号
	 */
	private String userId;
	/**
	 * 人员名称
	 */
	private String userName;
	public String getUserId() {
		return userId;
	}
	public void setUserId(String userId) {
		this.userId = userId;
	}
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	/**
	 * 人员离职
	 * @return 是否处理成功
	 */
	public boolean dimission(){
		//1：要先通过中介者去清除掉所有与这个人员相关的部门和人员的关系
		DepUserMediatorImpl mediator = DepUserMediatorImpl.getInstance();
		mediator.deleteUser(userId);
		//2：然后才能真的清除掉这个人员
		//请注意，实际开发中，人员离职，是不会真的删除人员记录的，
		//通常是把人员记录的状态或者是删除标记设置成已删除，
		//只是不再参加新的业务，但是已经发生的业务记录是不会被清除掉的
		
		return true;
	}
}


Dep.java

/**
 * 部门类
 */
public class Dep{
	/**
	 * 描述部门编号
	 */
	private String depId;
	/**
	 * 描述部门名称
	 */
	private String depName;
	public String getDepId() {
		return depId;
	}
	public void setDepId(String depId) {
		this.depId = depId;
	}
	public String getDepName() {
		return depName;
	}
	public void setDepName(String depName) {
		this.depName = depName;
	}
	/**
	 * 撤销部门
	 * @return 是否撤销成功
	 */
	public boolean deleteDep(){
		//1：要先通过中介者去清除掉所有与这个部门相关的部门和人员的关系
		DepUserMediatorImpl mediator = DepUserMediatorImpl.getInstance();
		mediator.deleteDep(depId);
		//2：然后才能真的清除掉这个部门
		//请注意在实际开发中，这些业务功能可能会做到业务层去，
		//而且实际开发中对于已经使用的业务数据通常是不会被删除的，
		//而是会被做为历史数据保留
		return true;
	}
}


DepUserModel.java

/**
 *	描述部门和人员关系的类
 */
public class DepUserModel {
	/**
	 * 用于部门和人员关系的编号，用做主键
	 */
	private String depUserId;
	/**
	 * 部门的编号
	 */
	private String depId;
	/**
	 * 人员的编号
	 */
	private String userId;
	public String getDepUserId() {
		return depUserId;
	}
	public void setDepUserId(String depUserId) {
		this.depUserId = depUserId;
	}
	public String getDepId() {
		return depId;
	}
	public void setDepId(String depId) {
		this.depId = depId;
	}
	public String getUserId() {
		return userId;
	}
	public void setUserId(String userId) {
		this.userId = userId;
	}
}



DepUserMediatorImpl.java

/**
 * 实现部门和人员交互的中介者实现类
 * 说明：为了演示的简洁性，只示例实现撤销部门和人员离职的功能
 */
public class DepUserMediatorImpl{
	private static DepUserMediatorImpl mediator = new DepUserMediatorImpl();
	private DepUserMediatorImpl(){
		//调用初始化测试数据的功能
		initTestData();
	}
	public static DepUserMediatorImpl getInstance(){
		return mediator;
	}
	
	/**
	 * 测试用，记录部门和人员的关系
	 */
	private Collection<DepUserModel> depUserCol = new ArrayList<DepUserModel>();
	/**
	 * 初始化测试数据
	 */
	private void initTestData(){
		//准备一些测试数据
		DepUserModel du1 = new DepUserModel();
		du1.setDepUserId("du1");
		du1.setDepId("d1");
		du1.setUserId("u1");		
		depUserCol.add(du1);
		
		DepUserModel du2 = new DepUserModel();
		du2.setDepUserId("du2");
		du2.setDepId("d1");
		du2.setUserId("u2");		
		depUserCol.add(du2);
		
		DepUserModel du3 = new DepUserModel();
		du3.setDepUserId("du3");
		du3.setDepId("d2");
		du3.setUserId("u3");		
		depUserCol.add(du3);
		
		DepUserModel du4 = new DepUserModel();
		du4.setDepUserId("du4");
		du4.setDepId("d2");
		du4.setUserId("u4");		
		depUserCol.add(du4);
		
		DepUserModel du5 = new DepUserModel();
		du5.setDepUserId("du5");
		du5.setDepId("d2");
		du5.setUserId("u1");		
		depUserCol.add(du5);
	}
	/**
	 * 完成因撤销部门的操作所引起的与人员的交互，需要去除相应的关系
	 * @param depId 被撤销的部门对象的编号
	 * @return 是否已经正确的处理了因撤销部门所引起的与人员的交互
	 */
	public boolean deleteDep(String depId) {
		//请注意：为了演示简单，部门撤销后，原部门的人员怎么处理等后续业务处理，这里就不管了
		
		//1：到记录部门和人员关系的集合里面，寻找跟这个部门相关的人员
		//设置一个临时的集合，记录需要清除的关系对象
		Collection<DepUserModel> tempCol = new ArrayList<DepUserModel>();
		for(DepUserModel du : depUserCol){
			if(du.getDepId().equals(depId)){
				//2：需要把这个相关的记录去掉，先记录下来
				tempCol.add(du);
			}
		}
		//3：从关系集合里面清除掉这些关系
		depUserCol.removeAll(tempCol);
		
		return true;
	}
	/**
	 * 完成因人员离职引起的与部门的交互
	 * @param userId 离职的人员的编号
	 * @return 是否正确处理了因人员离职引起的与部门的交互
	 */
	public boolean deleteUser(String userId) {
		//1：到记录部门和人员关系的集合里面，寻找跟这个人员相关的部门
		//设置一个临时的集合，记录需要清除的关系对象
		Collection<DepUserModel> tempCol = new ArrayList<DepUserModel>();
		for(DepUserModel du : depUserCol){
			if(du.getUserId().equals(userId)){
				//2：需要把这个相关的记录去掉，先记录下来
				tempCol.add(du);
			}
		}
		//3：从关系集合里面清除掉这些关系
		depUserCol.removeAll(tempCol);
	
		return true;
	}
	/**
	 * 测试用，在内部打印显示一下一个部门下的所有人员
	 * @param dep 部门对象
	 */
	public void showDepUsers(Dep dep) {
		for(DepUserModel du : depUserCol){
			if(du.getDepId().equals(dep.getDepId())){
				System.out.println("部门编号="+dep.getDepId()+"下面拥有人员，其编号是："+du.getUserId());
			}
		}
	}
	/**
	 * 测试用，在内部打印显示一下一个人员所属的部门
	 * @param user 人员对象
	 */
	public void showUserDeps(User user) {
		for(DepUserModel du : depUserCol){
			if(du.getUserId().equals(user.getUserId())){
				System.out.println("人员编号="+user.getUserId()+"属于部门编号是："+du.getDepId());
			}
		}
	}
	/**
	 * 完成因人员调换部门引起的与部门的交互
	 * @param userId 被调换的人员的编号
	 * @param oldDepId 调换前的部门的编号
	 * @param newDepId 调换后的部门的编号
	 * @return 是否正确处理了因人员调换部门引起的与部门的交互
	 */
	public boolean changeDep(String userId,String oldDepId, String newDepId) {
		//本示例不去实现了
		return false;
	}
	

	/**
	 * 完成因部门合并操作所引起的与人员的交互
	 * @param colDepIds 需要合并的部门的编号集合
	 * @param newDep 合并后新的部门对象
	 * @return 是否正确处理了因部门合并操作所引起的与人员的交互
	 */
	public boolean joinDep(Collection<String> colDepIds, Dep newDep) {
		//本示例不去实现了		
		return false;
	}
}


Client.java
public class Client {
	public static void main(String[] args) {
		DepUserMediatorImpl mediator = DepUserMediatorImpl.getInstance();
		//准备要撤销的部门，仅仅需要一个部门编号
		Dep dep = new Dep();
		dep.setDepId("d1");
		Dep dep2 = new Dep();
		dep2.setDepId("d2");
		//准备用于测试的人员，也只需要一个人员编号
		User user = new User();
		user.setUserId("u1");
		
		//测试撤销部门，在运行之前，输出一下，看这个人员属于哪些部门		
		System.out.println("撤销部门前------------------");
		mediator.showUserDeps(user);
		
		//真正执行业务，撤销这个部门
		dep.deleteDep();
		
		//再次输出一下，看这个人员属于哪些部门
		System.out.println("撤销部门后------------------");
		mediator.showUserDeps(user);
		
		//测试人员离职，在运行之前，输出一下，看这个部门下都有哪些人员
		System.out.println("---------------------------------");
		System.out.println("人员离职前------------------");
		mediator.showDepUsers(dep2);
		
		//真正执行业务，人员离职
		user.dimission();		
		//再次输出一下，看这个部门下都有哪些人员
		System.out.println("人员离职后------------------");
		mediator.showDepUsers(dep2);
	}
}
```



​	中介者模式的优缺点：

​	1.松散耦合

​	2.集中控制交互

​	3.多对多编程一对多

​	4.过度集中化



## 4.思考中介者模式 

​	中介者模式的本质：**封装交互**

​	何时选用中介者模式：

​	1.如果一组对象之间的通信方式比较复杂，导致互相依赖、结构混乱，可以采用中介者模式，把这些对象的相互的交互管理起来，各个对象都只需要和中介者交互，从而使得各个对象松散耦合，结构也更清晰易懂/

​	2.如果一个对象引用了很多的对象，并直接跟这些对象交互，导致难以复用对象。可以采用中介者模式，把这个对象跟其他对象的交互封装到中介者对象里面，这个对象就只需要和中介者对象交互就可以了。



# 九、代理模式

## 1.初识代理模式

​	定义：  为其他对象提供一种代理以控制对这个对象的访问。

​	结构和说明：

​		![](/images/20181102150047.bmp)





​	Proxy：代理对象，通常具有如下的功能：

​	1.实现与具体的目标一样的接口，这样就可以使用代理来代替具体的目标对象

​	2.保存一个指向具体目标对象的引用，可以在需要的时候调用具体的目标对象

​	3.可以控制对具体目标对象的访问，并可能负责创建和删除它



​	Subject：目标接口，定义代理和具体目标对象的接口，这样就可以在任何使用具体目标对象的地方使用代理对象

​	RealSubject:具体的目标对象，真正实现目标接口要求的功能。

​	



## 2.体会代理模式

![](/images/20181102150124.bmp)

 ![](/images/20181102150146.bmp)



![](/images/20181102150209.bmp)

![](/images/20181102150232.bmp)

 



```java
UserModelApi.java

/**
 * 定义用户数据对象的接口
 */
public interface UserModelApi {
	public String getUserId();
	public void setUserId(String userId);
	public String getName();
	public void setName(String name);
	public String getDepId();
	public void setDepId(String depId);
	public String getSex();
	public void setSex(String sex);
}


UserModel.java

/**
 * 描述用户数据的对象
 */
public class UserModel implements UserModelApi{	
	/**
	 * 用户编号
	 */
	private String userId;
	/**
	 * 用户姓名
	 */
	private String name;
	/**
	 * 部门编号
	 */
	private String depId;
	/**
	 * 性别
	 */
	private String sex;
	
	public String getUserId() {
		return userId;
	}
	public void setUserId(String userId) {
		this.userId = userId;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDepId() {
		return depId;
	}
	public void setDepId(String depId) {
		this.depId = depId;
	}
	public String getSex() {
		return sex;
	}
	public void setSex(String sex) {
		this.sex = sex;
	}
	
	@Override
	public String toString(){
		return "userId="+userId+",name="+name+",depId="+depId+",sex="+sex+"\n";
	}
}


Proxy.java

/**
 * 代理对象,代理用户数据对象
 */
public class Proxy implements UserModelApi{
	/**
	 * 持有被代理的具体的目标对象
	 */
	private UserModel realSubject=null;
	/**
	 * 构造方法，传入被代理的具体的目标对象
	 * @param realSubject 被代理的具体的目标对象
	 */
	public Proxy(UserModel realSubject){
		this.realSubject = realSubject;
	}
	/**
	 * 标示是否已经重新装载过数据了
	 */
	private boolean loaded = false;
	
	
	public String getUserId() {
		return realSubject.getUserId();
	}
	public void setUserId(String userId) {
		realSubject.setUserId(userId);
	}
	public String getName() {
		return realSubject.getName();
	}
	public void setName(String name) {
		realSubject.setName(name);
	}
	
	
	public void setDepId(String depId) {
		realSubject.setDepId(depId);
	}
	public void setSex(String sex) {
		realSubject.setSex(sex);
	}
	
	public String getDepId() {
		//需要判断是否已经装载过了
		if(!this.loaded){
			//从数据库中重新装载
			reload();
			//设置重新装载的标志为true
			this.loaded = true;
		}
		return realSubject.getDepId();
	}	
	public String getSex() {
		if(!this.loaded){
			reload();
			this.loaded = true;
		}
		return realSubject.getSex();
	}
	
	/**
	 * 重新查询数据库以获取完整的用户数据
	 */
	private void reload(){
		System.out.println("重新查询数据库获取完整的用户数据，userId=="+realSubject.getUserId());
		Connection conn = null;
		try{
			conn = this.getConnection();
			String sql = "select * from tbl_user where userId=? ";

			PreparedStatement pstmt = conn.prepareStatement(sql);
			pstmt.setString(1, realSubject.getUserId());
			
			ResultSet rs = pstmt.executeQuery();
			if(rs.next()){
				//只需要重新获取除了userId和name外的数据
				realSubject.setDepId(rs.getString("depId"));
				realSubject.setSex(rs.getString("sex"));
			}
			
			rs.close();
			pstmt.close();
		}catch(Exception err){
			err.printStackTrace();
		}finally{
			try {
				conn.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
	public String toString(){
		return "userId="+getUserId()+",name="+getName()
		+",depId="+getDepId()+",sex="+getSex()+"\n";
	}

	private Connection getConnection() throws Exception {
		Class.forName("oracle.jdbc.driver.OracleDriver");
		return DriverManager.getConnection(
				"jdbc:oracle:thin:@localhost:1521:orcl", "test", "test");
	}
}


UserManager.java

/**
 * 实现示例要求的功能
 */
public class UserManager {	
	/**
	 * 根据部门编号来获取该部门下的所有人员
	 * @param depId 部门编号
	 * @return 该部门下的所有人员
	 */
	public Collection<UserModelApi> getUserByDepId(String depId)throws Exception{
		Collection<UserModelApi> col = new ArrayList<UserModelApi>();
		Connection conn = null;
		try{
			conn = this.getConnection();
			//只需要查询userId和name两个值就可以了
			String sql = "select u.userId,u.name "
				+"from tbl_user u,tbl_dep d "
				+"where u.depId=d.depId and d.depId like ?";

			PreparedStatement pstmt = conn.prepareStatement(sql);
			pstmt.setString(1, depId+"%");
			
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				//这里是创建的代理对象，而不是直接创建UserModel的对象
				Proxy proxy = new Proxy(new UserModel());
				//只是设置userId和name两个值就可以了
				proxy.setUserId(rs.getString("userId"));
				proxy.setName(rs.getString("name"));
				
				col.add(proxy);
			}
			
			rs.close();
			pstmt.close();
		}finally{
			conn.close();
		}
		return col;
	}
	/**
	 * 获取与数据库的连接
	 * @return 数据库连接
	 */
	private Connection getConnection() throws Exception {
		Class.forName("oracle.jdbc.driver.OracleDriver");
		return DriverManager.getConnection(
				"jdbc:oracle:thin:@localhost:1521:orcl", "test", "test");
	}
}


Client.java

public class Client {
	public static void main(String[] args) throws Exception{
		UserManager userManager = new UserManager();
		Collection<UserModelApi> col = userManager.getUserByDepId("0101");

		//如果只是显示用户名称，那么不需要重新查询数据库
		for(UserModelApi umApi : col){
			System.out.println("用户编号：="+umApi.getUserId()+",用户姓名：="+umApi.getName());
		}
		//如果访问非用户编号和用户姓名外的属性，那就会重新查询数据库
		for(UserModelApi umApi : col){
			System.out.println("用户编号：="+umApi.getUserId()+",用户姓名：="+umApi.getName()+",所属部门：="+umApi.getDepId());
		}
	}
}
```



## 3.理解代理模式

​	**1.认识代理模式**

​		**代理模式的功能：**代理模式是用过创建一个代理对象，用这个代理对象去代表真实的对象，客户端得到这个代理对象后，对客户端没有说明影响，就跟得到真实的对象一样来实现。

​		当客户端操作这个代理对象时，实际上功能最终还是会由真实的对象来完成，只不过是通过代理操作的，也就是客户端操作代理，代理操作真正的对象。  正是因为由代理对象夹在客户端和被代理的真实对象中间，相当于一个中转，那么在中转的时候就可以加入自定义的操作，比如：判断一下权限，如果没有足够的权限那就不中转等等。

​		**代理的分类** 

​		1.虚代理： 根据需要来创建开销很大的对象，该对象只有在需要的时候才会被真正的创建。

​		2.远程代理：用来在不同的地址空间上代表同一个对象，这个不同的地址空间可以是在本机，也可以在其他机器上，在Java里面最典型的就是RMI技术。

​		3.copy-on-write代理：在客户端操作的时候，只有对象确实改变了，才会真的拷贝一个目标对象，算是虚代理的一个分支。

​		4.保护代理：控制对原始对象的访问，如果需要，可以给不同的用户提供不同的访问权限，以控制它们对原始对象的访问

​		5.Cache代理：为那些昂贵的操作的结果提供临时的存储空间，以便多个客户端可以共享这些代理。

​		6.防火墙代理：保护对象不被恶意用户访问和操作

​		7.同步代理：使多个用户能够同时访问目标对象而没有冲突

​		8.智能指引：在访问对象是执行一些附加操作，比如：对指向世界对象的引用计数、第一次引用一个持久对象时，将它装入内存等。

​		**具体目标和代理的关系**

​		从代理模式的结构图来看，好像是由一个具体的目标类就有一个代理类，其实不是这样的。如果代理类能完全通过接口来操作它所代理的目标对象，那么代理对象就不需要知道具体的目标对象，这样就无须为每一个具体目标类都创建一个代理类了。

​		但是，如果代理类必须要实例化它代理的目标对象，那么代理类就必须知道具体被代理的对象，这种情况下，一个具体目标类通常会有一个代理类。这种情况多出现在虚代理的实现里面。

​		**代理模式的调用顺序示意图：**

​		![](/images/20181102145702.bmp) 

​		



​	**保护代理**

​		保护代理是一种控制元原始对象访问的代理，多用于对象应该有不同的访问权限的时候。保护代理会检查调用者是否具有请求所必须的访问对象，如果没有相应的权限，那么就不会调用目标对象，从而实现对目标对象的保护。

​			![](/images/20181102150713.bmp) 

```java
OrderApi.java
/**
 * 订单对象的接口定义
 */
public interface OrderApi {
	/**
	 * 获取订单订购的产品名称
	 * @return 订单订购的产品名称
	 */
	public String getProductName();
	/**
	 * 设置订单订购的产品名称
	 * @param productName 订单订购的产品名称
	 * @param user 操作人员
	 */
	public void setProductName(String productName,String user);
	/**
	 * 获取订单订购的数量
	 * @return 订单订购的数量
	 */
	public int getOrderNum();
	/**
	 * 设置订单订购的数量
	 * @param orderNum 订单订购的数量
	 * @param user 操作人员
	 */
	public void setOrderNum(int orderNum,String user);
	/**
	 * 获取创建订单的人员
	 * @return 创建订单的人员
	 */
	public String getOrderUser();
	/**
	 * 设置创建订单的人员
	 * @param orderUser 创建订单的人员
	 * @param user 操作人员
	 */
	public void setOrderUser(String orderUser,String user);
}

Order.java

/**
 * 订单对象
 */
public class Order implements OrderApi{
	/**
	 * 订单订购的产品名称
	 */
	private String productName;
	/**
	 * 订单订购的数量
	 */
	private int orderNum;
	/**
	 * 创建订单的人员
	 */
	private String orderUser;
	
	/**
	 * 构造方法，传入构建需要的数据
	 * @param productName 订单订购的产品名称
	 * @param orderNum 订单订购的数量
	 * @param orderUser 创建订单的人员
	 */
	public Order(String productName,int orderNum,String orderUser){
		this.productName = productName;
		this.orderNum = orderNum;
		this.orderUser = orderUser;
	}
	
	public String getProductName() {
		return productName;
	}
	public void setProductName(String productName,String user) {
		this.productName = productName;
	}
	public int getOrderNum() {
		return orderNum;
	}
	public void setOrderNum(int orderNum,String user) {
		this.orderNum = orderNum;
	}
	public String getOrderUser() {
		return orderUser;
	}
	public void setOrderUser(String orderUser,String user) {
		this.orderUser = orderUser;
	}
}

OrderProxy.java

/**
 * 订单的代理对象
 */
public class OrderProxy implements OrderApi{
	/**
	 * 持有被代理的具体的目标对象
	 */
	private Order order=null;
	/**
	 * 构造方法，传入被代理的具体的目标对象
	 * @param realSubject 被代理的具体的目标对象
	 */
	public OrderProxy(Order realSubject){
		this.order = realSubject;
	}
	public void setProductName(String productName,String user) {
		//控制访问权限，只有创建订单的人员才能够修改
		if(user!=null && user.equals(this.getOrderUser())){
			order.setProductName(productName, user);
		}else{
			System.out.println("对不起"+user+"，您无权修改订单中的产品名称。");
		}
	}
	public void setOrderNum(int orderNum,String user) {
		//控制访问权限，只有创建订单的人员才能够修改
		if(user!=null && user.equals(this.getOrderUser())){
			order.setOrderNum(orderNum, user);
		}else{
			System.out.println("对不起"+user+"，您无权修改订单中的订购数量。");
		}
	}
	public void setOrderUser(String orderUser,String user) {
		//控制访问权限，只有创建订单的人员才能够修改
		if(user!=null && user.equals(this.getOrderUser())){
			order.setOrderUser(orderUser, user);
		}else{
			System.out.println("对不起"+user+"，您无权修改订单中的订购人。");
		}
	}
	public int getOrderNum() {
		return this.order.getOrderNum();
	}
	public String getOrderUser() {
		return this.order.getOrderUser();
	}
	public String getProductName() {
		return this.order.getProductName();
	}
	public String toString(){
		return "productName="+this.getProductName()+",orderNum="+this.getOrderNum()+",orderUser="+this.getOrderUser();
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//张三先登录系统创建了一个订单
		OrderApi order = new OrderProxy(new Order("设计模式",100,"张三"));
		//李四想要来修改，那就会报错
		order.setOrderNum(123, "李四");
		//输出order
		System.out.println("李四修改后订单记录没有变化："+order);
		//张三修改就不会有问题
		order.setOrderNum(123, "张三");
		//再次输出order
		System.out.println("张三修改后，订单记录："+order);
	}
}
```



​	**Java中的代理**

​	1.java的静态代理

​		通常把前面自己实现的代理模式，称位Java的静态代理。这种实现方式有一个较大的缺点，就是如果Subject接口发生变化，那么代理类和具体的目标实现都要变化，不是很灵活。

​	2.java的动态代理

​		通常把使用Java内建的对代理模式支持的功能来实现的代理称位Java的动态代理。动态代理跟静态代理相比，明显的变化是：静态代理实现的时候，在Subject接口上定义很多的方法，代理类里面自然也要实现很多方法；而动态代理实现的时候，虽然Subject接口上定义了很多方法，但是动态代理类始终只有一个Invoke方法。这样当Subject接口发生变化的时候，动态代理接口就不需要跟着变化。

​	

```java
OrderApi.java


/**
 * 订单对象的接口定义
 */
public interface OrderApi {
	/**
	 * 获取订单订购的产品名称
	 * @return 订单订购的产品名称
	 */
	public String getProductName();
	/**
	 * 设置订单订购的产品名称
	 * @param productName 订单订购的产品名称
	 * @param user 操作人员
	 */
	public void setProductName(String productName,String user);
	/**
	 * 获取订单订购的数量
	 * @return 订单订购的数量
	 */
	public int getOrderNum();
	/**
	 * 设置订单订购的数量
	 * @param orderNum 订单订购的数量
	 * @param user 操作人员
	 */
	public void setOrderNum(int orderNum,String user);
	/**
	 * 获取创建订单的人员
	 * @return 创建订单的人员
	 */
	public String getOrderUser();
	/**
	 * 设置创建订单的人员
	 * @param orderUser 创建订单的人员
	 * @param user 操作人员
	 */
	public void setOrderUser(String orderUser,String user);
}




Order.java

/**
 * 订单对象
 */
public class Order implements OrderApi{
	/**
	 * 订单订购的产品名称
	 */
	private String productName;
	/**
	 * 订单订购的数量
	 */
	private int orderNum;
	/**
	 * 创建订单的人员
	 */
	private String orderUser;
	
	/**
	 * 构造方法，传入构建需要的数据
	 * @param productName 订单订购的产品名称
	 * @param orderNum 订单订购的数量
	 * @param orderUser 创建订单的人员
	 */
	public Order(String productName,int orderNum,String orderUser){
		this.productName = productName;
		this.orderNum = orderNum;
		this.orderUser = orderUser;
	}
	
	public String getProductName() {
		return productName;
	}
	public void setProductName(String productName,String user) {
		this.productName = productName;
	}
	public int getOrderNum() {
		return orderNum;
	}
	public void setOrderNum(int orderNum,String user) {
		this.orderNum = orderNum;
	}
	public String getOrderUser() {
		return orderUser;
	}
	public void setOrderUser(String orderUser,String user) {
		this.orderUser = orderUser;
	}
	public String toString(){
		return "productName="+this.getProductName()+",orderNum="+this.getOrderNum()+",orderUser="+this.getOrderUser();
	}
}


DynamicProxy.java

/**
 * 使用Java中的动态代理
 */
public class DynamicProxy implements InvocationHandler{
	/**
	 * 被代理的对象
	 */
	private OrderApi order = null;
	/**
	 * 获取绑定好代理和具体目标对象后的目标对象的接口
	 * @param order 具体的订单对象，相当于具体目标对象
	 * @return 绑定好代理和具体目标对象后的目标对象的接口
	 */
	public OrderApi getProxyInterface(Order order){
		//设置被代理的对象，好方便invoke里面的操作
		this.order = order;
		//把真正的订单对象和动态代理关联起来
		OrderApi orderApi = (OrderApi) Proxy.newProxyInstance(
				order.getClass().getClassLoader(),
				order.getClass().getInterfaces(), 
				this);
		return orderApi;
	}
	
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		//如果是调用setter方法就需要检查权限
		if(method.getName().startsWith("set")){
			//如果不是创建人，那就不能修改
			if(order.getOrderUser()!=null && order.getOrderUser().equals(args[1])){
				//可以操作
				return method.invoke(order, args);
			}else{
				System.out.println("对不起，"+args[1]+"，您无权修改本订单中的数据");
			}
		}else{
			//不是调用的setter方法就继续运行
			return method.invoke(order, args);
		}
		return null;
	}
}

Client.java

public class Client {
	public static void main(String[] args) {
		//张三先登录系统创建了一个订单
		Order order = new Order("设计模式",100,"张三");
		
		//创建一个动态代理
		DynamicProxy dynamicProxy = new DynamicProxy();		
		//然后把订单和动态代理关联起来
		OrderApi orderApi = dynamicProxy.getProxyInterface(order);
		
		//以下就需要使用被代理过的接口来操作了
		//李四想要来修改，那就会报错
		orderApi.setOrderNum(123, "李四");
		//输出order
		System.out.println("李四修改后订单记录没有变化："+orderApi);
		//张三修改就不会有问题
		orderApi.setOrderNum(123, "张三");
		//再次输出order
		System.out.println("张三修改后，订单记录："+orderApi);	
	}
}
```



**代理模式的优缺点**

​	代理模式在客户和被客户访问的对象之间，引入了一定程度的间接性，客户是直接使用代理，让代理来与被访问的对象进行交互。不同的代理类型，这种附加的间接性有不同的用途，也就是有不同的特点：

1.远程代理：隐藏了一个对象存在于不同地址空间的事实，也即是客户通过远程代理去访问一个对象，根本就不关心这个对象在哪里，也不关心如何通过网络去访问到这个对象，从客户的角度来讲，它知识在使用代理对象而已。

2.虚代理：可以根据需要来创建”大“对象，只有到必须创建对象的时候，虚代理才会创建对象，从而大大加快程序运行速度，并节省资源。通过虚代理可以对系统进行优化。

3.保护代理：可以在访问一个对象的前后，执行很多附加的操作，除了进行权限控制之外，还可以进行很多跟业务相关的处理，而不需要修改被代理的对象。可以通过代理给目标对象增加功能。

4.智能指引：跟保护代理类似，也是允许在访问一个对象的前后，执行很多附加的操作。



## 4.思考代理模式

​	代理模式的本质：  **控制对象访问**

​	**也可以使用继承的方式实现代理模式**

​	何时选用代理模式：

​	1.需要为一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理。

​	2.需要按照需要创建开销很大的对象的时候，可以使用虚代理

​	3.需要控制对原始对象的访问的时候，可以使用保护代理

​	4.需要在访问对象的时候执行一些附加操作的时候，可以使用智能指引代理



# 十、观察者模式

## 1.初识观察者模式

​		**定义**：  定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变是，所有依赖于它的对象都得到通知并被自动更新。

​	**结构与说明**：

​	![](/images/20181102163829.bmp) 

​	



​	Subject:

​		目标对象，通常具有如下功能：

​		1.一个目标可以被多个观察者观察

​		2.目标提供对观察者注册和退订的维护

​		3.当目标的状态发生变化时，目标负责通知所有注册的、有效的观察者

​	Observer:

​		定义观察者的接口，提供目标通知时对应的更新方法，这个更新方法进行相应的业务处理，可以在这个方法里面回调目标对象，以获取目标对象的数据

​	Concrete Subject:

​		具体的目标实现对象，用来维护目标状态，当目标对象的状态发生癌变时候，通知所有注册有效的观察者，让观察者执行相应的处理。

​	ConcreteObserver：

​	观察者的具体实现对象，用来接收目标的通知，并进行相应的后续处理，比如更新自身的状态以保持和目标的相应状态一致





​	**简单代码示例**

​	

```java
Observer.java 

/**
 * 观察者接口，定义一个更新的接口给那些在目标发生改变的时候被通知的对象
 */
public interface Observer {
	/**
	 * 更新的接口
	 * @param subject 传入目标对象，好获取相应的目标对象的状态
	 */
	public void update(Subject subject);

}


ConcreteObserver.java

/**
 * 具体观察者对象，实现更新的方法，使自身的状态和目标的状态保持一致
 */
public class ConcreteObserver implements Observer {
	/**
	 * 示意，观者者的状态
	 */
	private String observerState;
	
	public void update(Subject subject) {
		// 具体的更新实现
		//这里可能需要更新观察者的状态，使其与目标的状态保持一致
		observerState = ((ConcreteSubject)subject).getSubjectState();
	}
}


Subject.java

/**
 * 目标对象，它知道观察它的观察者，并提供注册和删除观察者的接口
 */
public class Subject {
	/**
	 * 用来保存注册的观察者对象
	 */
	private List<Observer> observers = new ArrayList<Observer>();
	/**
	 * 注册观察者对象
	 * @param observer 观察者对象
	 */
	public void attach(Observer observer) {
		observers.add(observer);
	}
	/**
	 * 删除观察者对象
	 * @param observer 观察者对象
	 */
	public void detach(Observer observer) {
		observers.remove(observer);
	}
	/**
	 * 通知所有注册的观察者对象
	 */
	protected void notifyObservers() {
		for(Observer observer : observers){
			observer.update(this);
		}
	}
}

ConcreteSubject.java
/**
 * 具体的目标对象，负责把有关状态存入到相应的观察者对象，
 * 并在自己状态发生改变时，通知各个观察者
 */
public class ConcreteSubject extends Subject {
	/**
	 * 示意，目标对象的状态
	 */
	private String subjectState;
	public String getSubjectState() {
		return subjectState;
	}
	public void setSubjectState(String subjectState) {
		this.subjectState = subjectState;
		//状态发生了改变，通知各个观察者
		this.notifyObservers();
	}
}
```



## 2.体会观察者模式

​	![](/images/20181102171256.bmp)



![](/images/20181102171324.bmp) 

![](/images/20181102171404.bmp) 

![](/images/20181102171430.bmp)



```java
Observer.java

/**
 * 观察者，比如报纸的读者
 */
public interface Observer {
	/**
	 * 被通知的方法
	 * @param subject 具体的目标对象，可以获取报纸的内容
	 */
	public void update(Subject subject);
}

Reader.java

/**
 * 真正的读者，为了简单就描述一下姓名
 */
public class Reader implements Observer{
	/**
	 * 读者的姓名
	 */
	private String name;

	public void update(Subject subject) {
		//这是采用拉的方式
		System.out.println(name+"收到报纸了，阅读先。内容是==="+((NewsPaper)subject).getContent());
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}

Subject.java

/**
 * 目标对象，作为被观察者
 */
public class Subject {
	/**
	 * 用来保存注册的观察者对象，也就是报纸的订阅者
	 */
	private List<Observer> readers = new ArrayList<Observer>();
	/**
	 * 报纸的读者需要先向报社订阅，先要注册
	 * @param reader 报纸的读者 
	 * @return 是否注册成功
	 */
	public void attach(Observer reader) {
		readers.add(reader);
	}
	/**
	 * 报纸的读者可以取消订阅
	 * @param reader 报纸的读者
	 * @return 是否取消成功
	 */
	public void detach(Observer reader) {
		readers.remove(reader);
	}
	/**
	 * 当每期报纸印刷出来后，就要迅速的主动的被送到读者的手中，
	 * 相当于通知读者，让他们知道
	 */
	protected void notifyObservers() {
		for(Observer reader : readers){
			reader.update(this);
		}
	}
}

NewsPaper.java
/**
 * 报纸对象，具体的目标实现
 */
public class NewsPaper extends Subject{
	/**
	 * 报纸的具体内容
	 */
	private String content;
	/**
	 * 获取报纸的具体内容
	 * @return 报纸的具体内容
	 */
	public String getContent() {
		return content;
	}
	/**
	 * 示意，设置报纸的具体内容，相当于要出版报纸了
	 * @param content 报纸的具体内容
	 */
	public void setContent(String content) {
		this.content = content;
		//内容有了，说明又出报纸了，那就通知所有的读者
		notifyObservers();
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//创建一个报纸，作为被观察者
		NewsPaper subject = new NewsPaper();
		
		//创建阅读者，也就是观察者
		Reader reader1 = new Reader();
		reader1.setName("张三");
		
		Reader reader2 = new Reader();
		reader2.setName("李四");
		
		Reader reader3 = new Reader();
		reader3.setName("王五");
		
		//注册阅读者
		subject.attach(reader1);
		subject.attach(reader2);
		subject.attach(reader3);
		
		//要出报纸啦
		subject.setContent("本期内容是观察者模式");
	}
}
```



## 3.理解观察者模式

​	**认识观察者模式**

​	1.目标和观察者之间的关系

​			按照模式的定义，目标和观察者之间是典型的一对多的关系。

​			但是要注意，如果观察者只有一个，也是可以的，这样就变相实现了目标和观察者之间一对一的关系，这也使得在处理一个对象的状态变化会影响到另一个对象的时候，也可以考虑使用观察者模式。
			同样的，一个观察者也可以观察多个目标，如果观察者为多个目标定义的通知更新方法都是update方法的话，这会带来麻烦，因为需要接收多个目标的通知，如果是一个update的方法，那就需要在方法内部区分，到底这个更新的通知来自于哪一个目标，不同的目标有不同的后续操作。
			一般情况下，观察者应该为不同的观察者目标，定义不同的回调方法，这样实现最简单，不需要在update方法内部进行区分。

​	2.单向依赖

​		在观察者模式中，观察者和目标是单向依赖，只有观察者依赖于目标，而目标是不会依赖于观察者的。

​		它们之间联系的主动权掌握在目标手中，只有目标知道什么时候需要通知观察者，在整个过程中，观察者始终是被动的，被动的等待目标的通知，等待目标传值给它。

​		对目标而言，所有的观察者都是一样的，目标会一视同仁的对待。当然也可以通过在目标里面进行控制，实现有区别对待观察者，比如某些状态变化，只需要通知部分观察者，但那是属于稍微变形的用法了，不属于标准的、原始的观察者模式了。

​	3.基本实现说明

​		具体的目标实现对象要能维护观察者的注册信息，最简单的实现方案就如同前面的例子那样，采用一个集合来保存观察者的注册信息。	

​		具体的目标实现对象需要维护引起通知的状态，一般情况下是目标自身的状态，变形使用的情况下，也可以是别的对象的状态。

​		具体的观察者实现对象需要能接收目标的通知，能够接收目标传递的数据，或者是能够主动去获取目标的数据，并进行后续处理。

​		如果是一个观察者观察多个目标，那么在观察者的更新方法里面，需要去判断是来自哪一个目标的通知。一种简单的解决方案就是扩展update方法，比如在方法里面多传递一个参数进行区分等；还有一种更简单的方法，那就是干脆定义不同的回调方法。

​	4.命名建议

​		（1）观察者模式又被称为发布-订阅模式

​		 （2）目标接口的定义，建议在名称后面跟Subject

​		（3）观察者接口的定义，建议在名称后面跟Observer

​		（4）观察者接口的更新方法，建议名称为update，当然方法的参数可以根据需要定义，参数个数不限、参数类型不限

​	5.触发通知的时机

​		一般情况下，是在完成了状态维护后触发，因为通知会传递数据，不能够先通知后改数据，这很容易出问题，会导致观察者和目标对象的状态不一致。

​	6.相互观察

​		A对象的状态变化会引起B对象的联动操作，反过来，B 对象的状态变化也会引起A对象的联动操作。对于出现这种状况，要特别小心处理，因为可能会出现死循环的情况。

​	7.观察者模式的时序图：

​			在使用观察者模式时，会很明显的分成两个阶段，第一个阶段是准备阶段，也就是维护目标和观察者关系的阶段，这个阶段的调用顺序如图

​	

​		![](/images/20181102175825.bmp)

​			接下来就是实际的运行阶段了，这个阶段的调用顺序如图

​		![](/images/20181102175902.bmp)

​		8.通知的顺序

​		从理论上说，当目标对象的状态变化后通知所有观察者的时候，顺序是不确定的，因此观察者实现的功能，绝对不要依赖于通知的顺序，也就是说，多个观察者之间的功能是平行的，相互不应该有先后的依赖关系。



​	**推模型和拉模型**

​		推模型：目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是目标对象的全部或部分数据，相当于是在广播通信。

​		拉模型：目标对象在通知观察者的时候，只传递少量信息，如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据。

​		一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了



​	**推模型和拉模型的比较**

​	两种实现模型，在开发的时候，究竟应该使用哪一种，还是应该具体问题具体分析。这里，只是把两种模型进行一个简单的比较。
​	1：推模型是假定目标对象知道观察者需要的数据；而拉模型是目标对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传给观察者，让观察者自己去按需取值。
​	2：推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需而定义的，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能需要提供新的update方法，或者是干脆重新实现观察者。
​	而拉模型就不会造成这样的情况，因为拉模型下，update方法的参数是目标对象本身，这基本上是目标对象能传递的最大数据集合了，基本上可以适应各种情况的需要

​	

​	**java中的观察者模式：**

​	在java.util包里面有一个类Observable，它实现了大部分的功能，还有一个接口Observer，它里面定义了Update方法，就是观察者的接口。

​	

```java
Reader.java

/**
 * 真正的读者，为了简单就描述一下姓名
 */
public class Reader implements java.util.Observer{
	/**
	 * 读者的姓名
	 */
	private String name;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

	public void update(Observable o, Object obj) {
		//这是采用推的方式
		System.out.println(name+"收到报纸了，阅读先。目标推过来的内容是==="+obj);
		//这是获取拉的数据
		System.out.println(name+"收到报纸了，阅读先。主动到目标对象去拉的内容是==="
		+((NewsPaper)o).getContent());
	}
	
}


NewsPaper.java

/**
 * 报纸对象，具体的目标实现
 */
public class NewsPaper extends java.util.Observable{
	/**
	 * 报纸的具体内容
	 */
	private String content;
	/**
	 * 获取报纸的具体内容
	 * @return 报纸的具体内容
	 */
	public String getContent() {
		return content;
	}
	/**
	 * 示意，设置报纸的具体内容，相当于要出版报纸了
	 * @param content 报纸的具体内容
	 */
	public void setContent(String content) {
		this.content = content;
		//内容有了，说明又出报纸了，那就通知所有的读者
		//注意在用Java中的Observer模式的时候，这句话不可少
		this.setChanged();
		//然后主动通知，这里用的是推的方式
		this.notifyObservers(this.content);
		//如果用拉的方式，这么调用
		//this.notifyObservers();
	}
}

Client.java

public class Client {
	public static void main(String[] args) {
		//创建一个报纸，作为被观察者
		NewsPaper subject = new NewsPaper();
		
		//创建阅读者，也就是观察者
		Reader reader1 = new Reader();
		reader1.setName("张三");
		
		Reader reader2 = new Reader();
		reader2.setName("李四");
		
		Reader reader3 = new Reader();
		reader3.setName("王五");
		
		//注册阅读者
		subject.addObserver(reader1);
		subject.addObserver(reader2);
		subject.addObserver(reader3);
		
		//要出报纸啦
		subject.setContent("本期内容是观察者模式");
	}
}
```

​		

​	**Swing中的观察者模式**

​	Swing中到处都是观察者模式的身影，比如大家熟悉的事件处理，就是典型的观察者模式的应用。（说明一下：早期的Swing事件处理用的是职责链）
​	Swing组件是被观察的目标，而每个实现监听器的类就是观察者，监听器的接口就是观察者的接口，在调用addXXXListener方法的时候就相当于注册观察者。
​	当组件被点击，状态发生改变的时候，就会产生相应的通知，会调用注册的观察者的方法，就是我们所实现的监听器的方法。
​	从这里还可以学一招：如何处理一个观察者观察多个目标对象

​	

​	**观察者模式的优缺点** 

​	1.观察者模式实现了观察者和目标之间的抽象耦合

​	2.观察者模式实现了动态联动

​	3.观察者模式支持广播通信

​	4.观察者模式可以会引起无谓的操作



**简单变形示例--区别对待观察者：**

​	1：范例需求

​		这是一个实际系统的简化需求：在一个水质监测系统中有这样一个功能，当水中的杂质为正常的时候，只是通知监测人员做记录；当为轻度污染的时候，除了通知监测人员做记录外，还要通知预警人员，判断是否需要预警；当为中度或者高度污染的时候，除了通知监测人员做记录外，还要通知预警人员，判断是否需要预警，同时还要通知监测部门领导做相应的处理。
​	2：解决思路和范例代码
​		分析上述需求就会发现，对于水质污染这件事情，有可能会涉及到监测员、预警人员、监测部门领导，根据不同的水质污染情况涉及到不同的人员，也就是说，监测员、预警人员、监测部门领导他们三者是平行的，职责都是处理水质污染，但是处理的范围不一样。因此很容易套用上观察者模式，如果把水质污染的记录当作被观察的目标的话，那么监测员、预警人员和监测部门领导就都是观察者了。

​		前面学过的观察者模式，当目标通知观察者的时候是全部都通知，但是现在这个需求是不同的情况来让不同的人处理，怎么办呢？
**解决的方式通常有两种，一种是目标可以通知，但是观察者不做任何操作；另外一种是在目标里面进行判断，干脆就不通知了。**两种实现方式各有千秋，这里选择后面一种方式来示例，这种方式能够统一逻辑控制，并进行观察者的统一分派，有利于业务控制和今后的扩展。

```java
WatcherObserver.java

/**
 * 水质观察者接口定义
 */
public interface WatcherObserver {
	/**
	 * 被通知的方法
	 * @param subject 传入被观察的目标对象
	 */
	public void update(WaterQualitySubject subject);
	/**
	 * 设置观察人员的职务
	 * @param job 观察人员的职务
	 */
	public void setJob(String job);
	/**
	 * 获取观察人员的职务
	 * @return 观察人员的职务
	 */
	public String getJob();
}


Watcher.java

/**
 * 具体的观察者实现
 */
public class Watcher implements WatcherObserver{
	/**
	 * 职务
	 */
	private String job;
	
	public void update(WaterQualitySubject subject) {
		//这里采用的是拉的方式
		System.out.println(job+"获取到通知，当前污染级别为："+subject.getPolluteLevel());
	}
	
	public String getJob() {
		return this.job;
	}
	
	public void setJob(String job) {
		this.job = job;
	}
}




WaterQualitySubject.java

/**
 * 定义水质监测的目标对象
 */
public abstract class WaterQualitySubject {
	/**
	 * 用来保存注册的观察者对象
	 */
	protected List<WatcherObserver> observers = new ArrayList<WatcherObserver>();
	/**
	 * 注册观察者对象
	 * @param observer 观察者对象
	 */
	public void attach(WatcherObserver observer) {
		observers.add(observer);
	}
	/**
	 * 删除观察者对象
	 * @param observer 观察者对象
	 */
	public void detach(WatcherObserver observer) {
		observers.remove(observer);
	}
	/**
	 * 通知相应的观察者对象
	 */
	public abstract void notifyWatchers();
	/**
	 * 获取水质污染的级别
	 * @return 水质污染的级别
	 */
	public abstract int getPolluteLevel();
}


WaterQuality.java

/**
 * 具体的水质监测对象
 */
public class WaterQuality extends WaterQualitySubject{
	/**
	 * 污染的级别，0表示正常，1表示轻度污染，2表示中度污染，3表示高度污染
	 */
	private int polluteLevel = 0;
	/**
	 * 获取水质污染的级别
	 * @return 水质污染的级别
	 */
	public int getPolluteLevel() {
		return polluteLevel;
	}
	/**
	 * 当监测水质情况后，设置水质污染的级别
	 * @param polluteLevel 水质污染的级别
	 */
	public void setPolluteLevel(int polluteLevel) {
		this.polluteLevel = polluteLevel;
		//通知相应的观察者
		this.notifyWatchers();
	}
	/**
	 * 通知相应的观察者对象
	 */
	public void notifyWatchers() {
		//循环所有注册的观察者
		for(WatcherObserver watcher : observers){
						//开始根据污染级别判断是否需要通知，由这里总控
						if(this.polluteLevel >= 0){
							//通知监测员做记录
							if("监测人员".equals(watcher.getJob())){
								watcher.update(this);
							}
						}
						if(this.polluteLevel >= 1){
							//通知预警人员
							if("预警人员".equals(watcher.getJob())){
								watcher.update(this);
							}
						}
						if(this.polluteLevel >= 2){
							//通知监测部门领导
							if("监测部门领导".equals(watcher.getJob())){
								watcher.update(this);
							}
						}
		}
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//创建水质主题对象
		WaterQuality subject = new WaterQuality();
		//创建几个观察者
		WatcherObserver watcher1 = new Watcher();
		watcher1.setJob("监测人员");
		WatcherObserver watcher2 = new Watcher();
		watcher2.setJob("预警人员");
		WatcherObserver watcher3 = new Watcher();
		watcher3.setJob("监测部门领导");
		//注册观察者
		subject.attach(watcher1);
		subject.attach(watcher2);
		subject.attach(watcher3);
		
		//填写水质报告
		System.out.println("当水质为正常的时候------------------〉");
		subject.setPolluteLevel(0);
		System.out.println("当水质为轻度污染的时候---------------〉");
		subject.setPolluteLevel(1);
		System.out.println("当水质为中度污染的时候---------------〉");
		subject.setPolluteLevel(2);
	}
}
```



## 4.思考观察者模式

​	观察者模式的本质是：**触发联动**

​	何时选用观察者模式:

​		1.当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化。

​		2.如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，这种情况可以选用观察者模式，被更改的那一个对象很明显就是相当于是目标对象，则需要连带修改的多个其他对象，就作为多个观察者对象了。

​	3.当一个对象必须通知其他的对象，但是又希望这个对象和其他被通知的对象是松散耦合的。



# 十一、命令模式

## 1.初识命令模式

​	定义： 将一个请求封装成一个对象，从而使你可以不同的请求对客户进行参数化：对请求排列或记录请求日志，以及支持可撤销的操作。

​	



## 2.体会命令模式





## 3.理解命令模式











**命令模式的优缺点**

​	1.更松散的耦合

​	2.更动态的控制

​	3.能很自然的复古命令

​	4.更好的扩展性

**退化的命令模式**

​	前面讲到了智能命令，如果命令的实现对象超级智能，实现了命令所要求的功能，那么就不需要接收者了，既然没有了接收者，那么也就不需要组装者了。

​	

```java
Command.java

public interface Command {
	public void execute();
	/**
	 * 设置要输出的内容
	 * @param s 要输出的内容
	 */
	public void setStr(String s);
}

Invoker.java

public class Invoker {
	public void startPrint(Command cmd){	
		System.out.println("在Invoker中，输出服务前");
		cmd.execute();
		System.out.println("输出服务结束");
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//准备要发出的命令，没有具体实现类了
		Command cmd = new Command(){
			private String str = "";
			public void setStr(String s){
				str = s;
			}		
			public void execute() {
				System.out.println("打印的内容为="+str);
			}
		};
		cmd.setStr("退化的命令模式类似于Java回调的示例");		
		//这个时候的Invoker或许该称为服务了
		Invoker invoker = new Invoker();
		//按下按钮，真正启动执行命令
		invoker.startPrint(cmd);
	}
}
```



## 4.思考命令模式

​	命令模式的本质：   **封装请求**

​	何时选用命令模式

​	1.如果需要抽象出需要执行的动作，并参数化这些对象，可以选用命令模式，把这些需要执行的动作抽象成为命令，然后实现命令的参数化配置

​	2.如果需要在不同的时刻指定、排列和执行请求，可以选用命令模式，把这些请求封装成为命令对象，然后实现把请求队列化

​	3.如果需要支持取消操作，可以选用命令模式，通过管理命令对象，能很容易的实现命令的恢复和重做的功能

​	4.如果需要支持当系统崩溃时，能把对系统的操作功能重新执行一遍，可以选用命令模式，把这些操作功能的请求封装成命令对象，然后实现日志命令，就可以在系统恢复回来后，通过日志获取命令列表，从而重新执行一遍功能

​	5.在需要事务的系统中，可以选用命令模式，命令模式提供了对事务进行建模的方法，命令模式有一个别名就是Transaction。





# 十二、迭代器模式

## 1.初识迭代器模式

​	定义： **提供一种方法顺序访问一个聚合对象中各个元素，而不需暴露该对象的内部表示。**

​	结构与说明：

​	



​	Iterator:  迭代器的接口。定义访问和遍历元素的接口。

​	Concrete Iterator:具体的迭代器实现对象实现对聚合对象的遍历，并跟踪遍历时当前位置。 

​	Aggregate:聚合对象。定义创建相应迭代器对象的接口。

​	Concrete Aggregate: 具体聚合对象。实现创建相应的迭代器对象。



​	简单代码示例

```java
Iterator.java

/**
 * 迭代器接口，定义访问和遍历元素的操作
 */
public interface Iterator {
	/**
	 * 移动到聚合对象的第一个位置
	 */
	public void first();
	/**
	 * 移动到聚合对象的下一个位置
	 */
	public void next();
	/**
	 * 判断是否已经移动聚合对象的最后一个位置
	 * @return true表示已经移动到聚合对象的最后一个位置，
	 *         false表示还没有移动到聚合对象的最后一个位置
	 */
	public boolean isDone();
	/**
	 * 获取迭代的当前元素
	 * @return 迭代的当前元素
	 */
	public Object currentItem();
}



ConcreteIterator.java

/**
 * 具体迭代器实现对象，示意的是聚合对象为数组的迭代器
 * 不同的聚合对象相应的迭代器实现是不一样的
 */
public class ConcreteIterator implements Iterator {
	/**
	 * 持有被迭代的具体的聚合对象
	 */
	private ConcreteAggregate aggregate;
	/**
	 * 内部索引，记录当前迭代到的索引位置。
	 * -1表示刚开始的时候，迭代器指向聚合对象第一个对象之前
	 */
	private int index = -1;
	/**
	 * 构造方法，传入被迭代的具体的聚合对象
	 * @param aggregate 被迭代的具体的聚合对象
	 */
	public ConcreteIterator(ConcreteAggregate aggregate) {
		this.aggregate = aggregate;
	}

	public void first(){
		index = 0;
	}
	public void next(){
		if(index < this.aggregate.size()){
			index = index + 1;
		}
	}
	public boolean isDone(){
		if(index == this.aggregate.size()){
			return true;
		}
		return false;
	}
	public Object currentItem(){
		return this.aggregate.get(index);
	}
}

Aggregate.java
/**
 * 聚合对象的接口，定义创建相应迭代器对象的接口
 */
public abstract class Aggregate {
	/**
	 * 工厂方法，创建相应迭代器对象的接口
	 * @return 相应迭代器对象的接口
	 */
	public abstract Iterator createIterator();
}

ConcreteAggregate.java
/**
 * 具体的聚合对象，实现创建相应迭代器对象的功能
 */
public class ConcreteAggregate extends Aggregate {
	/**
	 * 示意，表示聚合对象具体的内容
	 */
	private String[] ss = null;
	
	/**
	 * 构造方法，传入聚合对象具体的内容
	 * @param ss 聚合对象具体的内容
	 */
	public ConcreteAggregate(String[] ss){
		this.ss = ss;
	}
	
	public Iterator createIterator() {
		//实现创建Iterator的工厂方法
		return new ConcreteIterator(this);
	}
	/**
	 * 获取索引所对应的元素
	 * @param index 索引
	 * @return 索引所对应的元素
	 */
	public Object get(int index){
		Object retObj = null;
		if(index < ss.length){
			retObj = ss[index];
		}
		return retObj;
	}
	/**
	 * 获取聚合对象的大小
	 * @return 聚合对象的大小
	 */
	public int size(){
		return this.ss.length;
	}
}

Client.java

public class Client {
	/**
	 * 示意方法，使用迭代器的功能。
	 * 这里示意使用迭代器来迭代聚合对象
	 */
	public void someOperation(){
		String[] names = {"张三","李四","王五"};
		//创建聚合对象
		Aggregate aggregate = new ConcreteAggregate(names);
		//循环输出聚合对象中的值
		Iterator it = aggregate.createIterator();
		//首先设置迭代器到第一个元素
		it.first();
		while(!it.isDone()){
			//取出当前的元素来
			Object obj = it.currentItem();
			System.out.println("the obj=="+obj);
			//如果还没有迭代到最后，那么就向下迭代一个
			it.next();
		}
	}	
	public static void main(String[] args) {
		//可以简单的测试一下
		Client client = new Client();
		client.someOperation();
	}
}
```

## 2.体会迭代器模式

​	![](/images/20181105114610.bmp)



![](/images/20181105133604.bmp) 











## 3.理解迭代器模式

**认识迭代器模式的功能**

​	1.迭代器模式的功能

​		迭代器模式的功能主要在于提供对聚合对象的迭代方法。









**迭代器模式的优缺点 **

​	1.更好的封装性

​	2.可以以不同的遍历方式来遍历一个聚合

​	3.迭代器简化了聚合的接口

​	4.简化客户端的调用

​	5.同一个聚合上可以有多个遍历

## 4.思考迭代器模式

​	迭代器模式的本质：  **控制访问聚合对象中的元素** 

​	

​	何时选用迭代器模式：

​		1.如果你希望提供访问一个聚合对象的内容，但是又不想暴露它的内部表示的时候，可以使用迭代器模式来提供迭代器接口，从而让客户端只是通过迭代器的接口来访问聚合对象，而无需关心聚合对象内部实现。

​		2.如果你希望有多种遍历方式可以访问聚合对象，可以使用迭代器模式

​		3.如果你希望为遍历不同的聚合对象提供一个统一的接口，可以使用迭代器模式



![](/images/20181105161019.bmp)

![](/images/20181105161042.bmp)

 

```java
PayModel.java

public class PayModel {
	private String userName;
	private double pay;
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public double getPay() {
		return pay;
	}
	public void setPay(double pay) {
		this.pay = pay;
	}
	public String toString(){
		return "userName="+userName+",pay="+pay;
	}
}


AggregationIterator.java

/**
 * 定义随机翻页访问聚合元素的迭代接口
 */
public interface AggregationIterator {
	/**
	 * 判断是否还有下一个元素，无所谓是否够一页的数据，
	 * 因为最后哪怕只有一条数据，也是要算一页的
	 * @return 如果有下一个元素，返回true，没有下一个元素就返回false
	 */
	public boolean hasNext();	
	/**
	 * 判断是否还有上一个元素，无所谓是否够一页的数据，
	 * 因为最后哪怕只有一条数据，也是要算一页的
	 * @return 如果有上一个元素，返回true，没有上一个元素就返回false
	 */
	public boolean hasPrevious();
	/**
	 * 取出指定页数的数据
	 * @param pageNum 要获取的页数
	 * @param pageShow 每页显示的数据条数
	 * @return 指定页数的数据
	 */
	public Collection getPage(int pageNum,int pageShow);
}


ArrayIteratorImpl.java
/**
 * 用来实现随机翻页访问聚合元素的迭代接口
 */
public class ArrayIteratorImpl implements AggregationIterator{
	/**
	 * 用来存放被迭代的数组
	 */
	private PayModel[] pms = null;
	/**
	 * 用来记录当前迭代到的位置索引
	 */
	private int index = 0;
	
	public ArrayIteratorImpl(SalaryManager aggregate){
		this.pms = aggregate.getPays();
	}
	
	
	public boolean hasNext() {
		//判断是否还有下一个元素
		if(pms!=null && index<=(pms.length-1)){
			return true;
		}
		return false;
	}
	
	public boolean hasPrevious() {
		if(pms!=null && index > 0){
			return true;
		}
		return false;
	}
	
	public Collection getPage(int pageNum,int pageShow){
		Collection col = new ArrayList();
		//需要在这里先计算需要获取的数据的开始条数和结束条数
		int start = (pageNum-1)*pageShow;
		int end = start + pageShow-1;
		//控制start的边界，最小是0
		if(start < 0){
			start = 0;
		}
		//控制end的边界，最大是数组的最大索引
		if(end > this.pms.length-1){
			end = this.pms.length - 1;
		}
		//每次取值都是从头开始循环，所以设置index为0
		index = 0;
		while(hasNext()  && index<=end){
			if(index >= start){
				col.add(pms[index]);
			}
			//把已访问索引加1
			index++;
		}
		return col;
	}
}


SalaryManager.java

/**
 * 被客户方收购的那个公司的工资管理类
 */
public class SalaryManager{
	/**
	 * 用数组管理
	 */
	private PayModel[] pms = null;
	/**
	 * 获取工资列表
	 * @return 工资列表
	 */
	public PayModel[] getPays(){
		return pms;
	}
	
	/**
	 * 计算工资，其实应该有很多参数，为了演示从简
	 */
	public void calcSalary(){
		//计算工资，并把工资信息填充到工资列表里面
		//为了测试，做点假数据进去
		PayModel pm1 = new PayModel();
		pm1.setPay(2200);
		pm1.setUserName("王五");
		
		PayModel pm2 = new PayModel();
		pm2.setPay(3600);
		pm2.setUserName("赵六");
		
		PayModel pm3 = new PayModel();
		pm3.setPay(2200);
		pm3.setUserName("王五二号");
		
		PayModel pm4 = new PayModel();
		pm4.setPay(3600);
		pm4.setUserName("赵六二号");
		
		PayModel pm5 = new PayModel();
		pm5.setPay(2200);
		pm5.setUserName("王五三号");
		
		pms = new PayModel[5];
		pms[0] = pm1;
		pms[1] = pm2;
		pms[2] = pm3;
		pms[3] = pm4;
		pms[4] = pm5;
	}

	public AggregationIterator createIterator() {
		return new ArrayIteratorImpl(this);
	}
}

Client.java
public class Client {
	public static void main(String[] args) {
		//访问新收购公司的工资列表
		SalaryManager salaryManager = new SalaryManager();
		//先计算再获取
		salaryManager.calcSalary();
		//得到翻页迭代器
		AggregationIterator it = salaryManager.createIterator();
		
		//获取第一页，每页显示2条
		Collection col = it.getPage(1,2);
		System.out.println("第一页数据：");
		print(col);
		//获取第二页，每页显示2条
		Collection col2 = it.getPage(2,2);
		System.out.println("第二页数据：");
		print(col2);
		//再次获取第一页
		Collection col3 = it.getPage(1,2);
		System.out.println("再次获取第一页数据：");
		print(col3);
		//获取第三页
		Collection col4 = it.getPage(3,2);
		System.out.println("获取第三页数据：");
		print(col4);
	}
	private static void print(Collection col){
		Iterator it = col.iterator();
		while(it.hasNext()){
			Object obj = it.next();
			System.out.println(obj);
		}		
	}
}
```



# 十三、组合模式

## 1.初识组合模式

​	定义：  将对象组合成树形接口以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

​	结构与说明：





​	简单代码示例

​	

```java

```



## 2.体会组合模式

![](/images/20181105164153.bmp)

![](/images/20181105164223.bmp)

![](/images/20181105164243.bmp)

![](/images/20181105164302.bmp)



```java
Component.java

/**
 * 抽象的组件对象
 */
public abstract class Component {
	/**
	 * 输出组件自身的名称
	 */
	public abstract void printStruct(String preStr);

	/**
	 * 向组合对象中加入组件对象 
	 * @param child 被加入组合对象中的组件对象
	 */
	public void addChild(Component child) {
		// 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
		throw new UnsupportedOperationException("对象不支持这个功能");
	}

	/**
	 * 从组合对象中移出某个组件对象
	 * @param child 被移出的组件对象
	 */
	public void removeChild(Component child) {
		// 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
		throw new UnsupportedOperationException("对象不支持这个功能");
	}

	/**
	 * 返回某个索引对应的组件对象
	 * @param index 需要获取的组件对象的索引，索引从0开始
	 * @return 索引对应的组件对象
	 */
	public Component getChildren(int index) {
		// 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
		throw new UnsupportedOperationException("对象不支持这个功能");
	}
}


Composite.java
/**
 * 组合对象，可以包含其它组合对象或者叶子对象
 */
public class Composite extends Component{
	/**
	 * 用来存储组合对象中包含的子组件对象
	 */
	private List<Component> childComponents = null;
	/**
	 * 组合对象的名字
	 */
	private String name = "";
	/**
	 * 构造方法，传入组合对象的名字
	 * @param name 组合对象的名字
	 */
	public Composite(String name){
		this.name = name;
	}
	
	public void addChild(Component child) {
		//延迟初始化
		if (childComponents == null) {
			childComponents = new ArrayList<Component>();
		}
		childComponents.add(child);
	}
	/**
	 * 输出组合对象自身的结构
	 * @param preStr 前缀，主要是按照层级拼接的空格，实现向后缩进
	 */
	public void printStruct(String preStr){
		//先把自己输出去
		System.out.println(preStr+"+"+this.name);
		//如果还包含有子组件，那么就输出这些子组件对象
		if(this.childComponents!=null){
			//然后添加一个空格，表示向后缩进一个空格
			preStr+=" ";		
			//输出当前对象的子对象了
			for(Component c : childComponents){
				//递归输出每个子对象
				c.printStruct(preStr);
			}
		}
	}
}


Leaf.java

/**
 * 叶子对象
 */
public class Leaf extends Component{
	/**
	 * 叶子对象的名字
	 */
	private String name = "";
	/**
	 * 构造方法，传入叶子对象的名字
	 * @param name 叶子对象的名字
	 */
	public Leaf(String name){
		this.name = name;
	}
	/**
	 * 输出叶子对象的结构，叶子对象没有子对象，也就是输出叶子对象的名字
	 * @param preStr 前缀，主要是按照层级拼接的空格，实现向后缩进
	 */
	public void printStruct(String preStr){
		System.out.println(preStr+"-"+name);
	}
}


Client.java
public class Client {
	public static void main(String[] args) {
		//定义所有的组合对象
		Component root = new Composite("服装");
		Component c1 = new Composite("男装");
		Component c2 = new Composite("女装");
		//定义所有的叶子对象
		Component leaf1 = new Leaf("衬衣");
		Component leaf2 = new Leaf("夹克");
		Component leaf3 = new Leaf("裙子");
		Component leaf4 = new Leaf("套装");
		//按照树的结构来组合组合对象和叶子对象
		root.addChild(c1);
		root.addChild(c2);
		
		c1.addChild(leaf1);
		c1.addChild(leaf2);
		
		c2.addChild(leaf3);
		c2.addChild(leaf4);
		
		//调用根对象的输出功能来输出整棵树
		root.printStruct("");
	}
}
```



## 3.理解组合模式

**认识组合模式**

1.组合模式的目的

​	组合模式的目的是让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。

​	实现整个目标的关键之处是设计一个抽象的组件类，让它可以代表组合对象和叶子对象。这样依赖，客户端就不用区分到底是组合对象还是叶子对象了，只需全部当成组件对象进行统一的操作就可以了。

2.对象树

​	通常，组合模式会组合出树形接口来，组成这个树形结构所使用的多个组合对象就自然形成了对象树。

​	这也意味着凡是可以使用对象树来描述或操作的功能，都可以考虑使用组合模式，比如读取XML文件，或是对语句进行语法解析等。

3.组合模式的递归

​	组合模式的递归，指的是对象递归组合，不是常说的递归算法。

​	而这里的组合模式中的递归，是对象本身的递归，是对象的组合方式，是从设计上来讲的，在设计上称作递归关联，是对象关联关系的一种。



## 4.理解组合模式





# 十四、模板方法模式

## 1.初识模板方法模式



## 2.体会模板方法模式



## 3.理解模板方法模式



## 4.思考模板方法模式

模板方法模式的本质是：**固定算法骨架** 



何时选用模板方法模式：

1.需要固定定义算法框架，实现一个算法不变的部分，并把可变的行为留给子类来实现的情况。

2.各个子类有公共行为，应该抽取出来在一个公共类中去实现，从而避免了代码重复。

3.需要控制子类扩展的情况，模板方法模式会在特定的点来调用子类的方法，这样只允许在这些点进行扩展。

# 十五、策略模式

## 1.初识策略模式

定义：  定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

## 2.体会策略模式



## 3.理解策略模



## 4.思考策略模式

策略模式的本质是：   **分离算法，选择实现。**



何时选用策略模式：

1.出现有许多相关的类，仅仅是行为有差别的情况，可以使用策略模式来使用多个行为中一个来配置一个类的方法，实现算法动态切换。

2.出现同一算法，有很多不同实现的情况，可使用策略模式来把这些“不同的实现”实现成为一个算法的类层次。

3.需要封装算法中，与算法相关的数据的情况，可以使用策略模式来避免暴露这些跟算法相关的数据结构。

4.出现了一个定义了很多行为的类，并且是用过多个if-else语句来选择这些行为的情况，可以使用策略模式来代替这些条件语句。



# 十六、状态模式



## 1.初识状态模式

定义：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

结构和说明

![](/images/20181106155234.bmp)



Context: 环境，也称上下文，通常用来定义客户感兴趣的接口，同时维护一个来具体处理当前状态的实例对象。

State:  状态接口，用来封装与上下文的一个特定状态所对应的行为。

ConcreteState: 具体实现状态处理的类，每个类实现一个状态的具体处理。



简单示例代码

```java
State.java

/**
 * 封装与Context的一个特定状态相关的行为
 */
public interface State {
	/**
	 * 状态对应的处理
	 * @param sampleParameter 示例参数，说明可以传入参数，具体传入
	 *             什么样的参数，传入几个参数，由具体应用来具体分析
	 */
	public void handle(String sampleParameter);
}

ConcreteStateA.java

/**
 * 实现一个与Context的一个特定状态相关的行为
 */
public class ConcreteStateA implements State {
	public void handle(String sampleParameter) {
		//实现具体的处理
	}
}

ConcreteStateB.java

/**
 * 实现一个与Context的一个特定状态相关的行为
 */
public class ConcreteStateB implements State {
	public void handle(String sampleParameter) {
		//实现具体的处理
	}
}

Context.java

/**
 * 定义客户感兴趣的接口，通常会维护一个State类型的对象实例
 */
public class Context {
	/**
	 * 持有一个State类型的对象实例
	 */
	private State state;
	/**
	 * 设置实现State的对象的实例 
	 * @param state 实现State的对象的实例 
	 */
	public void setState(State state) {
		this.state = state;
	}
	/**
	 * 用户感兴趣的接口方法
	 * @param sampleParameter 示意参数
	 */
	public void request(String sampleParameter) {
		//在处理中，会转调state来处理
		state.handle(sampleParameter);
	}
}
```



## 2.体会状态模式

![](/images/20181106155816.bmp)





```java
VoteState.java


/**
 * 封装一个投票状态相关的行为
 */
public interface VoteState {
	/**
	 * 处理状态对应的行为
	 * @param user 投票人
	 * @param voteItem 投票项
	 * @param voteManager 投票上下文，用来在实现状态对应的功能处理的时候，
	 *                    可以回调上下文的数据
	 */
	public void vote(String user,String voteItem,VoteManager voteManager);
}

NormalVoteState.java

public class NormalVoteState implements VoteState{
	public void vote(String user, String voteItem, VoteManager voteManager) {
		//正常投票
		//记录到投票记录中
		voteManager.getMapVote().put(user, voteItem);
		System.out.println("恭喜你投票成功");
	}
}

NormalVoteState2.java

public class NormalVoteState2 extends NormalVoteState{
	public void vote(String user, String voteItem, VoteManager voteManager) {
		//先调用已有的功能
		super.vote(user, voteItem, voteManager);
		//给予积分奖励，示意一下
		System.out.println("奖励积分10分");
	}
}


RepeatVoteState.java

public class RepeatVoteState implements VoteState{
	public void vote(String user, String voteItem, VoteManager voteManager) {
		//重复投票
		//暂时不做处理
		System.out.println("请不要重复投票");
	}
}


SpiteVoteState.java

public class SpiteVoteState implements VoteState{
	public void vote(String user, String voteItem, VoteManager voteManager) {
		//恶意投票
		//取消用户的投票资格，并取消投票记录
		String s = voteManager.getMapVote().get(user);
		if(s!=null){
			voteManager.getMapVote().remove(user);
		}
		System.out.println("你有恶意刷票行为，取消投票资格");
	}
}


BlackWarnVoteState.java

public class BlackWarnVoteState implements VoteState{
	public void vote(String user, String voteItem, VoteManager voteManager) {
		//待进黑名单警告状态
		System.out.println("禁止登录和使用系统3天");
	}
}


BlackVoteState.java

public class BlackVoteState implements VoteState{
	public void vote(String user, String voteItem, VoteManager voteManager) {
		//黑名单
		//记入黑名单中，禁止登录系统了
		System.out.println("进入黑名单，将禁止登录和使用本系统");
	}
}


VoteManager.java

/**
 * 投票管理
 */
public class VoteManager {
	/**
	 * 持有状态处理对象
	 */
	private VoteState state = null;
	/**
	 * 记录用户投票的结果,Map<String,String>对应Map<用户名称,投票的选项>
	 */
	private Map<String,String> mapVote = new HashMap<String,String>();
	/**
	 * 记录用户投票次数,Map<String,Integer>对应Map<用户名称,投票的次数>
	 */
	private Map<String,Integer> mapVoteCount = new HashMap<String,Integer>();
	
	/**
	 * 获取记录用户投票结果的Map
	 * @return 记录用户投票结果的Map
	 */
	public Map<String, String> getMapVote() {
		return mapVote;
	}
	
	/**
	 * 投票
	 * @param user 投票人，为了简单，就是用户名称
	 * @param voteItem 投票的选项
	 */
	public void vote(String user,String voteItem){
		//1：先为该用户增加投票的次数
		//先从记录中取出已有的投票次数
		Integer oldVoteCount = mapVoteCount.get(user);
		if(oldVoteCount==null){
			oldVoteCount = 0;
		}
		oldVoteCount = oldVoteCount + 1;
		mapVoteCount.put(user, oldVoteCount);
		
		//2：判断该用户投票的类型，就相当于是判断对应的状态
		//到底是正常投票、重复投票、恶意投票还是上黑名单的状态
		if(oldVoteCount==1){
			state = new NormalVoteState();
		}else if(oldVoteCount>1 && oldVoteCount<5){
			state = new RepeatVoteState();
		}else if(oldVoteCount >= 5 && oldVoteCount<8){
			state = new SpiteVoteState();
		}else if(oldVoteCount>=8){
			state = new BlackVoteState();
		}
		//然后转调状态对象来进行相应的操作
		state.vote(user, voteItem, this);
	}
}

Client.java

public class Client {
	public static void main(String[] args) {
		VoteManager vm = new VoteManager();
		for(int i=0;i<8;i++){
			vm.vote("u1", "A");
		}
	}
}
```



## 3.理解状态模式

**认识状态模式**

1.状态和行为

​	所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为多半可以对应到方法上。

​	状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同的状态对应的不同的功能。也就是说，状态和行为是相关联的，它们的关系可描述为：状态决定行为

​	由于状态是在运行期被改变的，因此行为也会在运行期，根据状态的改变而改变，看起来，同一个对象，在不同的运行时刻，行为是不一样的，就像是类被修改了一样

2.行为的平行性

​	注意是平行性而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互是独立的、没有关联的，是根据不同的状态来决定到底走平行线的那一条，行为是不同的，当然对应的实现也是不同的，相互之间不可替换。

​	![](/images/20181106174855.bmp)

​	而平等性强调的是可替换性，大家是同一行为的不同描述或实现，因此在同一个行为发生的时候，可以根据条件来挑选任意一个实现来进行相应的处理。

​	![](/images/20181106174949.bmp)

​	大家可能会发现状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质都是完全不一样的。这个行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。

3.上下文和状态处理对象

​	在状态模式中，上下文是持有状态的对象，但是上下文自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。

​	在具体的客户端一般只和上下文交互，客户端可以用状态对象来配置一个上下文，一旦配置完毕，就不再需要和状态对象打交道了，客户端通常不负责运行期间状态的维护，也不负责决定到底后续使用哪一个具体的状态处理对象。处理类里面经常需要获取上下文自身的数据，甚至在必要的时候会回调上下文的方法，因此，通常将上下文自身当作一个参数传递给具体的状态处理类。

4.不完美的OCP体验

​	使用状态模式来修改和扩展功能，是没有完全遵循OCP原则的。由于状态的维护和转换在状态模式结构里面，不管你是扩展了状态实现类，还是新添加了状态实现类，都需要修改状态维护和转换的地方，以使用新的实现。

5.创建和销毁状态对象

![](/images/20181106175549.bmp)

![](/images/20181106175609.bmp)





![](/images/20181106175648.bmp)

![](/images/20181106175709.bmp)

```java
LeaveRequestModel.java

/**
 * 请假单对象
 */
public class LeaveRequestModel {
	/**
	 * 请假人
	 */
	private String user;
	/**
	 * 请假开始时间
	 */
	private String beginDate;
	/**
	 * 请假天数
	 */
	private int leaveDays;
	/**
	 * 审核结果
	 */
	private String result;
	
	public String getResult() {
		return result;
	}

	public void setResult(String result) {
		this.result = result;
	}

	public String getUser() {
		return user;
	}

	public String getBeginDate() {
		return beginDate;
	}

	public int getLeaveDays() {
		return leaveDays;
	}
	public void setUser(String user) {
		this.user = user;
	}

	public void setBeginDate(String beginDate) {
		this.beginDate = beginDate;
	}

	public void setLeaveDays(int leaveDays) {
		this.leaveDays = leaveDays;
	}	
}


StateMachine.java

/**
 * 公共状态处理机，相当于状态模式的Context
 * 包含所有流程使用状态模式时的公共功能
 */
public  class StateMachine {
	/**
	 * 持有一个状态对象
	 */
	private State state = null;
	/**
	 * 包含流程处理需要的业务数据对象，不知道具体类型,
	 * 用Object，反正只是传递到具体的状态对象里面
	 */
	private Object businessVO = null;
	/**
	 * 执行工作，客户端处理流程的接口方法。
	 * 在客户完成自己的业务工作后调用
	 */
	public void doWork(){
		//转调相应的状态对象真正完成功能处理
		this.state.doWork(this);
	}
	
	public State getState() {
		return state;
	}
	public void setState(State state) {
		this.state = state;
	}
	public Object getBusinessVO() {
		return businessVO;
	}
	public void setBusinessVO(Object businessVO) {
		this.businessVO = businessVO;
	}
}

State.java
/**
 * 公共状态接口
 */
public interface State {
	/**
	 * 执行状态对应的功能处理
	 * @param ctx 上下文的实例对象
	 */
	public void doWork(StateMachine ctx);
}


LeaveRequestState.java
public interface LeaveRequestState extends State{
	//这里可以扩展跟自己流程相关的处理
}



LeaveRequestContext.java
public class LeaveRequestContext extends StateMachine{
	//这里可以扩展跟自己流程相关的处理
}


ProjectManagerState.java

/**
 * 处理项目经理的审核，处理后可能对应部门经理审核、审核结束之中的一种
 */
public class ProjectManagerState implements LeaveRequestState{
	public void doWork(StateMachine request) {
		//先把业务对象造型回来
		LeaveRequestModel lrm = (LeaveRequestModel)request.getBusinessVO();
		
		System.out.println("项目经理审核中，请稍候......");
		
		//模拟用户处理界面，通过控制台来读取数据
		System.out.println(lrm.getUser()+"申请从"+lrm.getBeginDate()+
		"开始请假"+lrm.getLeaveDays()+"天,请项目经理审核(1为同意，2为不同意)：");
		//读取从控制台输入的数据
		Scanner scanner = new Scanner(System.in);
		if(scanner.hasNext()){
			int a = scanner.nextInt();
			//设置回到上下文中
			String result = "不同意";
			if(a==1){
				result = "同意";
			}
			lrm.setResult("项目经理审核结果："+result);
			//根据选择的结果和条件来设置下一步
			if(a==1){
				if(lrm.getLeaveDays() > 3){
					//如果请假天数大于3天，而且项目经理同意了，就提交给部门经理
					request.setState(new DepManagerState());
					//继续执行下一步工作
					request.doWork();
				}else{
					//3天以内的请假，由项目经理做主,就不用提交给部门经理了，转向审核结束状态
					request.setState(new  AuditOverState());
					//继续执行下一步工作
					request.doWork();
				}				
			}else{
				//项目经理要是不同意的话，也就不用提交给部门经理了，转向审核结束状态
				request.setState(new  AuditOverState());
				//继续执行下一步工作
				request.doWork();
			}			
		}		
	}	
}

DepManagerState.java

/**
 * 处理部门经理的审核，处理后对应审核结束状态
 */
public class DepManagerState implements LeaveRequestState{
	public void doWork(StateMachine request) {
		//先把业务对象造型回来
		LeaveRequestModel lrm = (LeaveRequestModel)request.getBusinessVO();
		System.out.println("部门经理审核中，请稍候......");
		
		//模拟用户处理界面，通过控制台来读取数据
		System.out.println(lrm.getUser()+"申请从"+lrm.getBeginDate()+
		"开始请假"+lrm.getLeaveDays()+"天,请部门经理审核(1为同意，2为不同意)：");
		//读取从控制台输入的数据
		Scanner scanner = new Scanner(System.in);
		if(scanner.hasNext()){
			int a = scanner.nextInt();
			//设置回到上下文中
			String result = "不同意";
			if(a==1){
				result = "同意";
			}
			lrm.setResult("部门经理审核结果："+result);
			//部门经理审核过后，直接转向审核结束状态了
			request.setState(new AuditOverState());
			//继续执行下一步工作
			request.doWork();
		}		
	}
}

AuditOverState.java

/**
 * 处理审核结束的类
 */
public class AuditOverState implements LeaveRequestState{
	public void doWork(StateMachine request) {
		//先把业务对象造型回来
		LeaveRequestModel lrm = (LeaveRequestModel)request.getBusinessVO();
		System.out.println(lrm.getUser()+"，你的请假申请已经审核结束，结果是："+lrm.getResult());
	}
}

Client.java

public class Client {
	public static void main(String[] args) {
		//创建业务对象，并设置业务数据
		LeaveRequestModel lrm = new LeaveRequestModel();
		lrm.setUser("小李");
		lrm.setBeginDate("2010-02-08");
		lrm.setLeaveDays(5);
		
		//创建上下文对象
		LeaveRequestContext request = new LeaveRequestContext();
		//为上下文对象设置业务数据对象
		request.setBusinessVO(lrm);
		//配置上下文，作为开始的状态，以后就不管了
		request.setState(new ProjectManagerState());
		
		//请求上下文，让上下文开始处理工作
		request.doWork();
	}
}
```



**状态模式的优缺点：**

​	1.简化应用逻辑控制

​	2.更好的分离状态和行为

​	3.更好的扩展性

​	4.显式化进行状态转换

​	5.引入太多的状态类



## 4.思考状态模式

状态模式的本质是：**根据状态来分离和选择行为**



何时选用状态模式：

1.如果一个y对象的行为取决于它的状态，而且它必须在运行时刻根据状态来改变它的行为，可以使用状态模式，来把状态和行为分离开，虽然分离开了，但状态和行为是有对应关系的，可以在运行期间通过改变状态就能够调用到该状态对应状态处理对象上，从而改变对象的行为。

2.如果一个操作中含有庞大的多分支语句，而且这些分支依赖于该对象的状态。可以使用状态模式，把各个分支的处理分散包装到单独的对象处理类里面，这样，这些分支对应的对象就可以不依赖于其它对象而独立变化了。



# 十七、备忘录模式

## 1.初识备忘录模式

定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存整个状态。这样以后就可将该对象恢复到原先保存的状态中。



## 2.体会备忘录模式





## 3.理解备忘录模式





## 4.思考备忘录模式

备忘录模式的本质：   **保存和恢复内部状态**



何时选用备忘录模式

1.如果必须保存一个对象在某一个时刻的全部或者部分状态，这样在以后需要的时候，可以把该对象恢复到先前的状态。可以使用备忘录模式，使用备忘录对象来封装和保存需要保存的内部状态，然后把备忘录对象保存到管理者对象里面，在需要的时候，再从管理者对象里面获取备忘录对象，来恢复对象的状态



2.如果需要保存一个对象的内部状态，但是如果用接口来让其它对象直接得到这些需要保存的状态，将会暴露对象的实现细节并破坏对象的封装性。可以使用备忘录模式，把备忘录对象实现成为原发器对象的内部类，而且还是私有的，从而保证只有原发器对象才能访问该备忘录对象。这样既保存了需要保存的状态，又不会暴露原发器对象的内部实现细节。





# 十八、享元模式

## 1.初识享元模式

定义：运用共享技术有效地支持大量细粒度的对象。



## 2.体会享元模式





## 3.理解享元模式





## 4.思考享元模式

享元模式的本质： **分离和共享**



# 十九、解释器模式

## 1.初识解释器模式

​	定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。



## 2.体会解释器模式





## 3.理解解释器模式

**认识解释器的功能**

1.解释器模式的功能

​	解释器模式使用解释器对象来表示和处理相应的语法规则，一般一个解释器处理一条语法规则。理论上来说，只要能用解释器对象把服务语法的表达式表示出来，而且能够构成抽象的语法树，那都可以使用解释器模式来处理。

2.语法规则和解释器

​	语法规则和解释器之间是有对应关系的，一般一个解释器处理一条语法规则，但是反过来并不成立，一条语法规则是可以有多种解释和处理的，也就是一条语法规则可以对应多个解释器对象。

3.上下文的公用性

​	上下文在解释器模式中起到非常重要的作用，由于上下文会被传递到所有的解释器中，因此可以在上下文中存储和访问解释器的状态，比如前面的解释器可以存储一些数据在上下文中，后面的解释器就可以获取这些值。

​	另外还可以通过上下文传递一些在解释器外部，但是解释器需要的数据，也可以是一些全局的，公共的数据。

​	上下文还有一个功能，可以提供所有解释器对象的公共功能，类似于对象组合，而不是使用继承来获取公共功能，在每个解释器对象里面都可以调用。

4.谁来构建抽象语法树

​	在前面的示例中，大家已经发现，自己在客户端手工来构建抽象语法树，是很麻烦的，但是在解释器模式中，并没有涉及这部分功能，只是负责对构建好的抽象语法树进行解释处理。前面的测试简单，所以手工构建抽象语法树也不是特别困难的事，要是复杂了呢？如果还是手工创建，那跟修改解析xml的代码也差不了多少。后面会给大家讲提供解析器来把表达式转换成为抽象语法树。

​	还有一个问题，就是一条语法规则是可以对应多个解释器对象的，也就是说同一个元素，是可以转换成多个解释器对象的，这也就意味着同样一个表达式，是可以构成不同的抽象语法树的，这也造成构建抽象语法树变得很困难，而且工作量很大。

5.谁负责解释操作

​	只要定义好了抽象语法树，解释器来负责解释执行。虽然有不同的语法规则，但是解释器不负责选择究竟用哪一个解释器对象来解释执行语法规则，选择解释器的功能在构建抽象语法树的时候就完成了。所以解释器只要忠实的按照抽象语法树解释执行就好了。

6.解释器模式的调用顺序示意图

​	![](/images/20181107094703.bmp)









**解释器模式的优缺点**

​	1.易于实现语法

​	2.易于扩展新的语法

​	3.不适合复杂的语法

## 4.思考解释器模式

解释器模式的本质：   **分离实现，解释执行**

何时选用解释器模式：

​	当有一个语言需要解释执行，并且可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式。

​	在使用解释器模式的时候，还有两个特点需要考虑，一个是语法相对应该比较简单，太复杂的语法不合适使用解释器模式；另一个是效率要求不是很高，对效率要求很高的情况下，不适合使用解释器模式。

# 二十、装饰模式

## 1.初识装饰模式

定义：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。

![](/images/20181106153739.bmp)

![](/images/20181106153800.bmp)

## 2.体会装饰模式



![](/images/20181106142424.bmp)

![](/images/20181106142444.bmp)

![](/images/20181106142646.bmp)

![](/images/20181106142727.bmp)

![](/images/20181106142752.bmp)

```java
Component.java

/**
 * 计算奖金的组件接口
 */
public abstract class Component {
	/**
	 * 计算某人在某段时间内的奖金，有些参数在演示中并不会使用，
	 * 但是在实际业务实现上是会用的，为了表示这是个具体的业务方法，
	 * 因此这些参数被保留了
	 * @param user 被计算奖金的人员
	 * @param begin 计算奖金的开始时间
	 * @param end 计算奖金的结束时间
	 * @return 某人在某段时间内的奖金
	 */
	public abstract double calcPrize(String user,Date begin,Date end);
}

ConcreteComponent.java

/**
 * 基本的实现计算奖金的类，也是被装饰器装饰的对象
 */
public class ConcreteComponent extends Component{
	
	public double calcPrize(String user, Date begin, Date end) {
		//只是一个默认的实现，默认没有奖金
		return 0;
	}
}

TempDB.java

/**
 * 在内存中模拟数据库，准备点测试数据，好计算奖金
 */
public class TempDB {
	private TempDB(){}
	/**
	 * 记录每个人的月度销售额，只用了人员，月份没有用
	 */
	public static Map<String,Double> mapMonthSaleMoney = new HashMap<String,Double>();
	
	static{
		//填充测试数据
		mapMonthSaleMoney.put("张三",10000.0);
		mapMonthSaleMoney.put("李四",20000.0);
		mapMonthSaleMoney.put("王五",30000.0);
	}
}


Decorator.java
/**
 * 装饰器的接口，需要跟被装饰的对象实现同样的接口
 */
public abstract class Decorator extends Component{
	/**
	 * 持有被装饰的组件对象
	 */
	protected Component c;
	/**
	 * 通过构造方法传入被装饰的对象
	 * @param c被装饰的对象
	 */
	public Decorator(Component c){
		this.c = c;
	}

	public double calcPrize(String user, Date begin, Date end) {
		//转调组件对象的方法
		return c.calcPrize(user, begin, end);
	}
}


MonthPrizeDecorator.java

/**
 * 装饰器对象，计算当月业务奖金
 */
public class MonthPrizeDecorator extends Decorator{
	public MonthPrizeDecorator(Component c){
		super(c);
	}
	
	public double calcPrize(String user, Date begin, Date end) {
		//1：先获取前面运算出来的奖金
		double money = super.calcPrize(user, begin, end);
		//2：然后计算当月业务奖金,按照人员和时间去获取当月的业务额，然后再乘以3%
		double prize = TempDB.mapMonthSaleMoney.get(user) * 0.03;
		System.out.println(user+"当月业务奖金"+prize);
		return money + prize;
	}

}

SumPrizeDecorator.java
/**
 * 装饰器对象，计算累计奖金
 */
public class SumPrizeDecorator extends Decorator{
	public SumPrizeDecorator(Component c){
		super(c);
	}
	
	public double calcPrize(String user, Date begin, Date end) {
		//1：先获取前面运算出来的奖金
		double money = super.calcPrize(user, begin, end);
		//2：然后计算累计奖金,其实这里应该按照人员去获取累计的业务额，然后再乘以0.1%
		//简单演示一下，假定大家的累计业务额都是1000000元
		double prize = 1000000 * 0.001;
		System.out.println(user+"累计奖金"+prize);
		return money + prize;
	}

}

GroupPrizeDecorator.java

/**
 * 装饰器对象，计算当月团队业务奖金
 */
public class GroupPrizeDecorator extends Decorator{
	public GroupPrizeDecorator(Component c){
		super(c);
	}
	
	public double calcPrize(String user, Date begin, Date end) {
		//1：先获取前面运算出来的奖金
		double money = super.calcPrize(user, begin, end);
		//2：然后计算当月团队业务奖金，先计算出团队总的业务额，然后再乘以1%
		//假设都是一个团队的
		double group = 0.0;
		for(double d : TempDB.mapMonthSaleMoney.values()){
			group += d;
		}
		double prize = group * 0.01;
		System.out.println(user+"当月团队业务奖金"+prize);
		return money + prize;
	}

}

Client.java

/**
 * 使用装饰模式的客户端
 */
public class Client {
	public static void main(String[] args) {
		//先创建计算基本奖金的类，这也是被装饰的对象
		Component c1 = new ConcreteComponent();
		
		//然后对计算的基本奖金进行装饰，这里要组合各个装饰
		//说明，各个装饰者之间最好是不要有先后顺序的限制，也就是先装饰谁和后装饰谁都应该是一样的
		
		//先组合普通业务人员的奖金计算
		Decorator d1 = new MonthPrizeDecorator(c1);
		Decorator d2 = new SumPrizeDecorator(d1);	
		
		//注意：这里只需要使用最后组合好的对象调用业务方法即可，会依次调用回去
		//日期对象都没有用上，所以传null就可以了
		double zs = d2.calcPrize("张三",null,null);		
		System.out.println("==========张三应得奖金："+zs);
		double ls = d2.calcPrize("李四",null,null);
		System.out.println("==========李四应得奖金："+ls);
		
		//如果是业务经理，还需要一个计算团队的奖金计算
		Decorator d3 = new GroupPrizeDecorator(d2);
		double ww = d3.calcPrize("王五",null,null);
		System.out.println("==========王经理应得奖金："+ww);
		
	}
}
```





## 3.理解装饰模式

**认识装饰模式**

1.装饰模式的功能 

​	装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象增加功能，相当于是改变了对象的外观。当装饰过后，从外部使用系统的角度看，就不再是使用原始的那个对象了，而是使用被一系列的装饰器装饰过后的对象。

​	这样就能够灵活的改变一个对象的功能，只要动态组合的装饰器发生了改变，那么最终所得到的对象的功能也就发生了改变。

​	变相的还得到了另外一个好处，那就是装饰器功能的复用，可以给一个对象多次增加同一个装饰器，也可以用同一个装饰器装饰不同的对象。

2.对象组合

​	在面向对象设计中，有一条很基本的规则就是“尽量使用对象组合，而不是对象继承”来扩展和复用功能，装饰模式的思考起点就是这个规则。

3.装饰器

​	装饰器实现了对被装饰对象的某些装饰功能，可以在装饰器里面调用被装饰对象的功能，获取相应的值，这其实是一种递归调用。

​	在装饰器里不仅仅是可以给被装饰对象增加功能，还可以根据需要选择是否调用被装饰对象的功能，如果不调用被装饰对象的功能，那就变成完全重新实现了，相当于动态修改了被装饰对象的功能。

​	另外一点，各个装饰器之间最好是完全独立的功能，不要有依赖，这样在进行装饰组合的时候，才没有先后顺序的限制，也就是先装饰谁和后装饰谁都应该是一样的，否则会大大降低装饰器组合的灵活性。

4.装饰器和组件类的关系

​	装饰器是用来装饰组件的，装饰器一定要实现和组件类一致的接口，保证它们是同一个类型，并具有同一个外观，这样组合完成的装饰才能够递归的调用下去。

​	组件类是不知道装饰器的存在的，装饰器给组件添加功能是一种透明的包装，组件类毫不知情。需要改变的是外部使用组件类的地方，现在需要使用包装后的类，接口是一样的，但是具体的实现类发生了改变。

5.退化形式

​	如果仅仅只是想要添加一个功能，就没有必要再设计装饰器的抽象类了，直接在装饰器里面实现跟组件一样的接口，然后实现相应的装饰功能就可以了。但是建议最好还是设计上装饰器的抽象类，这样有利于程序的扩展。



**Java中的装饰器应用**

​	![](/images/20181106144739.bmp)

![](/images/20181106144847.bmp)

![](/images/20181106145000.bmp)

![](/images/20181106151045.bmp)

![](/images/20181106151125.bmp)



```java
EncryptOutputStream.java

/**
 * 实现简单的加密
 */
public class EncryptOutputStream  extends java.io.FilterOutputStream{
	public EncryptOutputStream(OutputStream os){
		//调用父类的构造方法
		super(os);
	}
	
	public void write(int a) throws IOException {
		//先统一向后移动两位
		a = a+2;
		//97是小写的a的码值
		if(a >= (97+26)){
			//如果大于，表示已经是y或者z了，减去26就回到a或者b了
			a = a-26;
		}
		//调用父类的方法
		super.write(a);
	}
}

Client.java

public class Client {
	public static void main(String[] args) throws Exception {
		//流式输出文件
		DataOutputStream dout = new DataOutputStream(
			new EncryptOutputStream(
				new BufferedOutputStream(
					new FileOutputStream("MyEncrypt.txt"))));
		//然后就可以输出内容了
		dout.write("abcdxyz".getBytes());
		dout.close();
	}
}
```



**装饰模式和AOP**

可以使用装饰模式实现类似AOP的效果，业务可以当作被修饰的对象，而装饰器则可以看成实现的切面功能

```java
SaleModel.java

/**
 * 封装销售单的数据，简单的示意一些
 */
public class SaleModel {
	/**
	 * 销售的商品
	 */
	private String goods;
	/**
	 * 销售的数量
	 */
	private int saleNum;
	public String getGoods() {
		return goods;
	}
	public void setGoods(String goods) {
		this.goods = goods;
	}
	public int getSaleNum() {
		return saleNum;
	}
	public void setSaleNum(int saleNum) {
		this.saleNum = saleNum;
	}
	
	public String toString(){
		return "商品名称="+goods+",购买数量="+saleNum;
	}
}


GoodsSaleEbi.java

/**
 * 商品销售管理的业务接口
 */
public interface GoodsSaleEbi {
	/**
	 * 保存销售信息，本来销售数据应该是多条，太麻烦了，为了演示，简单点
	 * @param user 操作人员
	 * @param customer 客户
	 * @param saleModel 销售数据
	 * @return 是否保存成功
	 */
	public boolean sale(String user,String customer,SaleModel saleModel);
}

GoodsSaleEbo.java

public class GoodsSaleEbo implements GoodsSaleEbi{
	
	public boolean sale(String user,String customer, SaleModel saleModel) {
		System.out.println(user+"保存了"+customer+"购买 "+saleModel+" 的销售数据");
		return true;
	}
}




Decorator.java

/**
 * 装饰器的接口，需要跟被装饰的对象实现同样的接口
 */
public abstract class Decorator implements GoodsSaleEbi{
	/**
	 * 持有被装饰的组件对象
	 */
	protected GoodsSaleEbi ebi;
	/**
	 * 通过构造方法传入被装饰的对象
	 * @param ebi被装饰的对象
	 */
	public Decorator(GoodsSaleEbi ebi){
		this.ebi = ebi;
	}
}

LogDecorator.java

/**
 * 实现日志记录
 */
public class LogDecorator extends Decorator{
	public LogDecorator(GoodsSaleEbi ebi){
		super(ebi);
	}
	
	public boolean sale(String user,String customer, SaleModel saleModel) {
		//执行业务功能
		boolean f = this.ebi.sale(user, customer, saleModel);
		//在执行业务功能过后，记录日志
		DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
		System.out.println("日志记录："+user+"于"+df.format(new Date())+"时保存了一条销售记录，客户是"+customer+",购买记录是"+saleModel);
		return f;
	}

}

CheckDecorator.java
/**
 * 实现权限控制
 */
public class CheckDecorator extends Decorator{
	public CheckDecorator(GoodsSaleEbi ebi){
		super(ebi);
	}
	
	public boolean sale(String user,String customer, SaleModel saleModel) {
		//简单点，只让张三执行这个功能
		if(!"张三".equals(user)){
			System.out.println("对不起"+user+"，你没有保存销售单的权限");
			//就不再调用被装饰对象的功能了
			return false;
		}else{
			return this.ebi.sale(user, customer, saleModel);
		}		
	}
}

Client.java

public class Client {
	public static void main(String[] args) {
		//得到业务接口,组合装饰器
		GoodsSaleEbi ebi = new CheckDecorator(new LogDecorator(new GoodsSaleEbo()));
		//准备测试数据
		SaleModel saleModel = new SaleModel();
		saleModel.setGoods("Moto手机");
		saleModel.setSaleNum(2);
		//调用业务功能
		ebi.sale("张三","张三丰", saleModel);
		ebi.sale("李四","张三丰", saleModel);
	}
}
```



**装饰模式的优缺点**

1. 比继承更灵活
2. 更容易复用功能
3. 简化高层定义
4. 会产生很多细粒度对象



## 4.思考装饰模式

装饰模式的本质是：  **动态组合**



何时选用装饰模式：

1.如果需要在不影响其它对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰模式，这几乎就是装饰模式的主要功能

2.如果不合适使用子类来进行扩展的时候，可以考虑使用装饰模式，因为装饰模式是使用的“对象组合”的方式。所谓不适合用子类扩展的方式，比如：扩展功能需要的子类太多，造成子类数目呈爆炸性增长。



# 二一、职责链模式

## 1.初识职责链模式

定义： 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。







## 2.体会职责链模式

![](/images/20181107161559.bmp)



![](/images/20181107161730.bmp)

![](/images/20181107161845.bmp)

```java
Handler.java 

/**
 * 定义职责对象的接口
 */
public abstract class Handler {
	/**
	 * 持有下一个处理请求的对象
	 */
	protected Handler successor = null;
	/**
	 * 设置下一个处理请求的对象
	 * @param successor 下一个处理请求的对象
	 */
	public void setSuccessor(Handler successor){
		this.successor = successor;
	}
	/**
	 * 处理聚餐费用的申请
	 * @param user 申请人
	 * @param fee 申请的钱数
	 * @return 成功或失败的具体通知
	 */
	public abstract String handleFeeRequest(String user,double fee);
}


ProjectManager.java

public class ProjectManager extends Handler{
	
	public String handleFeeRequest(String user, double fee) {
		String str = "";
		//项目经理的权限比较小，只能在500以内
		if(fee < 500){
			//为了测试，简单点，只同意小李的
			if("小李".equals(user)){
				str = "项目经理同意"+user+"聚餐费用"+fee+"元的请求";
			}else{
				//其他人一律不同意
				str = "项目经理不同意"+user+"聚餐费用"+fee+"元的请求";
			}
			return str;
		}else{
			//超过500，继续传递给级别更高的人处理
			if(this.successor!=null){
				return successor.handleFeeRequest(user, fee);
			}
		}
		return str;
	}
}


DepManager.java

public class DepManager extends Handler{

	
	public String handleFeeRequest(String user, double fee) {
		String str = "";
		//部门经理的权限只能在1000以内
		if(fee < 1000){
			//为了测试，简单点，只同意小李申请的
			if("小李".equals(user)){
				str = "部门经理同意"+user+"聚餐费用"+fee+"元的请求";
			}else{
				//其他人一律不同意
				str = "部门经理不同意"+user+"聚餐费用"+fee+"元的请求";
			}
			return str;
		}else{
			//超过1000，继续传递给级别更高的人处理
			if(this.successor!=null){
				return this.successor.handleFeeRequest(user, fee);
			}
		}
		return str;
	}
}

GeneralManager.java

public class GeneralManager extends Handler{
	public String handleFeeRequest(String user, double fee) {
		String str = "";
		//总经理的权限很大，只要请求到了这里，他都可以处理
		if(fee >= 1000){
			//为了测试，简单点，只同意小李的
			if("小李".equals(user)){
				str = "总经理同意"+user+"聚餐费用"+fee+"元的请求";
			}else{
				//其他人一律不同意
				str = "总经理不同意"+user+"聚餐费用"+fee+"元的请求";
			}
			return str;
		}else{
			//如果还有后继的处理对象，继续传递
			if(this.successor!=null){
				return successor.handleFeeRequest(user, fee);
			}
		}
		return str;
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//先要组装职责链		
		Handler h1 = new GeneralManager();
		Handler h2 = new DepManager();
		Handler h3 = new ProjectManager();
		h3.setSuccessor(h2);
		h2.setSuccessor(h1);
		
		//开始测试
		String ret1 = h3.handleFeeRequest("小李", 300);
		System.out.println("the ret1="+ret1);	
		String ret2 = h3.handleFeeRequest("小张", 300);
		System.out.println("the ret2="+ret2);	
		
		String ret3 = h3.handleFeeRequest("小李", 600);
		System.out.println("the ret3="+ret3);	
		String ret4 = h3.handleFeeRequest("小张", 600);
		System.out.println("the ret4="+ret4);	
		
		String ret5 = h3.handleFeeRequest("小李", 1200);	
		System.out.println("the ret5="+ret5);	
		String ret6 = h3.handleFeeRequest("小张", 1200);
		System.out.println("the ret6="+ret6);	
	}
}
```







## 3.理解职责链模式

**认识职责链模式**

1.职责链模式的功能

​	职责链模式主要用来处理：“客户端发出一个请求，有多个对象都有机会来处理这一个请求，但是客户端不知道究竟谁会来处理他的请求”，这样的情况。也就是需要让请求者和接收者解耦，这样就可以动态的切换和组合接收者了。

​	要注意在标准的职责链模式里面，是只要有对象处理了请求，这个请求就到此为止，不再被传递和处理了。

​	如果是要变形使用职责链，就可以让这个请求继续传递，每个职责对象对这个请求进行一定的功能处理，从而形成一个处理请求的功能链。

2.隐式接收者

​	当客户端发出请求的时候，客户端并不知道谁会真正处理他的请求，客户端只知道他提交请求的第一个对象。从第一个处理对象开始，整个职责链里面的对象，要么自己处理请求，要么继续转发给下一个接收者。

​	也就是对于请求者而言，并不知道最终的接收者是谁，但是一般情况下，总是会有一个对象来处理的，因此称为隐式接收者。

3.如何构建链

​	![](/images/20181107163632.bmp)

​	![](/images/20181107163725.bmp)

![](/images/20181107163754.bmp)



**处理多种请求**

![](/images/20181107163924.bmp)

![](/images/20181107163955.bmp)







![](/images/20181107163955.bmp)

![](/images/20181107165542.bmp)



```java
SaleModel.java

/**
 * 封装销售单的数据，简单的示意一些
 */
public class SaleModel {
	/**
	 * 销售的商品
	 */
	private String goods;
	/**
	 * 销售的数量
	 */
	private int saleNum;
	public String getGoods() {
		return goods;
	}
	public void setGoods(String goods) {
		this.goods = goods;
	}
	public int getSaleNum() {
		return saleNum;
	}
	public void setSaleNum(int saleNum) {
		this.saleNum = saleNum;
	}
	
	public String toString(){
		return "商品名称="+goods+",销售数量="+saleNum;
	}
}


SaleHandler.java

/**
 * 定义职责对象的接口
 */
public abstract class SaleHandler {
	/**
	 * 持有下一个处理请求的对象
	 */
	protected SaleHandler successor = null;
	/**
	 * 设置下一个处理请求的对象
	 * @param successor 下一个处理请求的对象
	 */
	public void setSuccessor(SaleHandler successor){
		this.successor = successor;
	}
	/**
	 * 处理保存销售信息的请求
	 * @param user 操作人员
	 * @param customer 客户
	 * @param saleModel 销售数据
	 * @return 是否处理成功
	 */
	public abstract boolean sale(String user,String customer,SaleModel saleModel);
}

SaleSecurityCheck.java

/**
 * 进行权限检查的职责对象
 */
public class SaleSecurityCheck extends SaleHandler{
	public boolean sale(String user, String customer, SaleModel saleModel) {
		//进行权限检查，简单点，就小李能通过
		if("小李".equals(user)){
			return this.successor.sale(user, customer, saleModel);
		}else{
			System.out.println("对不起"+user+"，你没有保存销售信息的权限");
			return false;
		}		
	}
}


SaleDataCheck.java

/**
 * 进行数据通用检查的职责对象
 */
public class SaleDataCheck extends SaleHandler{
	public boolean sale(String user, String customer, SaleModel saleModel) {
		//进行数据通用检查，稍麻烦点，每个数据都要检测
		if(user==null || user.trim().length()==0){
			System.out.println("申请人不能为空");
			return false;
		}
		if(customer==null || customer.trim().length()==0){
			System.out.println("客户不能为空");
			return false;
		}
		if(saleModel==null ){
			System.out.println("销售商品的数据不能为空");
			return false;
		}
		if(saleModel.getGoods()==null ||saleModel.getGoods().trim().length()==0){
			System.out.println("销售的商品不能为空");
			return false;
		}
		if(saleModel.getSaleNum()==0){
			System.out.println("销售商品的数量不能为0");
			return false;
		}		
		//如果通过了上面的检测，那就向下继续执行
		return this.successor.sale(user, customer, saleModel);
	}
}


SaleLogicCheck.java

/**
 * 进行数据逻辑检查的职责对象
 */
public class SaleLogicCheck extends SaleHandler{
	public boolean sale(String user, String customer, SaleModel saleModel) {
		//进行数据的逻辑检查，比如检查ID的唯一性，主外键的对应关系等等
		//这里应该检查这种主外键的对应关系，比如销售商品是否存在
		//为了演示简单，直接通过吧
		
		//如果通过了上面的检测，那就向下继续执行
		return this.successor.sale(user, customer, saleModel);
	}
}


SaleMgr.java

/**
 * 真正处理销售的业务功能的职责对象
 */
public class SaleMgr extends SaleHandler{
	public boolean sale(String user, String customer, SaleModel saleModel) {
		//进行真正的业务逻辑处理
		System.out.println(user+"保存了"+customer+"购买 "+saleModel+" 的销售数据");
		return true;
	}
}


GoodsSaleEbo.java

/**
 * 商品销售管理模块的业务处理
 */
public class GoodsSaleEbo {
	/**
	 * 保存销售信息，本来销售数据应该是多条，太麻烦了，为了演示，简单点
	 * @param user 操作人员
	 * @param customer 客户
	 * @param saleModel 销售数据
	 * @return 是否保存成功
	 */
	public boolean sale(String user,String customer,SaleModel saleModel){
		//如果全部在这里处理，基本的顺序是
		//1：权限检查
		//2：通用数据检查（这个也可能在表现层已经作过了）
		//3：数据逻辑校验
		
		//4：真正的业务处理
		
		//但是现在通过功能链来做，这里就主要负责构建链
		SaleSecurityCheck ssc = new SaleSecurityCheck();
		SaleDataCheck sdc = new SaleDataCheck();
		SaleLogicCheck slc = new SaleLogicCheck();
		SaleMgr sd = new SaleMgr();
		ssc.setSuccessor(sdc);
		sdc.setSuccessor(slc);
		slc.setSuccessor(sd);
		//向链上的第一个对象发出处理的请求
		return ssc.sale(user, customer, saleModel);
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//创建业务对象
		GoodsSaleEbo ebo = new GoodsSaleEbo();
		//准备测试数据
		SaleModel saleModel = new SaleModel();
		saleModel.setGoods("张学友怀旧经典");
		saleModel.setSaleNum(10);
		
		//调用业务功能
		ebo.sale("小李", "张三", saleModel);
		ebo.sale("小张", "李四", saleModel);
	}
}
```



**职责链模式的优缺点**

1.请求者和接收者松散耦合

2.动态组合职责

3.产生很多细粒度的对象

4.不一定能处理





## 4.思考职责链模式

职责链模式的本质： **分离职责，动态组合**

**何时选用职责链模式**

1.如果有多个对象可以处理同一个请求，但是具体由哪个对象来处理该请求，是运行时刻动态确定的。这种情况可以使用职责链模式，把处理请求的对象实现成为职责对象，然后把它们构成一个职责链，当请求在这个链中传递的时候，具体由哪个职责对象来处理，会在运行时动态判断

2.如果你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求的话，可以使用职责链模式，职责链模式实现了请求者和接收者之间的解耦，请求者不需要知道究竟是哪一个接收者对象来处理了请求。

3.如果想要动态指定处理一个请求的对象集合，可以使用职责链模式，职责链模式能动态的构建职责链，也就是动态的来决定到底哪些职责对象来参与到处理请求中来，相当于是动态指定了处理一个请求的职责对象集合



# 二二、桥接模式

## 1.初识桥接模式

定义： 将抽象部分与它的实现部分分离，使它们都可以独立的变化。



## 2.体会桥接模式

![](/images/20181107140137.bmp)





![](/images/20181107140232.bmp)



```java
MessageImplementor.java
/**
 * 实现发送消息的统一接口
 */
public interface MessageImplementor {
	/**
	 * 发送消息
	 * @param message 要发送的消息内容
	 * @param toUser 把消息发送的目的人员
	 */
	public void send(String message,String toUser);
}


MessageEmail.java

/**
 * 以Email的方式发送消息
 */
public class MessageEmail implements MessageImplementor{

	public void send(String message, String toUser) {
		System.out.println("使用Email的方式，发送消息'"+message+"'给"+toUser);
	}
}

MessageMobile.java

/**
 * 以手机短消息的方式发送消息
 */
public  class MessageMobile implements MessageImplementor{

	public void send(String message, String toUser) {
		System.out.println("使用手机短消息的方式，发送消息'"+message+"'给"+toUser);
	}
}

MessageSMS.java
/**
 * 以站内短消息的方式发送消息
 */
public  class MessageSMS implements MessageImplementor{

	public void send(String message, String toUser) {
		System.out.println("使用站内短消息的方式，发送消息'"+message+"'给"+toUser);
	}
}


AbstractMessage.java
/**
 * 抽象的消息对象
 */
public abstract class AbstractMessage {
	/**
	 * 持有一个实现部分的对象
	 */
	protected MessageImplementor impl;
	/**
	 * 构造方法，传入实现部分的对象 
	 * @param impl 实现部分的对象
	 */
	public AbstractMessage(MessageImplementor impl){
		this.impl = impl;
	}
	
	/**
	 * 发送消息，转调实现部分的方法
	 * @param message 要发送的消息内容
	 * @param toUser 把消息发送的目的人员
	 */
	public void sendMessage(String message,String toUser){
		this.impl.send(message, toUser);
	}	
}


CommonMessage.java

/**
 * 普通消息
 */
public class CommonMessage extends AbstractMessage{
	public CommonMessage(MessageImplementor impl) {
		super(impl);
	}

	public void sendMessage(String message, String toUser) {
		//对于普通消息，什么都不干，直接调用父类的方法，把消息发送出去就可以了
		super.sendMessage(message, toUser);
	}	
}


UrgencyMessage.java

/**
 * 加急消息
 */
public class UrgencyMessage extends AbstractMessage{
	public UrgencyMessage(MessageImplementor impl) {
		super(impl);
	}
	public void sendMessage(String message, String toUser) {
		message = "加急："+message;
		super.sendMessage(message, toUser);
	}
	/**
	 * 监控某消息的处理过程
	 * @param messageId 被监控的消息的编号
	 * @return 包含监控到的数据对象，这里示意一下，所以用了Object
	 */
	public Object watch(String messageId) {
		//获取相应的数据，组织成监控的数据对象，然后返回		
		return null;
	}	
}


SpecialUrgencyMessage.java

/**
 * 特急消息
 */
public class SpecialUrgencyMessage extends AbstractMessage{

	public SpecialUrgencyMessage(MessageImplementor impl) {
		super(impl);
	}

	public void hurry(String messageId) {
		//执行催促的业务，发出催促的信息
	}

	public void sendMessage(String message, String toUser) {
		message = "特急："+message;
		super.sendMessage(message, toUser);
		//还需要增加一条待催促的信息
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//创建具体的实现对象
		MessageImplementor impl = new MessageSMS();

		//创建一个普通消息对象
		AbstractMessage m = new CommonMessage(impl);
		m.sendMessage("请喝一杯茶", "小李");
		
		//创建一个紧急消息对象
		m = new UrgencyMessage(impl);
		m.sendMessage("请喝一杯茶", "小李");
		
		//创建一个特急消息对象
		m = new SpecialUrgencyMessage(impl);
		m.sendMessage("请喝一杯茶", "小李");
		
		//把实现方式切换成手机短消息，然后再实现一遍
		impl = new MessageMobile();
		
		m = new CommonMessage(impl);
		m.sendMessage("请喝一杯茶", "小李");
		
		m = new UrgencyMessage(impl);
		m.sendMessage("请喝一杯茶", "小李");
		
		m = new SpecialUrgencyMessage(impl);
		m.sendMessage("请喝一杯茶", "小李");
	}
}
```





## 3.理解桥接模式

**认识桥接模式**

​	在桥接模式里面，不太好理解的就是桥接的概念，什么是桥接？为何需要桥接？如何桥接？把这些问题搞清楚了也就明白桥接的含义了。

1.什么是桥接

​	什么是桥接：所谓桥接，通俗点说就是在不同的东西之间搭一个桥，让他们能够连接起来，可以相互通讯和使用。

​	给什么东西进行桥接：为被分离了的抽象部分和实现部分来桥接。

​	在桥接模式中的桥接是单向的，也就是只能是抽象部分的对象去使用具体实现部分的对象，而不能反过来，也就是个单向桥。

2.为何需要桥接

​	为了达到让抽象部分和实现部分都可以独立变化的目的，在桥接模式中，是把抽象部分和实现部分分离开来的，虽然从程序结构上是分开了，但是在抽象部分实现的时候，还是需要使用具体的实现的，这可怎么办呢？抽象部分如何才能调用到具体实现部分的功能呢？很简单，搭个桥不就可以了，搭个桥，让抽象部分通过这个桥就可以调用到实现部分的功能了，因此需要桥接。

3.如何桥接

​	这个理解上也很简单，只要让抽象部分拥有实现部分的接口对象，这就桥接上了，在抽象部分就可以通过这个接口来调用具体实现部分的功能。也就是说，桥接在程序上就体现成了在抽象部分拥有实现部分的接口对象，维护桥接就是维护这个关系。

4.独立变化

​	桥接模式的意图：使得抽象和实现可以独立变化，都可以分别扩充。也就是说抽象部分和实现部分是一种非常松散的关系，从某个角度来讲，抽象部分和实现部分是可以完全分开的，独立的，抽象部分不过是一个使用实现部分对外接口的程序罢了。

​	如果这么看桥接模式的话，就类似于策略模式了，抽象部分需要根据某个策略，来选择真实的实现，也就是说桥接模式的抽象部分相当于策略模式的上下文。更原始的就直接类似于面向接口编程，通过接口分离的两个部分而已。但是别忘了，桥接模式的抽象部分，是可以继续扩展和变化的，而策略模式只有上下文，是不存在所谓抽象部分的。	

​	那抽象和实现为何还要组合在一起呢？原因是在抽象部分和实现部分还是存在内部联系的，抽象部分的实现通常是需要调用实现部分的功能来实现的

5.动态变换功能

​	由于桥接模式中的抽象部分和实现部分是完全分离的，因此可以在运行时动态组合具体的真实实现，从而达到动态变换功能的目的。

​	从另外一个角度看，抽象部分和实现部分没有固定的绑定关系了，因此同一个真实实现可以被不同的抽象对象使用，反过来，同一个抽象也可以有多个不同的实现。就像前面示例的那样，比如：站内短消息的实现功能，可以被普通消息、加急消息或是特急消息等不同的消息对象使用；反过来，某个消息具体的发送方式，可以是站内短消息，或者是Email，也可以是手机短消息等具体的发送方式。

6.退化的桥接模式

​	如果Implementor仅有一个实现，那么就没有必要创建Implementor接口了，这是一种桥接模式退化的情况。这个时候Abstraction和Implementor是一对一的关系，虽然如此，也还是要保持它们的分离状态，这样的话，它们才不会相互影响，才可以分别扩展。

​	也就是说，就算不要Implementor接口了，也要保持Abstraction和Implementor是分离的，模式的分离机制仍然是非常有用的。

7.桥接模式和继承

​	继承是扩展对象功能的一种常见手段，通常情况下，继承扩展的功能变化纬度都是一纬的，也就是变化的因素只有一类。

​	对于出现变化因素有两类的，也就是有两个变化纬度的情况，继承实现就会比较痛苦。比如上面的示例，就有两个变化纬度，一个是消息的类别，不同的消息类别处理不同；另外一个是消息的发送方式。

​	从理论上来说，如果用继承的方式来实现这种有两个变化纬度的情况，最后实际的实现类应该是两个纬度上可变数量的乘积那么多个。比如上面的示例，在消息类别的纬度上，目前的可变数量是3个，普通消息、加急消息和特急消息；在消息发送方式的纬度上，目前的可变数量也是3个，站内短消息、Email和手机短消息。这种情况下，如果要实现全的话，那么需要的实现类应该是：3 X3 = 9个。

8.桥接模式的调用顺序示意图

​	![](/images/20181107134219.bmp)



**谁来桥接**

​	所谓谁来桥接，就是谁来负责创建抽象部分和实现部分的关系，说得更直白点，就是谁来负责创建Implementor的对象，并把它设置到抽象部分的对象里面去，这点对于使用桥接模式来说，是十分重要的一点。



**典型例子-JDBC**

![](/images/20181107141620.bmp)

![](/images/20181107141703.bmp)

![](/images/20181107141741.bmp)

​	通过上图可以看出，基于JDBC的应用程序，使用JDBC的API，相当于是对数据库操作的抽象的扩展，算作桥接模式的抽象部分；而具体的接口实现是由驱动来完成的，驱动这边自然就相当于桥接模式的实现部分了。而桥接的方式，不再是让抽象部分持有实现部分，而是采用了类似于工厂的做法，通过DriverManager来把抽象部分和实现部分对接起来，从而实现抽象部分和实现部分解耦。
	JDBC的这种架构，把抽象和具体分离开来，从而使得抽象和具体部分都可以独立扩展。对于应用程序而言，只要选用不同的驱动，就可以让程序操作不同的数据库，而无需更改应用程序，从而实现在不同的数据库上移植；对于驱动程序而言，为数据库实现不同的驱动程序，并不会影响应用程序。而且，JDBC的这种架构，还合理的划分了应用程序开发人员和驱动程序开发人员的边界。



```java
public class JDBCTest {
	public static void main(String[] args) throws Exception {
		String sql = "具体要操作的sql语句";
		// 1：装载驱动
		Class.forName("驱动的名字");
		// 2：创建连接
		Connection conn = DriverManager.getConnection("连接数据库服务的URL", "用户名",
				"密码");

		// 3：创建statement或者是preparedStatement
		PreparedStatement pstmt = conn.prepareStatement(sql);

		// 4：执行sql，如果是查询，再获取ResultSet
		ResultSet rs = pstmt.executeQuery(sql);

		// 5：循环从ResultSet中把值取出来，封装到数据对象中去
		while (rs.next()) {
			// 取值示意，按名称取值
			String uuid = rs.getString("uuid");
			// 取值示意，按索引取值
			int age = rs.getInt(2);
		}
		//6：关闭
		rs.close();
		pstmt.close();
		conn.close();
	}
}

```



**广义桥接-Java中无处不桥接**

![](/images/20181107141953.bmp)

![](/images/20181107142020.bmp)

![](/images/20181107142047.bmp)

![](/images/20181107142118.bmp)

![](/images/20181107142139.bmp)

![](/images/20181107142205.bmp)

​	![](/images/20181107142229.bmp)



**桥接模式的优缺点**

1.分离抽象和实现部分

2.更好的扩展性

3.可动态切换实现

4.可减少子类的个数



## 4.思考桥接模式

桥接模式的本质是：**分离抽象和实现**



**桥接模式对设计原则的体现**

​	桥接模式很好的实现了开闭原则：通常应用桥接模式的地方，抽象部分和实现部分都是可变化的，也就是应用会有两个变化纬度，桥接模式就是找到这两个变化，并分别封装起来，从而合理的实现OCP。

​	桥接模式还很好的体现了：多用对象组合，少用对象继承。

**何时选用桥接模式**

1.如果你不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现

2.如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。

3.如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，也可以说对客户是透明的

4.如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目



# 二三、访问者模式

## 1.初识访问者模式

定义： 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。





## 2.体会访问者模式

​	![](/images/20181107102359.bmp)

![](/images/20181107102420.bmp)

![](/images/20181107102449.bmp)

![](/images/20181107102511.bmp)



```java
Customer.java

/**
 * 各种客户的父类
 */
public abstract class Customer {
	/**
	 * 客户编号
	 */
	private String customerId;
	/**
	 * 客户名称
	 */
	private String name;
	
	public String getCustomerId() {
		return customerId;
	}
	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}	
	
	/**
	 * 接受访问者的访问
	 * @param visitor 访问者对象
	 */
	public abstract void accept(Visitor visitor);
}


PersonalCustomer.java

/**
 * 个人客户
 */
public class PersonalCustomer extends Customer{
	/**
	 * 联系电话
	 */
	private String telephone;
	/**
	 * 年龄
	 */
	private int age;
	
	public String getTelephone() {
		return telephone;
	}
	public void setTelephone(String telephone) {
		this.telephone = telephone;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public void accept(Visitor visitor) {
		//回调访问者对象的相应方法
		visitor.visitPersonalCustomer(this);
	}
}

EnterpriseCustomer.java

/**
 * 企业客户
 */
public class EnterpriseCustomer extends Customer{
	/**
	 * 联系人
	 */
	private String linkman;
	/**
	 * 联系电话
	 */
	private String linkTelephone;
	/**
	 * 企业注册地址
	 */
	private String registerAddress;
	
	
	public String getLinkman() {
		return linkman;
	}

	public void setLinkman(String linkman) {
		this.linkman = linkman;
	}

	public String getLinkTelephone() {
		return linkTelephone;
	}

	public void setLinkTelephone(String linkTelephone) {
		this.linkTelephone = linkTelephone;
	}

	public String getRegisterAddress() {
		return registerAddress;
	}

	public void setRegisterAddress(String registerAddress) {
		this.registerAddress = registerAddress;
	}
	
	public void accept(Visitor visitor) {
		//回调访问者对象的相应方法
		visitor.visitEnterpriseCustomer(this);
	}
}


Visitor.java

/**
 * 访问者接口
 */
public interface Visitor {
	/**
	 * 访问企业客户，相当于给企业客户添加访问者的功能
	 * @param ec 企业客户的对象
	 */
	public void visitEnterpriseCustomer(EnterpriseCustomer ec);
	/**
	 * 访问个人客户，相当于给个人客户添加访问者的功能
	 * @param pc 个人客户的对象
	 */
	public void visitPersonalCustomer(PersonalCustomer pc);
}


PredilectionAnalyzeVisitor.java

/**
 * 具体的访问者，实现对客户的偏好分析
 */
public class PredilectionAnalyzeVisitor implements Visitor {
	public void visitEnterpriseCustomer(EnterpriseCustomer ec){
		//根据过往购买的历史、潜在购买意向
		//以及客户所在行业的发展趋势、客户的发展预期等的分析
		System.out.println("现在对企业客户"+ec.getName()+"进行产品偏好分析");
	}
	public void visitPersonalCustomer(PersonalCustomer pc){
		System.out.println("现在对个人客户"+pc.getName()+"进行产品偏好分析");
	}
}


ServiceRequestVisitor.java

/**
 * 具体的访问者，实现客户提出服务请求的功能
 */
public class ServiceRequestVisitor implements Visitor {
	public void visitEnterpriseCustomer(EnterpriseCustomer ec){
		//企业客户提出的具体服务请求
		System.out.println(ec.getName()+"企业提出服务请求");
	}
	public void visitPersonalCustomer(PersonalCustomer pc){
		//个人客户提出的具体服务请求
		System.out.println("客户"+pc.getName()+"提出服务请求");
	}
}


WorthAnalyzeVisitor.java

/**
 * 具体的访问者，实现对客户价值分析
 */
public class WorthAnalyzeVisitor implements Visitor {
	public void visitEnterpriseCustomer(EnterpriseCustomer ec){
		//根据购买的金额大小、购买的产品和服务的多少、购买的频率等进行分析
		//企业客户的标准会比个人客户的高
		System.out.println("现在对企业客户"+ec.getName()+"进行价值分析");
	}
	public void visitPersonalCustomer(PersonalCustomer pc){
		System.out.println("现在对个人客户"+pc.getName()+"进行价值分析");
	}
}


ObjectStructure.java

/**
 * 对象结构,通常在这里对元素对象进行遍历，让访问者能访问到所有的元素
 */
public class ObjectStructure {
	/**
	 * 要操作的客户集合
	 */
	private Collection<Customer> col = new ArrayList<Customer>();
	/**
	 * 提供给客户端操作的高层接口，具体的功能由客户端传入的访问者决定
	 * @param visitor 客户端需要使用的访问者
	 */
	public void handleRequest(Visitor visitor){
		//循环对象结构中的元素，接受访问
		for(Customer cm : col){
			cm.accept(visitor);
		}
	}
	/**
	 * 组建对象结构，向对象结构中添加元素。
	 * 不同的对象结构有不同的构建方式
	 * @param ele 加入到对象结构的元素
	 */
	public void addElement(Customer ele){
		this.col.add(ele);
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//创建ObjectStruct
		ObjectStructure os = new ObjectStructure();
		//准备点测试数据，创建客户对象，并加入ObjectStructure
		Customer cm1 = new EnterpriseCustomer();
		cm1.setName("ABC集团");
		os.addElement(cm1);
		
		Customer cm2 = new EnterpriseCustomer();
		cm2.setName("CDE公司");
		os.addElement(cm2);
		
		Customer cm3 = new PersonalCustomer();
		cm3.setName("张三");
		os.addElement(cm3);
		
		//客户提出服务请求，传入服务请求的Visitor
		ServiceRequestVisitor srVisitor = new ServiceRequestVisitor();
		os.handleRequest(srVisitor);
		
		//要对客户进行偏好分析，传入偏好分析的Visitor
		PredilectionAnalyzeVisitor paVisitor = new PredilectionAnalyzeVisitor();
		os.handleRequest(paVisitor);
		
		//要对客户进行价值分析，传入价值分析的Visitor
		WorthAnalyzeVisitor waVisitor = new WorthAnalyzeVisitor();
		os.handleRequest(waVisitor);		
	}
}
```



## 3.理解访问者模式

**认识访问者模式**

1.访问者的功能

​	访问者模式能给一系列对象，透明的增加新功能。从而避免在维护期间，对这一系列对象进行修改，而且还能变相的实现复用访问者所具有的功能。

​	由于是针对一系列对象的操作，这也导致如果只想给一系列对象中的部分对象添加功能，就会有些麻烦；而且要始终能保证把这一系列对象都要调用到，不管是循环也好，还是递归也好，总之要让每个对象都要被访问到。

2.调用通路

​	重要的就是依靠通用方法，访问者这边说要去访问，就提供一个访问的方法，如visit方法；而对象那边说，好的，我接受你的访问，提供一个接受访问的方法，如accept方法。这两个方法并不代表任何具体的功能，只是构成一个调用的通路，那么真正的功能实现在哪里呢？又如何调用到呢？

​	很简单，就在accept方法里面，回调visit的方法，从而回调到访问者的具体实现上，而这个访问者的具体实现的方法才是要添加的新的功能。

3.两次分发技术

​	访问者模式能够实现在不改变对象结构的情况下，就能给对象结构中的类增加功能，实现这个效果所使用的核心技术就是两次分发的技术。

​	在访问者模式中，当客户端调用ObjectStructure的时候，会遍历ObjectStructure中所有的元素，调用这些元素的accept方法，让这些元素来接受访问，这是请求的第一次分发；在具体的元素对象中实现accept方法的时候，会回调访问者的visit方法，等于请求被第二次分发了，请求被分发给访问者来进行处理，真正实现功能的正是访问者的visit方法。

​	两次分发技术具体的调用过程示意如图：

​		![](/images/20181107103944.bmp)

​	两次分发技术使得客户端的请求不再被静态的绑定在元素对象上，这个时候真正执行什么样的功能同时取决于访问者类型和元素类型，就算是同一种元素类型，只要访问者类型不一样，最终执行的功能也不会一样，这样一来，就可以在元素对象不变的情况下，通过改变访问者的类型，来改变真正执行的功能。
	两次分发技术还有一个优点，就是可以在程序运行期间进行动态的功能组装和切换，只需要在客户端调用时，组合使用不同的访问者对象实例即可。
	从另一个层面思考，Java回调技术也有点类似于两次分发技术，客户端调用某方法，这个方法就类似于accept方法，传入一个接口的实现对象，这个接口的实现对象就有点像是访问者，在方法内部，会回调这个接口的方法，就类似于调用访问者的visit方法，最终执行的还是接口的具体实现里面实现的功能。

4.为何不在Component中实现回调Visit方法

​	在看上面的示例的时候，细心的朋友会发现，在企业客户对象和个人客户对象中实现的accept方法从表面上看是相似的，都需要回调访问者的方法，可能就会有朋友想，为什么不把回调访问者方法的调用语句放到父类中去，那样不就可以复用了吗？

​	请注意，这是不可以的，虽然看起来是相似的语句，但其实是不同的，主要的玄机就在传入的this身上。this是代表当前的对象实例的，在企业客户对象中传递的就是企业客户对象的实例，在个人客户对象中传递的就是个人客户对象的实例，这样在访问者的实现中，就可以通过这不同的对象实例来访问不同的实例对象的数据了。

​	如果把这句话放到父类中，那么传递的就是父类对象的实例，是没有子对象的数据的，因此这句话不能放到父类中去。

5.访问者模式的调用顺序示意图

​	![](/images/20181107105155.bmp)

6.空的访问方法

​	并不是所有的访问方法都需要实现，由于访问者模式默认的是访问对象结构中的所有元素，因此在实现某些功能的时候，如果不需要涉及到某些元素的访问方法，这些方法可以实现成为空的，比如：这个访问者只想要处理组合对象，那么访问叶子对象的方法就可以为空，虽然还是需要访问所有的元素对象。
	还有一种就是有条件接受访问，在自己的accept方法里面进行判断，满足要求的接受，不满足要求的，就相当于空的访问方法，什么都不用做。



**操作组合对象结构**

​	对于使用组合模式构建的组合对象结构，对外有一个统一的外观，要想添加新的功能也不是很困难，只要在组件的接口上定义新的功能就可以了，麻烦的是这样一来，需要修改所有的子类。而且，每次添加一个新功能，都需要这么痛苦一回，修改组件接口，然后修改所有的子类，这是相当糟糕的。

​	为了让组合对象结构更灵活、更容易维护和更好的扩展性，接下来把它改造成访问者模式和组合模式组合来实现。这样在今后再进行功能改造的时候，就不需要再改动这个组合对象结构了。

​	访问者模式和组合模式组合使用的思路：首先把组合对象结构中的功能方法分离出来，虽然维护组合对象结构的方法也可以分离出来，但是为了维持组合对象结构本身，这些方法还是放在组合对象结构里面；然后把这些功能方法分别实现成为访问者对象，通过访问者模式添加到组合的对象结构中去。

​	下面通过访问者模式和组合模式组合来实现如下功能：输出对象的名称，在组合对象的名称前面添加“节点：”，在叶子对象的名称前面添加“叶子：”。

​	![](/images/20181107105639.bmp)

```java
Component.java

/**
 * 抽象的组件对象，相当于访问者模式中的元素对象
 */
public abstract class Component {
	/**
	 * 接受访问者的访问
	 * @param visitor 访问者对象
	 */
	public abstract void accept(Visitor visitor);

	/**
	 * 向组合对象中加入组件对象 
	 * @param child 被加入组合对象中的组件对象
	 */
	public void addChild(Component child) {
		// 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
		throw new UnsupportedOperationException("对象不支持这个功能");

	}
	/**
	 * 从组合对象中移出某个组件对象
	 * @param child 被移出的组件对象
	 */
	public void removeChild(Component child) {
		// 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
		throw new UnsupportedOperationException("对象不支持这个功能");

	}
	/**
	 * 返回某个索引对应的组件对象
	 * @param index 需要获取的组件对象的索引，索引从0开始
	 * @return 索引对应的组件对象
	 */
	public Component getChildren(int index) {
		throw new UnsupportedOperationException("对象不支持这个功能");
	}
}


Composite.java

/**
 * 组合对象，可以包含其它组合对象或者叶子对象，
 * 相当于访问者模式的具体Element实现对象
 */
public class Composite extends Component{
	public void accept(Visitor visitor) {
		//回调访问者对象的相应方法
		visitor.visitComposite(this);
		//循环子元素，让子元素也接受访问
		for(Component c : childComponents){
			//调用子对象接受访问，变相实现递归
			c.accept(visitor);
		}
	}
	/**
	 * 用来存储组合对象中包含的子组件对象
	 */
	private List<Component> childComponents = new ArrayList<Component>();
	/**
	 * 组合对象的名字
	 */
	private String name = "";
	/**
	 * 构造方法，传入组合对象的名字
	 * @param name 组合对象的名字
	 */
	public Composite(String name){
		this.name = name;
	}
	
	public void addChild(Component child) {
		childComponents.add(child);
	}
	public String getName() {
		return name;
	}
}


Leaf.java

/**
 * 叶子对象，相当于访问者模式的具体Element实现对象
 */
public class Leaf extends Component{
	public void accept(Visitor visitor) {
		//回调访问者对象的相应方法
		visitor.visitLeaf(this);
	}
	/**
	 * 叶子对象的名字
	 */
	private String name = "";
	/**
	 * 构造方法，传入叶子对象的名字
	 * @param name 叶子对象的名字
	 */
	public Leaf(String name){
		this.name = name;
	}
	public String getName() {
		return name;
	}
}


Visitor.java

/**
 * 访问组合对象结构的访问者接口
 */
public interface Visitor {
	/**
	 * 访问组合对象，相当于给组合对象添加访问者的功能
	 * @param composite 组合对象
	 */
	public void visitComposite(Composite composite);
	/**
	 * 访问叶子对象，相当于给叶子对象添加访问者的功能
	 * @param leaf 叶子对象
	 */
	public void visitLeaf(Leaf leaf);
}


PrintNameVisitor.java

/**
 * 具体的访问者，实现：输出对象的名称，在组合对象的名称前面添加"节点："，
 * 在叶子对象的名称前面添加"叶子："
*/
public class PrintNameVisitor implements Visitor {
	public void visitComposite(Composite composite) {
		//访问到组合对象的数据
		System.out.println("节点："+composite.getName());
	}
	public void visitLeaf(Leaf leaf) {
		//访问到叶子对象的数据		
		System.out.println("叶子："+leaf.getName());
	}
}


ObjectStructure.java

/**
 * 对象结构,通常在这里对元素对象进行遍历，让访问者能访问到所有的元素
 */
public class ObjectStructure {
	/**
	 * 表示对象结构，可以是一个组合结构
	 */
	private Component root = null;
	/**
	 * 提供给客户端操作的高层接口
	 * @param visitor 客户端需要使用的访问者
	 */
	public void handleRequest(Visitor visitor){
		//让组合对象结构中的根元素，接受访问
		//在组合对象结构中已经实现了元素的遍历
		if(root!=null){
			root.accept(visitor);
		}
	}
	/**
	 * 传入组合对象结构
	 * @param ele 组合对象结构
	 */
	public void setRoot(Component ele){
		this.root = ele;
	}
}


Client.java

public class Client {
	public static void main(String[] args) {
		//定义所有的组合对象
		Component root = new Composite("服装");
		Component c1 = new Composite("男装");
		Component c2 = new Composite("女装");
		//定义所有的叶子对象
		Component leaf1 = new Leaf("衬衣");
		Component leaf2 = new Leaf("夹克");
		Component leaf3 = new Leaf("裙子");
		Component leaf4 = new Leaf("套装");
		//按照树的结构来组合组合对象和叶子对象
		root.addChild(c1);
		root.addChild(c2);
		
		c1.addChild(leaf1);
		c1.addChild(leaf2);
		
		c2.addChild(leaf3);
		c2.addChild(leaf4);
		
		//创建ObjectStructure
		ObjectStructure os = new ObjectStructure();
		os.setRoot(root);
		
		//调用ObjectStructure来处理请求功能
		Visitor psVisitor = new PrintNameVisitor(); 
//		root.accept(psVisitor);
		
		os.handleRequest(psVisitor);
	}
}
```



**谁负责遍历所有元素对象**

​	在访问者模式中，访问者必须要能够访问到对象结构中的每个对象，因为访问者要为每个对象添加功能，为此特别在模式中定义出一个ObjectStructure来，然后由ObjectStructure来负责遍历访问一系列对象中的每个对象。



**访问者模式的优缺点**

1.好的扩展性

2.好的复用性

3.分离无关行为

4.对象结构变化很困难

5.破坏封装



## 4.思考访问者模式

访问者模式的本质： **预留通路，回调实现**

何时选用访问者模式：

1.如果想对一个对象结构，实施一些依赖于对象结构中的具体类操作，可以使用访问者模式。

2.如果想对一个对象结构中的各个元素，进行很多不同的而且不相关的操作，为了避免这些操作使得类变得复杂，可以使用访问者模式，可以使用访问者模式，，把这些操作分散到不同的访问者对象中去 ，每个访问者对象实现同一类功能。

3.如果对象结构很少变动，但是需要经常给对象结构中的元素对象定义新的操作，可以使用访问者模式



# 四：所有模式的相关模式