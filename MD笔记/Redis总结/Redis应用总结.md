Redis应用总结



# 一、Redis的简介与安装

## 1.Redis简介

​	Redis:REmote DIctionary Server(远程字典服务)。

　　是由意大利人Salvatore Sanfilippo（网名：antirez）开发的一款内存高速**缓存**数据库。是完全开源免费的，用**C语言**编写的，遵守BSD协议，高性能的(**key/value**)**分布式内存数据库**，基于内存运行并支持**持久化**的**NoSQL**数据库。

## 2.Redis下载

​	Redis 的官网是：[https://redis.io](https://redis.io/)   这是全英文的，英语不太好的，我们也可以查看中文网站：<http://www.redis.cn/> 。

　　在官网中点击 [Check the downloads page](https://redis.io/download) 

​	![](/images/20181108160842.bmp)

进入下载页面，下载最新稳定版的 Redis

##  3.安装环境

​	虚拟机安装完成之后，我们启动Linux系统，将第二步下载的 redis-4.0.9.tar.gz 文件通过工具复制到 /opt 目录下，然后在通过如下命令进行解压： 

```shell
tar -zxf redis-4.0.9.tar.gz
```

​	解压之后如下图所示： 

​	![](/images/311785863.png)

由于在安装过程中需要对源码进行编译，而编译依赖 gcc 环境。如下图所示，则是没有进行 gcc 的安装： 

![](/images/1242289705.png)

下面，我们通过如下命令进行 gcc 的安装（yum 方式需要联网）： 

```shell
yum install gcc-c++
```

安装完成之后，在输入 gcc -v 命令，则不会出现上面的提示信息了。 

## 4.编译安装

​	进入到第二步解压的Redis文件目录，然后输入 make 命令进行编译： 

```shell
 cd /opt/redis-4.0.9
 make
```

![](/images/1154819980.png)

编译完成之后，还是在该目录下输入 make install 进行构建：

　　该命令会生成 Redis的5个二进制文件，默认是在 /usr/local/bin 路径下，但是我们可以手动指定生成的文件位置，将 make install 变成：

```shell
make PREFIX=/usr/local/redis install
```

![](/images/1839471658.png)

完成之后，就会在 /usr/local/redis/bin 目录下生成如下几个二进制文件： 

​	![](/images/1540414236.png)

①、redis-server：Redis服务器 

②、redis-cli：Redis命令行客户端 

③、redis-benchmark：Redis性能测试工具 

④、redis-check-aof：AOF文件修复工具 

⑤、redis-check-rdb：RDB文件检查工具 

## **5.启动Redis**

首先，我们进入 Redis 文件的安装目录： 

![](/images/1051916558.png)

可以看到该目下有 redis.conf 配置文件，这个文件特别重要，后期的很多配置都是在这里面进行，为了防止该文件被破坏，我们可以将该文件复制到 /etc/redis 目录下： 

![](/images/101706607.png)

然后通过如下命令即可启动： 

```shell
/usr/local/redis/bin/redis-server /etc/redis/redis.conf
```

启动后出现如下界面： 

![](/images/1250904506.png)

注意：此种方式启动 Redis，当我们关闭命令窗口时，则 redis-server 程序也结束了，这显然是不友好的，我们需要将Redis设置为以守护进程的方式进行启动。

　　在 redis.conf 文件中，找到daemonize，将其设置为yes即可：

​	![](/images/1727104738.png)

还是以上面的命令启动 redis-server 服务。

启动之后可以通过如下命令查看 Redis 服务是否启动：

```shell
ps -ef | grep redis
```

启动完成之后，我们执行第 4 步编译安装的 redis-cli 文件，输入如下命令进入 Redis 客户端： 

```shell
/usr/local/redis/bin/redis-cli
```

![](/images/2044356971.png)

## 6.关闭Redis

①、redis-cli shutdown：安全关闭，但是只适用于没有配置密码的场景（一般情况下不会给Redis设置密码）。 

②、kill -9 pid：强制关闭，可能会造成Redis内存数据丢失。 



## 7.注意事项

①、我们在第 4 步编译安装生成了五个二进制文件，每次要执行该文件都要输入全路径，很不方便，为了能在任何路径下执行该二进制文件，我们可以对其进行环境变量的配置。

　　输入 vim /etc/profile 命令，将如下内容添加到文件末尾：

​	![](/images/2038037112.png)

接着输入**:wq**保存并退出，然后输入 source /etc/profile 使得配置文件生效即可。

　　接着我们便可在任意路径下启动Redis服务了：（下面是根目录下启动）

![](/images/1992875346.png)

②、可能有部分同学没有安装 gcc，直接在Redis解压目录下执行make 命令，会发现缺少编译器gcc，这时候通过 yum install gcc-c++ 命令安装gcc，然后接着执行 make 命令，但是发现还是报错： 

​	jemalloc/jemalloc.h：没有那个文件或目录 

​	原因：这次报错是因为第一次执行 make 命令有一些残存的文件没有清除干净，这时候需要执行 make distclean 命令后，再执行 make 命令即可。 



# 二、Redis配置文件介绍

​	在Redis的解压目录下有个很重要的配置文件 **redis.conf** （/opt/redis-4.0.9目录下），关于Redis的很多功能的配置都在此文件中完成的，在上一讲我也说过，一般为了不破坏安装的文件，出厂默认配置最好不要去改，所以我们将此配置文件复制到 /etc/redis/目录下了。

　　通过 vim /etc/redis/redis.conf  命令打开此文件。下面我们将详细介绍此配置文件。

## 1.开头说明

​	![](/images/861553739.png)

这里没什么好说的，需要注意的是后面需要使用内存大小时，可以指定单位，通常是以 k,gb,m的形式出现，并且**单位不区分大小写**。 

## 2.INCLUDES

​	![](/images/1781838151.png)

我们知道Redis只有一个配置文件，如果多个人进行开发维护，那么就需要多个这样的配置文件，这时候多个配置文件就可以在此通过 include /path/to/local.conf 配置进来，而原本的 redis.conf 配置文件就作为一个总闸。 

另外需要注意的时，如果将此配置写在redis.conf 文件的开头，那么后面的配置会覆盖引入文件的配置，如果想以引入文件的配置为主，那么需要将 include 配置写在 redis.conf 文件的末尾。 

## 3.MODULES

​	![](/images/1070403940.png)

redis3.0的爆炸功能是新增了集群，而redis4.0就是在3.0的基础上新增了许多功能，其中这里的 自定义模块配置就是其中之一。通过这里的 loadmodule 配置将引入自定义模块来新增一些功能。 

## 4.NETWORK

![](/images/688377503.png)

ps:这里的配置较长，我只截取了一部分，下同。

　　①、bind:绑定redis服务器网卡IP，默认为127.0.0.1,即本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind选项为空的话，那会接受所有来自于可用网络接口的连接。

　　②、port：指定redis运行的端口，默认是6379。由于Redis是单线程模型，因此单机开多个Redis进程的时候会修改端口。

　　③、timeout：设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接。默认值为0，表示不关闭。

　　④、tcp-keepalive ：单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测。

## 5.GENERAL

![](/images/280471471.png)

具体配置详解：

　　①、daemonize:设置为yes表示指定Redis以守护进程的方式启动（后台启动）。默认值为 no

　　②、pidfile:配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/redis/run/redis_6379.pid 文件里面

　　③、loglevel ：定义日志级别。默认值为notice，有如下4种取值：

　　　　　　　　　　debug（记录大量日志信息，适用于开发、测试阶段）

　　　　　　　　　　verbose（较多日志信息）

　　　　　　　　　　notice（适量日志信息，使用于生产环境）

　　　　　　　　　　warning（仅有部分重要、关键信息才会被记录）

　　④、logfile ：配置log文件地址,默认打印在命令行终端的窗口上

　　⑤、databases：设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select  <dbid> 命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。默认值是 16，也就是说默认Redis有16个数据库。

## 6.SHAPSHOTTING

​	这里的配置主要用来做持久化操作。 

​	![](/images/928144977.png)

①、save：这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘。默认如下配置： 

```shell
save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存
save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存
save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存
```

当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save "" 

②、stop-writes-on-bgsave-error ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了 

③、rdbcompression ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。 

④、rdbchecksum ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。 

⑤、dbfilename ：设置快照的文件名，默认是 dump.rdb 

⑥、dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。 

7.REPLICATION

![](/images/1905098088.png)

①、slave-serve-stale-data：默认值为yes。当一个 slave 与 master 失去联系，或者复制正在进行的时候，slave 可能会有两种表现： 

​	1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候 

  　　2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，slave 都将返回一个 "SYNC with master in progress" 的错误

②、slave-read-only：配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes。 

③、repl-diskless-sync：主从数据复制是否使用无硬盘复制功能。默认值为no。 

④、repl-diskless-sync-delay：当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。  这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段  时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5。 

⑤、repl-disable-tcp-nodelay：同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。  Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。 

## 8.SECURITY

![](/images/1268283350.png)

①、rename-command：命令重命名，对于一些危险命令例如： 

​	flushdb（清空数据库） 

​	flushall（清空所有记录） 

​	config（客户端连接后可配置服务器） 

​	keys（客户端连接后可查看所有存在的键） 

作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是是： 

- rename-command FLUSHALL ""

也可以保留命令但是不能轻易使用，重命名这个命令即可： 

- rename-command FLUSHALL abcdefg

这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown command。 

## 9.CLIENT

​	![](/images/1471166871.png)

①、maxclients ：设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件。  描述符数-32（redis server自身会使用一些），如果设置 maxclients为0 。表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 

## 10.MEMORY MANAGEMENT

![](/images/1790075947.png)

①、maxmemory：设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件。描述符数-32（redis server自身会使用一些），如果设置 maxclients为0 。表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息。 

②、maxmemory-policy ：当内存使用达到最大值时，redis使用的清楚策略。有以下几种可以选择： 

​	1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) 

​	2）allkeys-lru   利用LRU算法移除任何key 

​	3）volatile-random 移除设置过过期时间的随机key 

​	4）allkeys-random  移除随机ke 

​	5）volatile-ttl   移除即将过期的key(minor TTL)  

​	6）noeviction  noeviction   不移除任何key，只是返回一个写错误 ，默认选项 

③、maxmemory-samples ：LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)。随意你可以选择样本大小进行检，redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数。 

## 11.APPEND ONLY MODE

![](/images/1819364748.png)

①、appendonly：默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，  可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。默认值为no。 

②、appendfilename ：aof文件名，默认是"appendonly.aof" 

③、appendfsync：aof持久化策略的配置；no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据 

④、no-appendfsync-on-rewrite：在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。   设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。 

⑤、auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。 

⑥、auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。 

⑦、aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象  redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes。

##  12.LUA SCRIPTING

![](/images/1708398252.png)

①、lua-time-limit：一个lua脚本执行的最大时间，单位为ms。默认值为5000. 

## 13.REDIS CLUSTER

![](/images/2062906510.png)

①、cluster-enabled：集群开关，默认是不开启集群模式。 

②、cluster-config-file：集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。 这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件。请确保与实例运行的系统中配置文件名称不冲突。默认配置为nodes-6379.conf。 

③、cluster-node-timeout ：可以配置值为15000。节点互连超时的阀值，集群节点超时毫秒数 

④、cluster-slave-validity-factor ：可以配置值为10。在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，  导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period     如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 

⑤、cluster-migration-barrier ：可以配置值为1。master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。 

⑥、cluster-require-full-coverage：默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。  设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。

# 三、Redis的五大数据类型详细用法

 Redis 相对于 Memcache 等其他的缓存产品，有一个比较明显的优势就是 Redis 不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。介绍这些数据类型的详细使用以及顺带介绍Redis系统的相关命令用法。 

**注意：Redis的命令不区分大小写，但是key 严格区分大小写！！！** 

## **1.string数据类型**

​	string 是Redis的最基本的数据类型，可以理解为与 Memcached 一模一样的类型，一个key 对应一个 value。string 类型是二进制安全的，意思是 Redis 的 string 可以包含任何数据，比如图片或者序列化的对象，一个 redis 中字符串 value 最多可以是 512M。 

​	string 数据类型在 Redis 中的相关命令： 

​	![](/images/20181108164026.bmp)

![](/images/472653917.png)

PS：上面的 ttl 命令是返回 key 的剩余过期时间，单位为秒。

　　上面是 string 类型的基本命令，下面介绍几个自增自减操作，这在实际工作中还是特别有用的（分布式环境中统计系统的在线人数，利用Redis的高性能读写，在Redis中完成秒杀，而不是直接操作数据库。）。

![](/images/20181108164443.bmp)

![](/images/307428951.png)

## 2.hash数据类型

​	hash 是一个键值对集合，是一个 string 类型的 key和 value 的映射表，key 还是key，但是value是一个键值对（key-value）。类比于 Java里面的 Map<String,Map<String,Object>> 集合。

​	接着讲一下Hash，Hash本质上和String是一样的，无非String是纯粹的Key-Value，Hash是外面套了一层东西，里面还是Key-Value，接着我们用表格看一下Hash数据结构的相关命令： 

​	 ![](/images/20181108164700.bmp)

![](/images/1792125541.png)

## 3.list数据类型

​	list 列表，它是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表。 

![](/images/2026624164.png)

![](/images/1562218773.png)

![](/images/1057045680.png)

## 4.set数据类型

Redis 的 set 是 string 类型的无序集合。 

![](/IMAGES/20181108165144.bmp)

![](/IMAGES/20181108165204.bmp)

![](/images/1578709654.png)

## 5.zset数据类型

zset（sorted set 有序集合），和上面的set 数据类型一样，也是 string 类型元素的集合，但是它是有序的。 

![](/images/20181108165430.bmp)

![](/images/580910330.png)

## 6.系统相关命令

​	![](/images/1178536531.png)

## 7.key相关命令

关于 key 的命令应该说是最常用的，需要大家记住。 

![](/images/857227355.png)

![](/images/1573443943.png)

这里在介绍一个命令 ： 

```shell
OBJECT ENCODING    key
```

这是用来显示这五种数据类型的底层数据结构，下一篇博客我们会详细介绍。 

​	![](/images/711404655.png)



# 四、redis的底层数据结构

这五种数据类型底层是由什么数据结构构造的呢？ 

## 1.演示数据类型的实现

```shell
OBJECT ENCODING    key 
```

该命令是用来显示那五大数据类型的底层数据结构。

　　比如对于 string 数据类型：

​	![](/images/607035572.png)

我们可以看到实现string数据类型的数据结构有 embstr 以及 int。 

再比如 list 数据类型： 

​	![](/images/838051032.png)

这里我们就不做过多的演示了，那么上次出现的 embstr 以及 int 还有 quicklist 是什么数据结构呢？下面我们就来介绍Redis中几种主要的数据结构。 

## 2.简单动态字符串

​	第一篇文章我们就说过 Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamic string,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。 

**SDS 定义：** 

```c
struct sdshdr{
     //记录buf数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;
     //记录 buf 数组中未使用字节的数量
     int free;
     //字节数组，用于保存字符串
     char buf[];
}
```

用SDS保存字符串 “Redis”具体图示如下： 

![](/IMAGES/218845583.png)

我们看上面对于 SDS 数据类型的定义： 

1、len 保存了SDS保存字符串的长度 

2、buf[] 数组用来保存字符串的每个元素 

3、free j记录了 buf 数组中未使用的字节数量 

上面的定义相对于 C 语言对于字符串的定义，多出了 len 属性以及 free 属性。为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？ 

**①、常数复杂度获取字符串长度** 

由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。 

**②、杜绝缓冲区溢出** 

我们知道在 C 语言中使用 strcat  函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。 

**③、减少修改字符串的内存重新分配次数** 

C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。

　　而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：

​	1、空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。 

​	2、惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。） 

**④、二进制安全** 

​	因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。 

**⑤、兼容部分 C 字符串函数** 

​	虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<string.h> 中的一部分函数。 

**⑥、总结** 

​	![](/images/568401853.png)

一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。后面在介绍Redis的持久化时会进行介绍。 

## 3.链表

​	链表是一种常用的数据结构，C 语言内部是没有内置这种数据结构的实现，所以Redis自己构建了链表的实现。 

​	链表定义： 

```c
typedef  struct listNode{
       //前置节点
       struct listNode *prev;
       //后置节点
       struct listNode *next;
       //节点的值
       void *value;  
}listNode
```

通过多个 listNode 结构就可以组成链表，这是一个双端链表，Redis还提供了操作链表的数据结构： 

```c
typedef struct list{
     //表头节点
     listNode *head;
     //表尾节点
     listNode *tail;
     //链表所包含的节点数量
     unsigned long len;
     //节点值复制函数
     void (*free) (void *ptr);
     //节点值释放函数
     void (*free) (void *ptr);
     //节点值对比函数
     int (*match) (void *ptr,void *key);
}list;
```

![](/images/111834793.png)

Redis链表特性： 

①、双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。 

②、无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。　 

③、带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。 

④、多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。 

## 4.字典

​	字典又称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。字典中的每一个键 key 都是唯一的，通过 key 可以对值来进行查找或修改。C 语言中没有内置这种数据结构的实现，所以字典依然是 Redis自己构建的。 

​	Redis 的字典使用哈希表作为底层实现 ，哈希表结构定义:

```c
ypedef struct dictht{
     //哈希表数组
     dictEntry **table;
     //哈希表大小
     unsigned long size;
     //哈希表大小掩码，用于计算索引值
     //总是等于 size-1
     unsigned long sizemask;
     //该哈希表已有节点的数量
     unsigned long used;
 
}dictht
```

哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下： 

```c
typedef struct dictEntry{
     //键
     void *key;
     //值
     union{
          void *val;
          uint64_tu64;
          int64_ts64;
     }v;
 
     //指向下一个哈希表节点，形成链表
     struct dictEntry *next;
}dictEntry
```

key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。 

注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决**哈希冲突**。 

![](/images/11600710948.png)

**①、哈希算法：**Redis计算哈希值和索引值方法如下： 

```c
#1、使用字典设置的哈希函数，计算键 key 的哈希值
hash = dict->type->hashFunction(key);
#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值
index = hash & dict->ht[x].sizemask;
```

**②、解决哈希冲突：**这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。 

**③、扩容和收缩：**当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤： 

​	1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。 

​	2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。 

​	3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。 

**④、触发扩容的条件：** 

​	1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。 

​	2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。 

​	ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。 

**⑤、渐近式 rehash** 

​	什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。 

## 5.跳跃表

​	关于跳跃表的趣味介绍：<http://blog.jobbole.com/111731/> 

​	跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质： 

​	1、由很多层结构组成； 

​	2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点； 

​	3、最底层的链表包含了所有的元素； 

​	4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）； 

​	5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点； 

​	![](/images/949409375.png)

Redis中跳跃表节点定义如下： 

```c
typedef struct zskiplistNode {
     //层
     struct zskiplistLevel{
           //前进指针
           struct zskiplistNode *forward;
           //跨度
           unsigned int span;
     }level[];
 
     //后退指针
     struct zskiplistNode *backward;
     //分值
     double score;
     //成员对象
     robj *obj;
 
} zskiplistNode
```

多个跳跃表节点构成一个跳跃表： 

```c
typedef struct zskiplist{
     //表头节点和表尾节点
     structz skiplistNode *header, *tail;
     //表中节点的数量
     unsigned long length;
     //表中层数最大的节点的层数
     int level;
 
}zskiplist;
```

![](/images/225860439.png)

　①、搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。 

​	②、插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。 

　③、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。 

## 6.整数集合

整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。 

定义如下： 

```c
typedef struct intset{
     //编码方式
     uint32_t encoding;
     //集合包含的元素数量
     uint32_t length;
     //保存元素的数组
     int8_t contents[];
}intset;
```

整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。 

length 属性记录了 contents 数组的大小。 

需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。 

**①、升级** 

当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤： 

​	1、根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。 

​	2、将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。 

​	3、将新元素添加到整数集合中（保证有序）。 

升级能极大地节省内存。 

　**②、降级** 

​	整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。 

## 7.压缩列表

压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。 

**压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。** 

​	![](/images/1088896020.png)

压缩列表的每个节点构成如下： 

​	![](/images/899108663.png)

　①、previous_entry_ength：记录压缩列表前一个字节的长度。previous_entry_ength的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。 

②、encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。 

③、content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。 

## 8.总结

​	大多数情况下，Redis使用简单字符串SDS作为字符串的表示，相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓存区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全能存储各种类型的文件，并且还兼容部分C函数。 

​	通过为链表设置不同类型的特定函数，Redis链表可以保存各种不同类型的值，除了用作列表键，还在发布与订阅、慢查询、监视器等方面发挥作用（后面会介绍）。

​	Redis的字典底层使用哈希表实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash时使用，使用链地址法解决哈希冲突。 

​	 跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。 

​	整数集合是集合键的底层实现之一，底层由数组构成，升级特性能尽可能的节省内存。 

​	压缩列表是Redis为节省内存而开发的顺序型数据结构，通常作为列表键和哈希键的底层实现之一。 

​	以上介绍的简单字符串、链表、字典、跳跃表、整数集合、压缩列表等数据结构就是Redis底层的一些数据结构。

# 五、redis的五大数据类型实现原理

​	在Redis中，并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这些对象系统也就是前面说的五大数据类型，每一种数据类型都至少用到了一种数据结构。通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型判断一个对象是否可以执行给定的命令，而且可以针对不同的场景，为对象设置多种不同的数据结构，从而优化对象在不同场景下的使用效率。 

## 1.对象的类型和编码

​	Redis使用前面说的五大数据类型来表示键和值，每次在Redis数据库中创建一个键值对时，至少会创建两个对象，一个是键对象，一个是值对象，而Redis中的每个对象都是由 redisObject 结构来表示： 

```c
typedef struct redisObject{
     //类型
     unsigned type:4;
     //编码
     unsigned encoding:4;
     //指向底层数据结构的指针
     void *ptr;
     //引用计数
     int refcount;
     //记录最后一次被程序访问的时间
     unsigned lru:22;
 
}robj
```

**①、type属性**

​	对象的type属性记录了对象的类型，这个类型就是前面讲的五大数据类型： 

​	![](/images/1759247786.png)

可以通过如下命令来判断对象类型： 

```shell
type key
```

![](/images/892937737.png)

​	**注意：在Redis中，键总是一个字符串对象，而值可以是字符串、列表、集合等对象，所以我们通常说的键为字符串键，表示的是这个键对应的值为字符串对象，我们说一个键为集合键时，表示的是这个键对应的值为集合对象。** 

**②、encoding 属性和 *prt 指针**

对象的 prt 指针指向对象底层的数据结构，而数据结构由 encoding 属性来决定。 

![](/images/1997988837.png)

而每种类型的对象都至少使用了两种不同的编码： 

![](/images/438384530.png)

可以通过如下命令查看值对象的编码： 

```shell
OBJECT ENCODING    key
```

比如 string 类型：（可以是 embstr编码的简单字符串或者是 int 整数值实现） 

![](/images/194567473.png)

## 2.字符串对象

​	字符串是Redis最基本的数据类型，不仅所有key都是字符串类型，其它几种数据类型构成的元素也是字符串。注意字符串的长度不能超过512M。 

**①、编码** 

​	字符串对象的编码可以是int，raw或者embstr。 

​	1、int 编码：保存的是可以用 long 类型表示的整数值。 

​	2、raw 编码：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。 

​	3、embstr 编码：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。 

![](/images/1514060894.png)

​	由上可以看出，int 编码是用来保存整数值，raw编码是用来保存长字符串，而embstr是用来保存短字符串。其实 embstr 编码是专门用来保存短字符串的一种优化编码，raw 和 embstr 的区别： 

​	![](/images/666390009.png)

![](/images/696981013.png)

​	embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。

**ps：Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型。** 

**②、编码的转换** 	 

​	当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。 

​	对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。 

## 3.列表对象

​	list 列表，它是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表结构。 

**①、编码** 

​	列表对象的编码可以是 ziplist(压缩列表) 和 linkedlist(双端链表)。 关于链表和压缩列表的特性可以看我前面的[这篇博客](https://www.cnblogs.com/ysocean/p/9080942.html) 

​	比如我们执行以下命令，创建一个 key = ‘numbers’，value = ‘1 three 5’ 的三个值的列表。 

```shell
rpush numbers 1 "three" 5
```

ziplist 编码表示如下： 

​		![](/images/1999704925.png)

**linkedlist表示如下：** 

​	![](/images/1817773967.png)

**②、编码转换** 

​	当同时满足下面两个条件时，使用ziplist（压缩列表）编码： 

​	1、列表保存元素个数小于512个 

​	2、每个元素长度小于64字节 

​	不能满足这两个条件的时候使用 linkedlist 编码。 

​	上面两个条件可以在redis.conf 配置文件中的 list-max-ziplist-value选项和 list-max-ziplist-entries 选项进行配置。 

## 4.哈希对象

哈希对象的键是一个字符串类型，值是一个键值对集合。 

**①、编码** 

​	哈希对象的编码可以是 ziplist 或者 hashtable。 

​	当使用ziplist，也就是压缩列表作为底层实现时，新增的键值对是保存到压缩列表的表尾。比如执行以下命令： 	

```shell
hset profile name "Tom"
hset profile age 25
hset profile career "Programmer"
```

如果使用ziplist，profile 存储如下： 

​		![](/images/752750675.png)

当使用 hashtable 编码时，上面命令存储如下 

![](/images/980707096.png)

​	hashtable 编码的哈希表对象底层使用字典数据结构，哈希对象中的每个键值对都使用一个字典键值对。 

​	在前面介绍压缩列表时，我们介绍过压缩列表是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，相对于字典数据结构，压缩列表用于元素个数少、元素长度小的场景。其优势在于集中存储，节省空间。 

**②、编码转换** 

​	和上面列表对象使用 ziplist 编码一样，当同时满足下面两个条件时，使用ziplist（压缩列表）编码： 

​	1、列表保存元素个数小于512个 

​	2、每个元素长度小于64字节 

​	不能满足这两个条件的时候使用 hashtable 编码。第一个条件可以通过配置文件中的 set-max-intset-entries 进行修改。 

## 5.集合对象

​	集合对象 set 是 string 类型（整数也会转换成string类型进行存储）的无序集合。注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。 

**①、编码** 

​	集合对象的编码可以是 intset 或者 hashtable。 

​	intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合中。 

​	hashtable 编码的集合对象使用 字典作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值则全部设置为 null。这里可以类比Java集合中HashSet 集合的实现，HashSet 集合是由 HashMap 来实现的，集合中的元素就是 HashMap 的key，而 HashMap 的值都设为 null。 

```shell
SADD numbers 1 3 5
```

![](/images/33688989.png)

```c
SADD Dfruits "apple" "banana" "cherry"
```

![](/images/167113910.png)

**②、编码转换** 

​	当集合同时满足以下两个条件时，使用 intset 编码： 

​	1、集合对象中所有元素都是整数 

​	2、集合对象所有元素数量不超过512 

​	不能满足这两个条件的就使用 hashtable 编码。第二个条件可以通过配置文件的 set-max-intset-entries 进行配置。 

## 6.有序集合对象

​	和上面的集合对象相比，有序集合对象是有序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。 

**①、编码** 

​	有序集合的编码可以是 ziplist 或者 skiplist。 

​	ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。 

```shell
ZADD price 8.5 apple 5.0 banana 6.0 cherry
```

![](/images/539249809.png)

![](/images/1209186625.png)

​	skiplist 编码的有序集合对象使用 zet 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳跃表： 

```c
typedef struct zset{
     //跳跃表
     zskiplist *zsl;
     //字典
     dict *dice;
} zset;
```

​	字典的键保存元素的值，字典的值则保存元素的分值；跳跃表节点的 object 属性保存元素的成员，跳跃表节点的 score 属性保存元素的分值。 

​	这两种数据结构会通过指针来共享相同元素的成员和分值，所以不会产生重复成员和分值，造成内存的浪费。 

​	说明：其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独使用 字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1)的复杂度变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。 

**②、编码转换** 

​	当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码： 

​	1、保存的元素数量小于128； 

​	2、保存的所有元素长度都小于64字节。 

​	不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改 



## 7.五大数据类型的应用场景

​	对于string 数据类型，因为string 类型是二进制安全的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作计数器（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。 

​	对于 hash 数据类型，value 存放的是键值对，比如可以做单点登录存放用户信息。 

​	对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能 

​	对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判断用户名是否注册；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 

​	对于 zset 数据类型，有序的集合，可以做范围查找，排行榜应用，取 TOP N 操作等。 

## 8.内存回收和内存共享

**①、内存回收**

​	前面讲 Redis 的每个对象都是由 redisObject 结构表示： 

```c
typedef struct redisObject{
     //类型
     unsigned type:4;
     //编码
     unsigned encoding:4;
     //指向底层数据结构的指针
     void *ptr;
     //引用计数
     int refcount;
     //记录最后一次被程序访问的时间
     unsigned lru:22;
 
}robj
```

​	其中关键的 type属性，encoding 属性和 ptr 指针都介绍过了，那么 refcount 属性是干什么的呢？

​	因为 C 语言不具备自动回收内存功能，那么该如何回收内存呢？于是 Redis自己构建了一个内存回收机制，通过在 redisObject 结构中的 refcount 属性实现。这个属性会随着对象的使用状态而不断变化：

 	1、创建一个新对象，属性 refcount 初始化为1 

​	2、对象被一个新程序使用，属性 refcount 加 1 

​	3、对象不再被一个程序使用，属性 refcount 减 1 

​	4、当对象的引用计数值变为 0 时，对象所占用的内存就会被释放。 

在 Redis 中通过如下 API 来实现： 

​	![](/images/1250718951.png)

​	学过Java的应该知道，引用计数的内存回收机制其实是不被Java采用的，因为不能克服循环引用的例子（比如 A 具有 B 的引用，B 具有 C 的引用，C 具有 A 的引用，除此之外，这三个对象没有任何用处了），这时候 A B C 三个对象会一直驻留在内存中，造成内存泄露。那么 Redis 既然采用引用计数的垃圾回收机制，如何解决这个问题呢？ 

​	在前面介绍 redis.conf 配置文件时，在  MEMORY MANAGEMENT 下有个 maxmemory-policy 配置： 

​	maxmemory-policy ：当内存使用达到最大值时，redis使用的清楚策略。有以下几种可以选择：

​	1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )  

​	 2）allkeys-lru   利用LRU算法移除任何key  

​	3）volatile-random 移除设置过过期时间的随机key  

​	4）allkeys-random  移除随机key 

​	5）volatile-ttl   移除即将过期的key(minor TTL)  

​	6）noeviction  noeviction   不移除任何key，只是返回一个写错误 ，默认选项 

通过这种配置，也可以对内存进行回收。 

**②、内存共享**

​	refcount 属性除了能实现内存回收以外，还能用于内存共享。 

​	比如通过如下命令 set k1 100,创建一个键为 k1，值为100的字符串对象，接着通过如下命令 set k2 100 ，创建一个键为 k2，值为100 的字符串对象，那么 Redis 是如何做的呢？ 

​	1、将数据库键的值指针指向一个现有值的对象 

​	2、将被共享的值对象引用refcount 加 1 

 ![](/images/991054734.png)

​	注意：Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。 

​	虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。

##  9.对象的空转时长

​	在 redisObject 结构中，前面介绍了 type、encoding、ptr 和 refcount 属性，最后一个 lru 属性，该属性记录了对象最后一次被命令程序访问的时间。 	

​	使用 OBJECT IDLETIME 命令可以打印给定键的空转时长，通过将当前时间减去值对象的 lru 时间计算得到。 

​	![](/images/666739532.png)

​	lru 属性除了计算空转时长以外，还可以配合前面内存回收配置使用。如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。 

# 六、RDB持久化

​	由于 Redis 是一个内存数据库，所谓内存数据库，就是将数据库中的内容保存在内存中，这与传统的MySQL，Oracle等关系型数据库直接将内容保存到硬盘中相比，内存数据库的读写效率比传统数据库要快的多（内存的读写效率远远大于硬盘的读写效率）。但是保存在内存中也随之带来了一个缺点，一旦断电或者宕机，那么内存数据库中的数据将会全部丢失。

　　为了解决这个缺点，Redis提供了将内存数据持久化到硬盘，以及用持久化文件来恢复数据库数据的功能。Redis 支持两种形式的持久化，一种是RDB快照（snapshotting），另外一种是AOF（append-only-file）。本章先对 RDB 快照进行介绍。

## 1.RDB简介

​	RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里 

## 2.RDB触发方式

​	RDB 有两种触发方式，分别是自动触发和手动触发。 

**①、自动触发**

​	在 redis.conf 配置文件中的 SNAPSHOTTING 下。 	

​	![](/images/1421814394.png)

​	**①、save：**这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave（这个命令下面会介绍，手动触发RDB持久化的命令） 

​	默认如下配置： 

```shell
save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存
save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存
save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存
```

​	当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save "" 

​	**②、stop-writes-on-bgsave-error ：**默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了 

​	**③、rdbcompression ；**默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。 

​	**④、rdbchecksum ：**默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。 

​	**⑤、dbfilename ：**设置快照的文件名，默认是 dump.rdb 

​	**⑥、dir：**设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。默认是和当前配置文件保存在同一目录。 

​	也就是说通过在配置文件中配置的 save 方式，当实际操作满足该配置形式时就会进行 RDB 持久化，将当前的内存快照保存在 dir 配置的目录中，文件名由配置的 dbfilename 决定。 

**②、手动触发**

​	手动触发Redis进行RDB持久化的命令有两种： 

​	1、save 

​		该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。 显然该命令对于内存比较大的实例会造成长时间阻塞，这是致命的缺陷，为了解决此问题，Redis提供了第二种方式。 

​	2、bgsave 

​		执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。 

​	　**基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。** 

​	**ps:执行执行 flushall 命令，也会产生dump.rdb文件，但里面是空的，无意义** 	

## 3.恢复数据

​	将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。

　　获取 redis 的安装目录可以使用 config get dir 命令

​	![](/images/1580619697.png)

## 4.停止RDB持久化

​	有些情况下，我们只想利用Redis的缓存功能，并不像使用 Redis 的持久化功能，那么这时候我们最好停掉 RDB 持久化。可以通过上面讲的在配置文件 redis.conf 中，可以注释掉所有的 save 行来停用保存功能或者直接一个空字符串来实现停用：save "" 

​	也可以通过命令： 

```shell
redis-cli config set save " "
```

## 5.RDB的优势和劣势

**①、优势**

​	 1.RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。 

​	2.生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。 

​	3.RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 

**②、劣势**

​	 1、RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作(内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑)，频繁执行成本过高(影响性能) 

​	2、RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(版本不兼容) 

​	3、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(数据有丢失) 

## 6.RDB自动保存原理

Redis有个服务器状态结构： 

```c
struct redisService{
     //1、记录保存save条件的数组
     struct saveparam *saveparams;
     //2、修改计数器
     long long dirty;
     //3、上一次执行保存的时间
     time_t lastsave;
}
```

①、首先看记录保存save条件的数组 saveparam，里面每个元素都是一个 saveparams 结构： 

```c
struct saveparam{
     //秒数
     time_t seconds;
     //修改数
     int changes;
};
```

前面我们在 redis.conf 配置文件中进行了关于save 的配置： 		

```shell
save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存
save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存
save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存
```

那么服务器状态中的saveparam 数组将会是如下的样子： 

​	![](/images/719758439.png)

②、dirty 计数器和lastsave 属性 

​	dirty 计数器记录距离上一次成功执行 save 命令或者 bgsave 命令之后，Redis服务器进行了多少次修改（包括写入、删除、更新等操作）。 	

​	lastsave 属性是一个时间戳，记录上一次成功执行 save 命令或者 bgsave 命令的时间。 

​	通过这两个命令，当服务器成功执行一次修改操作，那么dirty 计数器就会加 1，而lastsave 属性记录上一次执行save或bgsave的时间，Redis 服务器还有一个周期性操作函数 severCron ,默认每隔 100 毫秒就会执行一次，该函数会遍历并检查 saveparams 数组中的所有保存条件，只要有一个条件被满足，那么就会执行 bgsave 命令。 

​	执行完成之后，dirty 计数器更新为 0 ，lastsave 也更新为执行命令的完成时间。 

# 七、AOF持久化









# 八、主从复制